# DP: hg updates of the 2.7 release branch (until 2014-01-11).

# hg diff -r v2.7.6 | filterdiff --exclude=.*ignore --exclude=.hg* --remove-timestamps

diff -r 3a1db0d2747e Doc/Makefile
--- a/Doc/Makefile
+++ b/Doc/Makefile
@@ -170,6 +170,7 @@
 autobuild-dev:
 	make update
 	make dist SPHINXOPTS='-A daily=1 -A versionswitcher=1'
+	-make suspicious
 
 # for quick rebuilds (HTML only)
 autobuild-html:
diff -r 3a1db0d2747e Doc/README.txt
--- a/Doc/README.txt
+++ b/Doc/README.txt
@@ -127,7 +127,7 @@
 as long as you don't change or remove the copyright notice:
 
 ----------------------------------------------------------------------
-Copyright (c) 2000-2013 Python Software Foundation.
+Copyright (c) 2000-2014 Python Software Foundation.
 All rights reserved.
 
 Copyright (c) 2000 BeOpen.com.
diff -r 3a1db0d2747e Doc/copyright.rst
--- a/Doc/copyright.rst
+++ b/Doc/copyright.rst
@@ -4,7 +4,7 @@
 
 Python and this documentation is:
 
-Copyright © 2001-2013 Python Software Foundation. All rights reserved.
+Copyright © 2001-2014 Python Software Foundation. All rights reserved.
 
 Copyright © 2000 BeOpen.com. All rights reserved.
 
diff -r 3a1db0d2747e Doc/distutils/index.rst
--- a/Doc/distutils/index.rst
+++ b/Doc/distutils/index.rst
@@ -12,6 +12,16 @@
 make Python modules and extensions easily available to a wider audience with
 very little overhead for build/release/install mechanics.
 
+.. note::
+
+   This guide only covers the basic tools for building and distributing
+   extensions that are provided as part of this version of Python. Third
+   party tools offer easier to use and more secure alternatives. Refer to the
+   `quick recommendations section
+   <https://python-packaging-user-guide.readthedocs.org/en/latest/current.html>`__
+   in the Python Packaging User Guide for more information.
+
+
 .. toctree::
    :maxdepth: 2
    :numbered:
diff -r 3a1db0d2747e Doc/extending/index.rst
--- a/Doc/extending/index.rst
+++ b/Doc/extending/index.rst
@@ -21,6 +21,15 @@
 For a detailed description of the whole Python/C API, see the separate
 :ref:`c-api-index`.
 
+.. note::
+
+   This guide only covers the basic tools for creating extensions provided
+   as part of this version of CPython. Third party tools may offer simpler
+   alternatives. Refer to the `binary extensions section
+   <https://python-packaging-user-guide.readthedocs.org/en/latest/extensions.html>`__
+   in the Python Packaging User Guide for more information.
+
+
 .. toctree::
    :maxdepth: 2
    :numbered:
diff -r 3a1db0d2747e Doc/faq/library.rst
--- a/Doc/faq/library.rst
+++ b/Doc/faq/library.rst
@@ -640,7 +640,7 @@
 .. XXX check if wiki page is still up to date
 
 A summary of available frameworks is maintained by Paul Boddie at
-http://wiki.python.org/moin/WebProgramming .
+http://wiki.python.org/moin/WebProgramming\ .
 
 Cameron Laird maintains a useful set of pages about Python web technologies at
 http://phaseit.net/claird/comp.lang.python/web_python.
diff -r 3a1db0d2747e Doc/faq/programming.rst
--- a/Doc/faq/programming.rst
+++ b/Doc/faq/programming.rst
@@ -910,7 +910,7 @@
    >>> a = array.array('c', s)
    >>> print a
    array('c', 'Hello, world')
-   >>> a[0] = 'y' ; print a
+   >>> a[0] = 'y'; print a
    array('c', 'yello, world')
    >>> a.tostring()
    'yello, world'
diff -r 3a1db0d2747e Doc/faq/windows.rst
--- a/Doc/faq/windows.rst
+++ b/Doc/faq/windows.rst
@@ -243,7 +243,7 @@
       ...
       Py_Initialize();  // Initialize Python.
       initmyAppc();  // Initialize (import) the helper class.
-      PyRun_SimpleString("import myApp") ;  // Import the shadow class.
+      PyRun_SimpleString("import myApp");  // Import the shadow class.
 
 5. There are two problems with Python's C API which will become apparent if you
    use a compiler other than MSVC, the compiler used to build pythonNN.dll.
diff -r 3a1db0d2747e Doc/howto/descriptor.rst
--- a/Doc/howto/descriptor.rst
+++ b/Doc/howto/descriptor.rst
@@ -167,7 +167,7 @@
             return self.val
 
         def __set__(self, obj, val):
-            print 'Updating' , self.name
+            print 'Updating', self.name
             self.val = val
 
     >>> class MyClass(object):
diff -r 3a1db0d2747e Doc/howto/functional.rst
--- a/Doc/howto/functional.rst
+++ b/Doc/howto/functional.rst
@@ -743,8 +743,8 @@
 Python wiki at http://wiki.python.org/moin/HowTo/Sorting.)
 
 The ``any(iter)`` and ``all(iter)`` built-ins look at the truth values of an
-iterable's contents.  :func:`any` returns True if any element in the iterable is
-a true value, and :func:`all` returns True if all of the elements are true
+iterable's contents.  :func:`any` returns ``True`` if any element in the iterable is
+a true value, and :func:`all` returns ``True`` if all of the elements are true
 values:
 
     >>> any([0,1,0])
diff -r 3a1db0d2747e Doc/howto/logging-cookbook.rst
--- a/Doc/howto/logging-cookbook.rst
+++ b/Doc/howto/logging-cookbook.rst
@@ -834,4 +834,3 @@
 
 Note that the order of items might be different according to the version of
 Python used.
-
diff -r 3a1db0d2747e Doc/howto/logging.rst
--- a/Doc/howto/logging.rst
+++ b/Doc/howto/logging.rst
@@ -122,7 +122,8 @@
 ^^^^^^^^^^^^^^^^^
 
 A very common situation is that of recording logging events in a file, so let's
-look at that next::
+look at that next. Be sure to try the following in a newly-started Python
+interpreter, and don't just continue from the session described above::
 
    import logging
    logging.basicConfig(filename='example.log',level=logging.DEBUG)
diff -r 3a1db0d2747e Doc/howto/pyporting.rst
--- a/Doc/howto/pyporting.rst
+++ b/Doc/howto/pyporting.rst
@@ -598,7 +598,7 @@
 
 To get a complete idea of what issues you will need to deal with, see the
 `What's New in Python 3.0`_. Others have reorganized the data in other formats
-such as http://docs.pythonsprints.com/python3_porting/py-porting.html .
+such as http://docs.pythonsprints.com/python3_porting/py-porting.html\ .
 
 The following are some steps to take to try to support both Python 2 & 3 from
 the same source code.
diff -r 3a1db0d2747e Doc/howto/urllib2.rst
--- a/Doc/howto/urllib2.rst
+++ b/Doc/howto/urllib2.rst
@@ -18,7 +18,7 @@
 .. sidebar:: Related Articles
 
     You may also find useful the following article on fetching web resources
-    with Python :
+    with Python:
 
     * `Basic Authentication <http://www.voidspace.org.uk/python/articles/authentication.shtml>`_
 
@@ -150,7 +150,7 @@
 to your HTTP request.
 
 Some websites [#]_ dislike being browsed by programs, or send different versions
-to different browsers [#]_ . By default urllib2 identifies itself as
+to different browsers [#]_. By default urllib2 identifies itself as
 ``Python-urllib/x.y`` (where ``x`` and ``y`` are the major and minor version
 numbers of the Python release,
 e.g. ``Python-urllib/2.5``), which may confuse the site, or just plain
@@ -439,7 +439,7 @@
 
 When authentication is required, the server sends a header (as well as the 401
 error code) requesting authentication.  This specifies the authentication scheme
-and a 'realm'. The header looks like : ``WWW-Authenticate: SCHEME
+and a 'realm'. The header looks like: ``WWW-Authenticate: SCHEME
 realm="REALM"``.
 
 e.g. ::
@@ -511,7 +511,7 @@
 setting is detected.  Normally that's a good thing, but there are occasions
 when it may not be helpful [#]_. One way to do this is to setup our own
 ``ProxyHandler``, with no proxies defined. This is done using similar steps to
-setting up a `Basic Authentication`_ handler : ::
+setting up a `Basic Authentication`_ handler: ::
 
     >>> proxy_support = urllib2.ProxyHandler({})
     >>> opener = urllib2.build_opener(proxy_support)
diff -r 3a1db0d2747e Doc/install/index.rst
--- a/Doc/install/index.rst
+++ b/Doc/install/index.rst
@@ -20,12 +20,20 @@
    Finally, it might be useful to include all the material from my "Care
    and Feeding of a Python Installation" talk in here somewhere.  Yow!
 
-.. topic:: Abstract
+This document describes the Python Distribution Utilities ("Distutils") from the
+end-user's point-of-view, describing how to extend the capabilities of a
+standard Python installation by building and installing third-party Python
+modules and extensions.
 
-   This document describes the Python Distribution Utilities ("Distutils") from the
-   end-user's point-of-view, describing how to extend the capabilities of a
-   standard Python installation by building and installing third-party Python
-   modules and extensions.
+
+.. note::
+
+   This guide only covers the basic tools for installing extensions that are
+   provided as part of this version of Python. Third party tools offer easier
+   to use and more secure alternatives. Refer to the
+   `quick recommendations section
+   <https://python-packaging-user-guide.readthedocs.org/en/latest/current.html>`__
+   in the Python Packaging User Guide for more information.
 
 
 .. _inst-intro:
diff -r 3a1db0d2747e Doc/library/argparse.rst
--- a/Doc/library/argparse.rst
+++ b/Doc/library/argparse.rst
@@ -1351,12 +1351,14 @@
    >>> parser.parse_args(['--', '-f'])
    Namespace(foo='-f', one=None)
 
+.. _prefix-matching:
 
-Argument abbreviations
-^^^^^^^^^^^^^^^^^^^^^^
+Argument abbreviations (prefix matching)
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
 The :meth:`~ArgumentParser.parse_args` method allows long options to be
-abbreviated if the abbreviation is unambiguous::
+abbreviated to a prefix, if the abbreviation is unambiguous (the prefix matches
+a unique option)::
 
    >>> parser = argparse.ArgumentParser(prog='PROG')
    >>> parser.add_argument('-bacon')
@@ -1822,6 +1824,12 @@
    >>> parser.parse_known_args(['--foo', '--badger', 'BAR', 'spam'])
    (Namespace(bar='BAR', foo=True), ['--badger', 'spam'])
 
+.. warning::
+   :ref:`Prefix matching <prefix-matching>` rules apply to
+   :meth:`parse_known_args`. The parser may consume an option even if it's just
+   a prefix of one of its known options, instead of leaving it in the remaining
+   arguments list.
+
 
 Customizing file parsing
 ^^^^^^^^^^^^^^^^^^^^^^^^
diff -r 3a1db0d2747e Doc/library/ast.rst
--- a/Doc/library/ast.rst
+++ b/Doc/library/ast.rst
@@ -257,6 +257,6 @@
    Return a formatted dump of the tree in *node*.  This is mainly useful for
    debugging purposes.  The returned string will show the names and the values
    for fields.  This makes the code impossible to evaluate, so if evaluation is
-   wanted *annotate_fields* must be set to False.  Attributes such as line
+   wanted *annotate_fields* must be set to ``False``.  Attributes such as line
    numbers and column offsets are not dumped by default.  If this is wanted,
    *include_attributes* can be set to ``True``.
diff -r 3a1db0d2747e Doc/library/base64.rst
--- a/Doc/library/base64.rst
+++ b/Doc/library/base64.rst
@@ -93,7 +93,7 @@
    digit 0 is always mapped to the letter O).  For security purposes the default is
    ``None``, so that 0 and 1 are not allowed in the input.
 
-   The decoded string is returned.  A :exc:`TypeError` is raised if *s* were
+   The decoded string is returned.  A :exc:`TypeError` is raised if *s* is
    incorrectly padded or if there are non-alphabet characters present in the
    string.
 
diff -r 3a1db0d2747e Doc/library/bdb.rst
--- a/Doc/library/bdb.rst
+++ b/Doc/library/bdb.rst
@@ -20,7 +20,7 @@
 
 The :mod:`bdb` module also defines two classes:
 
-.. class:: Breakpoint(self, file, line, temporary=0, cond=None , funcname=None)
+.. class:: Breakpoint(self, file, line, temporary=0, cond=None, funcname=None)
 
    This class implements temporary breakpoints, ignore counts, disabling and
    (re-)enabling, and conditionals.
@@ -186,17 +186,17 @@
    .. method:: user_line(frame)
 
       This method is called from :meth:`dispatch_line` when either
-      :meth:`stop_here` or :meth:`break_here` yields True.
+      :meth:`stop_here` or :meth:`break_here` yields ``True``.
 
    .. method:: user_return(frame, return_value)
 
       This method is called from :meth:`dispatch_return` when :meth:`stop_here`
-      yields True.
+      yields ``True``.
 
    .. method:: user_exception(frame, exc_info)
 
       This method is called from :meth:`dispatch_exception` when
-      :meth:`stop_here` yields True.
+      :meth:`stop_here` yields ``True``.
 
    .. method:: do_clear(arg)
 
@@ -237,7 +237,7 @@
 
    .. method:: set_quit()
 
-      Set the :attr:`quitting` attribute to True.  This raises :exc:`BdbQuit` in
+      Set the :attr:`quitting` attribute to ``True``.  This raises :exc:`BdbQuit` in
       the next call to one of the :meth:`dispatch_\*` methods.
 
 
diff -r 3a1db0d2747e Doc/library/bsddb.rst
--- a/Doc/library/bsddb.rst
+++ b/Doc/library/bsddb.rst
@@ -52,7 +52,7 @@
    Open the hash format file named *filename*.  Files never intended to be
    preserved on disk may be created by passing ``None`` as the  *filename*.  The
    optional *flag* identifies the mode used to open the file.  It may be ``'r'``
-   (read only), ``'w'`` (read-write) , ``'c'`` (read-write - create if necessary;
+   (read only), ``'w'`` (read-write), ``'c'`` (read-write - create if necessary;
    the default) or ``'n'`` (read-write - truncate to zero length).  The other
    arguments are rarely used and are just passed to the low-level :c:func:`dbopen`
    function.  Consult the Berkeley DB documentation for their use and
diff -r 3a1db0d2747e Doc/library/codecs.rst
--- a/Doc/library/codecs.rst
+++ b/Doc/library/codecs.rst
@@ -23,6 +23,29 @@
 
 It defines the following functions:
 
+.. function:: encode(obj, encoding='ascii', errors='strict')
+
+   Encodes *obj* using the codec registered for *encoding*.
+
+   *Errors* may be given to set the desired error handling scheme. The
+   default error handler is ``strict`` meaning that encoding errors raise
+   :exc:`ValueError` (or a more codec specific subclass, such as
+   :exc:`UnicodeEncodeError`). Refer to :ref:`codec-base-classes` for more
+   information on codec error handling.
+
+   .. versionadded:: 2.4
+
+.. function:: decode(obj, encoding='ascii', errors='strict')
+
+   Decodes *obj* using the codec registered for *encoding*.
+
+   *Errors* may be given to set the desired error handling scheme. The
+   default error handler is ``strict`` meaning that decoding errors raise
+   :exc:`ValueError` (or a more codec specific subclass, such as
+   :exc:`UnicodeDecodeError`). Refer to :ref:`codec-base-classes` for more
+   information on codec error handling.
+
+   .. versionadded:: 2.4
 
 .. function:: register(search_function)
 
diff -r 3a1db0d2747e Doc/library/cookielib.rst
--- a/Doc/library/cookielib.rst
+++ b/Doc/library/cookielib.rst
@@ -98,7 +98,7 @@
    Netscape and RFC 2965 cookies.  By default, RFC 2109 cookies (ie. cookies
    received in a :mailheader:`Set-Cookie` header with a version cookie-attribute of
    1) are treated according to the RFC 2965 rules.  However, if RFC 2965 handling
-   is turned off or :attr:`rfc2109_as_netscape` is True, RFC 2109 cookies are
+   is turned off or :attr:`rfc2109_as_netscape` is ``True``, RFC 2109 cookies are
    'downgraded' by the :class:`CookieJar` instance to Netscape cookies, by
    setting the :attr:`version` attribute of the :class:`Cookie` instance to 0.
    :class:`DefaultCookiePolicy` also provides some parameters to allow some
@@ -308,7 +308,7 @@
 -----------------------------------------------------------
 
 The following :class:`CookieJar` subclasses are provided for reading and
-writing .
+writing.
 
 .. class:: MozillaCookieJar(filename, delayload=None, policy=None)
 
@@ -652,7 +652,7 @@
 
 .. attribute:: Cookie.secure
 
-   True if cookie should only be returned over a secure connection.
+   ``True`` if cookie should only be returned over a secure connection.
 
 
 .. attribute:: Cookie.expires
@@ -663,7 +663,7 @@
 
 .. attribute:: Cookie.discard
 
-   True if this is a session cookie.
+   ``True`` if this is a session cookie.
 
 
 .. attribute:: Cookie.comment
@@ -680,7 +680,7 @@
 
 .. attribute:: Cookie.rfc2109
 
-   True if this cookie was received as an RFC 2109 cookie (ie. the cookie
+   ``True`` if this cookie was received as an RFC 2109 cookie (ie. the cookie
    arrived in a :mailheader:`Set-Cookie` header, and the value of the Version
    cookie-attribute in that header was 1).  This attribute is provided because
    :mod:`cookielib` may 'downgrade' RFC 2109 cookies to Netscape cookies, in
@@ -691,18 +691,18 @@
 
 .. attribute:: Cookie.port_specified
 
-   True if a port or set of ports was explicitly specified by the server (in the
+   ``True`` if a port or set of ports was explicitly specified by the server (in the
    :mailheader:`Set-Cookie` / :mailheader:`Set-Cookie2` header).
 
 
 .. attribute:: Cookie.domain_specified
 
-   True if a domain was explicitly specified by the server.
+   ``True`` if a domain was explicitly specified by the server.
 
 
 .. attribute:: Cookie.domain_initial_dot
 
-   True if the domain explicitly specified by the server began with a dot
+   ``True`` if the domain explicitly specified by the server began with a dot
    (``'.'``).
 
 Cookies may have additional non-standard cookie-attributes.  These may be
@@ -729,7 +729,7 @@
 
 .. method:: Cookie.is_expired([now=None])
 
-   True if cookie has passed the time at which the server requested it should
+   ``True`` if cookie has passed the time at which the server requested it should
    expire.  If *now* is given (in seconds since the epoch), return whether the
    cookie has expired at the specified time.
 
diff -r 3a1db0d2747e Doc/library/ctypes.rst
--- a/Doc/library/ctypes.rst
+++ b/Doc/library/ctypes.rst
@@ -215,7 +215,7 @@
 Fundamental data types
 ^^^^^^^^^^^^^^^^^^^^^^
 
-:mod:`ctypes` defines a number of primitive C compatible data types :
+:mod:`ctypes` defines a number of primitive C compatible data types:
 
 +----------------------+------------------------------------------+----------------------------+
 | ctypes type          | C type                                   | Python type                |
@@ -1714,7 +1714,7 @@
 
    WINUSERAPI int WINAPI
    MessageBoxA(
-       HWND hWnd ,
+       HWND hWnd,
        LPCSTR lpText,
        LPCSTR lpCaption,
        UINT uType);
@@ -2351,7 +2351,7 @@
 .. class:: c_bool
 
    Represent the C :c:type:`bool` datatype (more accurately, :c:type:`_Bool` from
-   C99).  Its value can be True or False, and the constructor accepts any object
+   C99).  Its value can be ``True`` or ``False``, and the constructor accepts any object
    that has a truth value.
 
    .. versionadded:: 2.6
diff -r 3a1db0d2747e Doc/library/curses.rst
--- a/Doc/library/curses.rst
+++ b/Doc/library/curses.rst
@@ -380,7 +380,7 @@
    is to be displayed.
 
 
-.. function:: newwin(begin_y, begin_x)
+.. function:: newwin(nlines, ncols)
               newwin(nlines, ncols, begin_y, begin_x)
 
    Return a new window, whose left-upper corner is at  ``(begin_y, begin_x)``, and
diff -r 3a1db0d2747e Doc/library/datetime.rst
--- a/Doc/library/datetime.rst
+++ b/Doc/library/datetime.rst
@@ -1720,7 +1720,7 @@
    making assumptions about the output value. Field orderings will vary (for
    example, "month/day/year" versus "day/month/year"), and the output may
    contain Unicode characters encoded using the locale's default encoding (for
-   example, if the current locale is ``js_JP``, the default encoding could be
+   example, if the current locale is ``ja_JP``, the default encoding could be
    any one of ``eucJP``, ``SJIS``, or ``utf-8``; use :meth:`locale.getlocale`
    to determine the current locale's encoding).
 
diff -r 3a1db0d2747e Doc/library/decimal.rst
--- a/Doc/library/decimal.rst
+++ b/Doc/library/decimal.rst
@@ -1226,52 +1226,52 @@
 
    .. method:: is_canonical(x)
 
-      Returns True if *x* is canonical; otherwise returns False.
+      Returns ``True`` if *x* is canonical; otherwise returns ``False``.
 
 
    .. method:: is_finite(x)
 
-      Returns True if *x* is finite; otherwise returns False.
+      Returns ``True`` if *x* is finite; otherwise returns ``False``.
 
 
    .. method:: is_infinite(x)
 
-      Returns True if *x* is infinite; otherwise returns False.
+      Returns ``True`` if *x* is infinite; otherwise returns ``False``.
 
 
    .. method:: is_nan(x)
 
-      Returns True if *x* is a qNaN or sNaN; otherwise returns False.
+      Returns ``True`` if *x* is a qNaN or sNaN; otherwise returns ``False``.
 
 
    .. method:: is_normal(x)
 
-      Returns True if *x* is a normal number; otherwise returns False.
+      Returns ``True`` if *x* is a normal number; otherwise returns ``False``.
 
 
    .. method:: is_qnan(x)
 
-      Returns True if *x* is a quiet NaN; otherwise returns False.
+      Returns ``True`` if *x* is a quiet NaN; otherwise returns ``False``.
 
 
    .. method:: is_signed(x)
 
-      Returns True if *x* is negative; otherwise returns False.
+      Returns ``True`` if *x* is negative; otherwise returns ``False``.
 
 
    .. method:: is_snan(x)
 
-      Returns True if *x* is a signaling NaN; otherwise returns False.
+      Returns ``True`` if *x* is a signaling NaN; otherwise returns ``False``.
 
 
    .. method:: is_subnormal(x)
 
-      Returns True if *x* is subnormal; otherwise returns False.
+      Returns ``True`` if *x* is subnormal; otherwise returns ``False``.
 
 
    .. method:: is_zero(x)
 
-      Returns True if *x* is a zero; otherwise returns False.
+      Returns ``True`` if *x* is a zero; otherwise returns ``False``.
 
 
    .. method:: ln(x)
@@ -1431,7 +1431,7 @@
 
    .. method:: same_quantum(x, y)
 
-      Returns True if the two operands have the same exponent.
+      Returns ``True`` if the two operands have the same exponent.
 
 
    .. method:: scaleb (x, y)
diff -r 3a1db0d2747e Doc/library/email.message.rst
--- a/Doc/library/email.message.rst
+++ b/Doc/library/email.message.rst
@@ -68,7 +68,7 @@
 
       Return ``True`` if the message's payload is a list of sub-\
       :class:`Message` objects, otherwise return ``False``.  When
-      :meth:`is_multipart` returns False, the payload should be a string object.
+      :meth:`is_multipart` returns ``False``, the payload should be a string object.
 
 
    .. method:: set_unixfrom(unixfrom)
diff -r 3a1db0d2747e Doc/library/exceptions.rst
--- a/Doc/library/exceptions.rst
+++ b/Doc/library/exceptions.rst
@@ -286,8 +286,7 @@
 
    Raised when an error is detected that doesn't fall in any of the other
    categories.  The associated value is a string indicating what precisely went
-   wrong.  (This exception is mostly a relic from a previous version of the
-   interpreter; it is not used very much any more.)
+   wrong.
 
 
 .. exception:: StopIteration
diff -r 3a1db0d2747e Doc/library/fcntl.rst
--- a/Doc/library/fcntl.rst
+++ b/Doc/library/fcntl.rst
@@ -24,11 +24,11 @@
 
 .. function:: fcntl(fd, op[, arg])
 
-   Perform the requested operation on file descriptor *fd* (file objects providing
-   a :meth:`~io.IOBase.fileno` method are accepted as well). The operation is
-   defined by *op*
-   and is operating system dependent.  These codes are also found in the
-   :mod:`fcntl` module. The argument *arg* is optional, and defaults to the integer
+   Perform the operation *op* on file descriptor *fd* (file objects providing
+   a :meth:`~io.IOBase.fileno` method are accepted as well).  The values used
+   for for *op* are operating system dependent, and are available as constants
+   in the :mod:`fcntl` module, using the same names as used in the relevant C
+   header files.  The argument *arg* is optional, and defaults to the integer
    value ``0``.  When present, it can either be an integer value, or a string.
    With the argument missing or an integer value, the return value of this function
    is the integer return value of the C :c:func:`fcntl` call.  When the argument is
@@ -51,6 +51,9 @@
    argument handling is even more complicated.
 
    The op parameter is limited to values that can fit in 32-bits.
+   Additional constants of interest for use as the *op* argument can be
+   found in the :mod:`termios` module, under the same names as used in
+   the relevant C header files.
 
    The parameter *arg* can be one of an integer, absent (treated identically to the
    integer ``0``), an object supporting the read-only buffer interface (most likely
diff -r 3a1db0d2747e Doc/library/functions.rst
--- a/Doc/library/functions.rst
+++ b/Doc/library/functions.rst
@@ -47,7 +47,7 @@
 
 .. function:: all(iterable)
 
-   Return True if all elements of the *iterable* are true (or if the iterable
+   Return ``True`` if all elements of the *iterable* are true (or if the iterable
    is empty).  Equivalent to::
 
       def all(iterable):
@@ -61,8 +61,8 @@
 
 .. function:: any(iterable)
 
-   Return True if any element of the *iterable* is true.  If the iterable
-   is empty, return False.  Equivalent to::
+   Return ``True`` if any element of the *iterable* is true.  If the iterable
+   is empty, return ``False``.  Equivalent to::
 
       def any(iterable):
           for element in iterable:
diff -r 3a1db0d2747e Doc/library/gc.rst
--- a/Doc/library/gc.rst
+++ b/Doc/library/gc.rst
@@ -142,8 +142,8 @@
 
 .. function:: is_tracked(obj)
 
-   Returns True if the object is currently tracked by the garbage collector,
-   False otherwise.  As a general rule, instances of atomic types aren't
+   Returns ``True`` if the object is currently tracked by the garbage collector,
+   ``False`` otherwise.  As a general rule, instances of atomic types aren't
    tracked and instances of non-atomic types (containers, user-defined
    objects...) are.  However, some type-specific optimizations can be present
    in order to suppress the garbage collector footprint of simple instances
diff -r 3a1db0d2747e Doc/library/io.rst
--- a/Doc/library/io.rst
+++ b/Doc/library/io.rst
@@ -278,7 +278,7 @@
 
    .. method:: readable()
 
-      Return ``True`` if the stream can be read from.  If False, :meth:`read`
+      Return ``True`` if the stream can be read from.  If ``False``, :meth:`read`
       will raise :exc:`IOError`.
 
    .. method:: readline(limit=-1)
diff -r 3a1db0d2747e Doc/library/itertools.rst
--- a/Doc/library/itertools.rst
+++ b/Doc/library/itertools.rst
@@ -52,12 +52,12 @@
 :func:`compress`        data, selectors                 (d[0] if s[0]), (d[1] if s[1]), ...                 ``compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F``
 :func:`dropwhile`       pred, seq                       seq[n], seq[n+1], starting when pred fails          ``dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1``
 :func:`groupby`         iterable[, keyfunc]             sub-iterators grouped by value of keyfunc(v)
-:func:`ifilter`         pred, seq                       elements of seq where pred(elem) is True            ``ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9``
-:func:`ifilterfalse`    pred, seq                       elements of seq where pred(elem) is False           ``ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8``
+:func:`ifilter`         pred, seq                       elements of seq where pred(elem) is true            ``ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9``
+:func:`ifilterfalse`    pred, seq                       elements of seq where pred(elem) is false           ``ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8``
 :func:`islice`          seq, [start,] stop [, step]     elements from seq[start:stop:step]                  ``islice('ABCDEFG', 2, None) --> C D E F G``
 :func:`imap`            func, p, q, ...                 func(p0, q0), func(p1, q1), ...                     ``imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000``
 :func:`starmap`         func, seq                       func(\*seq[0]), func(\*seq[1]), ...                 ``starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000``
-:func:`tee`             it, n                           it1, it2 , ... itn  splits one iterator into n
+:func:`tee`             it, n                           it1, it2, ... itn  splits one iterator into n
 :func:`takewhile`       pred, seq                       seq[0], seq[1], until pred fails                    ``takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4``
 :func:`izip`            p, q, ...                       (p[0], q[0]), (p[1], q[1]), ...                     ``izip('ABCD', 'xy') --> Ax By``
 :func:`izip_longest`    p, q, ...                       (p[0], q[0]), (p[1], q[1]), ...                     ``izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-``
diff -r 3a1db0d2747e Doc/library/logging.rst
--- a/Doc/library/logging.rst
+++ b/Doc/library/logging.rst
@@ -114,6 +114,8 @@
    If the root is reached, and it has a level of NOTSET, then all messages will be
    processed. Otherwise, the root's level will be used as the effective level.
 
+   See :ref:`levels` for a list of levels.
+
 
 .. method:: Logger.isEnabledFor(lvl)
 
@@ -281,6 +283,35 @@
    .. versionchanged:: 2.5
       *func* and *extra* were added.
 
+
+.. _levels:
+
+Logging Levels
+--------------
+
+The numeric values of logging levels are given in the following table. These are
+primarily of interest if you want to define your own levels, and need them to
+have specific values relative to the predefined levels. If you define a level
+with the same numeric value, it overwrites the predefined value; the predefined
+name is lost.
+
++--------------+---------------+
+| Level        | Numeric value |
++==============+===============+
+| ``CRITICAL`` | 50            |
++--------------+---------------+
+| ``ERROR``    | 40            |
++--------------+---------------+
+| ``WARNING``  | 30            |
++--------------+---------------+
+| ``INFO``     | 20            |
++--------------+---------------+
+| ``DEBUG``    | 10            |
++--------------+---------------+
+| ``NOTSET``   | 0             |
++--------------+---------------+
+
+
 .. _handler:
 
 Handler Objects
@@ -321,6 +352,7 @@
    severe than *lvl* will be ignored. When a handler is created, the level is set
    to :const:`NOTSET` (which causes all messages to be processed).
 
+   See :ref:`levels` for a list of levels.
 
 .. method:: Handler.setFormatter(form)
 
@@ -659,7 +691,7 @@
 ---------------------
 
 :class:`LoggerAdapter` instances are used to conveniently pass contextual
-information into logging calls. For a usage example , see the section on
+information into logging calls. For a usage example, see the section on
 :ref:`adding contextual information to your logging output <context-info>`.
 
 .. versionadded:: 2.6
@@ -679,16 +711,15 @@
       (possibly modified) versions of the arguments passed in.
 
 In addition to the above, :class:`LoggerAdapter` supports the following
-methods of :class:`Logger`, i.e. :meth:`debug`, :meth:`info`, :meth:`warning`,
-:meth:`error`, :meth:`exception`, :meth:`critical`, :meth:`log`,
-:meth:`isEnabledFor`, :meth:`getEffectiveLevel`, :meth:`setLevel`,
-:meth:`hasHandlers`. These methods have the same signatures as their
-counterparts in :class:`Logger`, so you can use the two types of instances
-interchangeably.
+methods of :class:`Logger`: :meth:`~Logger.debug`, :meth:`~Logger.info`,
+:meth:`~Logger.warning`, :meth:`~Logger.error`, :meth:`~Logger.exception`,
+:meth:`~Logger.critical`, :meth:`~Logger.log` and :meth:`~Logger.isEnabledFor`.
+These methods have the same signatures as their counterparts in :class:`Logger`,
+so you can use the two types of instances interchangeably for these calls.
 
 .. versionchanged:: 2.7
-   The :meth:`isEnabledFor` method was added to :class:`LoggerAdapter`.  This
-   method delegates to the underlying logger.
+   The :meth:`~Logger.isEnabledFor` method was added to :class:`LoggerAdapter`.
+   This method delegates to the underlying logger.
 
 
 Thread Safety
@@ -728,8 +759,8 @@
 
    Return either the standard :class:`Logger` class, or the last class passed to
    :func:`setLoggerClass`. This function may be called from within a new class
-   definition, to ensure that installing a customised :class:`Logger` class will
-   not undo customisations already applied by other code. For example::
+   definition, to ensure that installing a customized :class:`Logger` class will
+   not undo customizations already applied by other code. For example::
 
       class MyLogger(logging.getLoggerClass()):
           # ... override behaviour here
@@ -838,8 +869,10 @@
    effect is to disable all logging calls of severity *lvl* and below, so that
    if you call it with a value of INFO, then all INFO and DEBUG events would be
    discarded, whereas those of severity WARNING and above would be processed
-   according to the logger's effective level. To undo the effect of a call to
-   ``logging.disable(lvl)``, call ``logging.disable(logging.NOTSET)``.
+   according to the logger's effective level. If
+   ``logging.disable(logging.NOTSET)`` is called, it effectively removes this
+   overriding level, so that logging output again depends on the effective
+   levels of individual loggers.
 
 
 .. function:: addLevelName(lvl, levelName)
diff -r 3a1db0d2747e Doc/library/mailbox.rst
--- a/Doc/library/mailbox.rst
+++ b/Doc/library/mailbox.rst
@@ -1664,7 +1664,7 @@
 due to malformed messages in the mailbox::
 
    import mailbox
-   import email.Errors
+   import email.errors
 
    list_names = ('python-list', 'python-dev', 'python-bugs')
 
@@ -1674,7 +1674,7 @@
    for key in inbox.iterkeys():
        try:
            message = inbox[key]
-       except email.Errors.MessageParseError:
+       except email.errors.MessageParseError:
            continue                # The message is malformed. Just leave it.
 
        for name in list_names:
diff -r 3a1db0d2747e Doc/library/multiprocessing.rst
--- a/Doc/library/multiprocessing.rst
+++ b/Doc/library/multiprocessing.rst
@@ -960,12 +960,24 @@
    ctypes type or a one character typecode of the kind used by the :mod:`array`
    module.  *\*args* is passed on to the constructor for the type.
 
-   If *lock* is ``True`` (the default) then a new lock object is created to
-   synchronize access to the value.  If *lock* is a :class:`Lock` or
-   :class:`RLock` object then that will be used to synchronize access to the
-   value.  If *lock* is ``False`` then access to the returned object will not be
-   automatically protected by a lock, so it will not necessarily be
-   "process-safe".
+   If *lock* is ``True`` (the default) then a new recursive lock
+   object is created to synchronize access to the value.  If *lock* is
+   a :class:`Lock` or :class:`RLock` object then that will be used to
+   synchronize access to the value.  If *lock* is ``False`` then
+   access to the returned object will not be automatically protected
+   by a lock, so it will not necessarily be "process-safe".
+
+   Operations like ``+=`` which involve a read and write are not
+   atomic.  So if, for instance, you want to atomically increment a
+   shared value it is insufficient to just do ::
+
+       counter.value += 1
+
+   Assuming the associated lock is recursive (which it is by default)
+   you can instead do ::
+
+       with counter.get_lock():
+           counter.value += 1
 
    Note that *lock* is a keyword-only argument.
 
diff -r 3a1db0d2747e Doc/library/nntplib.rst
--- a/Doc/library/nntplib.rst
+++ b/Doc/library/nntplib.rst
@@ -234,25 +234,25 @@
 
 .. method:: NNTP.next()
 
-   Send a ``NEXT`` command.  Return as for :meth:`stat`.
+   Send a ``NEXT`` command.  Return as for :meth:`.stat`.
 
 
 .. method:: NNTP.last()
 
-   Send a ``LAST`` command.  Return as for :meth:`stat`.
+   Send a ``LAST`` command.  Return as for :meth:`.stat`.
 
 
 .. method:: NNTP.head(id)
 
-   Send a ``HEAD`` command, where *id* has the same meaning as for :meth:`stat`.
+   Send a ``HEAD`` command, where *id* has the same meaning as for :meth:`.stat`.
    Return a tuple ``(response, number, id, list)`` where the first three are the
-   same as for :meth:`stat`, and *list* is a list of the article's headers (an
+   same as for :meth:`.stat`, and *list* is a list of the article's headers (an
    uninterpreted list of lines, without trailing newlines).
 
 
 .. method:: NNTP.body(id,[file])
 
-   Send a ``BODY`` command, where *id* has the same meaning as for :meth:`stat`.
+   Send a ``BODY`` command, where *id* has the same meaning as for :meth:`.stat`.
    If the *file* parameter is supplied, then the body is stored in a file.  If
    *file* is a string, then the method will open a file object with that name,
    write to it then close it. If *file* is a file object, then it will start
@@ -263,7 +263,7 @@
 .. method:: NNTP.article(id)
 
    Send an ``ARTICLE`` command, where *id* has the same meaning as for
-   :meth:`stat`.  Return as for :meth:`head`.
+   :meth:`.stat`.  Return as for :meth:`head`.
 
 
 .. method:: NNTP.slave()
@@ -290,7 +290,7 @@
 .. method:: NNTP.post(file)
 
    Post an article using the ``POST`` command.  The *file* argument is an open file
-   object which is read until EOF using its :meth:`readline` method.  It should be
+   object which is read until EOF using its :meth:`~file.readline` method.  It should be
    a well-formed news article, including the required headers.  The :meth:`post`
    method automatically escapes lines beginning with ``.``.
 
diff -r 3a1db0d2747e Doc/library/operator.rst
--- a/Doc/library/operator.rst
+++ b/Doc/library/operator.rst
@@ -503,7 +503,7 @@
      ``(b.name, b.date)``.
 
    * After ``f = attrgetter('name.first', 'name.last')``, the call ``f(b)``
-     returns ``(r.name.first, r.name.last)``.
+     returns ``(b.name.first, b.name.last)``.
 
    Equivalent to::
 
diff -r 3a1db0d2747e Doc/library/os.path.rst
--- a/Doc/library/os.path.rst
+++ b/Doc/library/os.path.rst
@@ -127,7 +127,7 @@
    .. versionadded:: 1.5.2
 
    .. versionchanged:: 2.3
-      If :func:`os.stat_float_times` returns True, the result is a floating point
+      If :func:`os.stat_float_times` returns ``True``, the result is a floating point
       number.
 
 
@@ -140,7 +140,7 @@
    .. versionadded:: 1.5.2
 
    .. versionchanged:: 2.3
-      If :func:`os.stat_float_times` returns True, the result is a floating point
+      If :func:`os.stat_float_times` returns ``True``, the result is a floating point
       number.
 
 
@@ -345,7 +345,7 @@
 
 .. data:: supports_unicode_filenames
 
-   True if arbitrary Unicode strings can be used as file names (within limitations
+   ``True`` if arbitrary Unicode strings can be used as file names (within limitations
    imposed by the file system).
 
    .. versionadded:: 2.3
diff -r 3a1db0d2747e Doc/library/os.rst
--- a/Doc/library/os.rst
+++ b/Doc/library/os.rst
@@ -1936,6 +1936,10 @@
    Note that some platforms including FreeBSD <= 6.3, Cygwin and OS/2 EMX have
    known issues when using fork() from a thread.
 
+   .. warning::
+
+      See :mod:`ssl` for applications that use the SSL module with fork().
+
    Availability: Unix.
 
 
diff -r 3a1db0d2747e Doc/library/ossaudiodev.rst
--- a/Doc/library/ossaudiodev.rst
+++ b/Doc/library/ossaudiodev.rst
@@ -48,7 +48,7 @@
       the official documentation for the OSS C API
 
    The module defines a large number of constants supplied by the OSS device
-   driver; see ``<sys/soundcard.h>`` on either Linux or FreeBSD for a listing .
+   driver; see ``<sys/soundcard.h>`` on either Linux or FreeBSD for a listing.
 
 :mod:`ossaudiodev` defines the following variables and functions:
 
diff -r 3a1db0d2747e Doc/library/pyexpat.rst
--- a/Doc/library/pyexpat.rst
+++ b/Doc/library/pyexpat.rst
@@ -906,5 +906,5 @@
 .. [#] The encoding string included in XML output should conform to the
    appropriate standards. For example, "UTF-8" is valid, but "UTF8" is
    not. See http://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl
-   and http://www.iana.org/assignments/character-sets .
+   and http://www.iana.org/assignments/character-sets\ .
 
diff -r 3a1db0d2747e Doc/library/rexec.rst
--- a/Doc/library/rexec.rst
+++ b/Doc/library/rexec.rst
@@ -270,7 +270,7 @@
            if mode in ('r', 'rb'):
                pass
            elif mode in ('w', 'wb', 'a', 'ab'):
-               # check filename : must begin with /tmp/
+               # check filename: must begin with /tmp/
                if file[:5]!='/tmp/':
                    raise IOError("can't write outside /tmp")
                elif (string.find(file, '/../') >= 0 or
diff -r 3a1db0d2747e Doc/library/simplexmlrpcserver.rst
--- a/Doc/library/simplexmlrpcserver.rst
+++ b/Doc/library/simplexmlrpcserver.rst
@@ -247,7 +247,7 @@
 Example::
 
    class MyFuncs:
-       def div(self, x, y) : return x // y
+       def div(self, x, y): return x // y
 
 
    handler = CGIXMLRPCRequestHandler()
diff -r 3a1db0d2747e Doc/library/sqlite3.rst
--- a/Doc/library/sqlite3.rst
+++ b/Doc/library/sqlite3.rst
@@ -234,10 +234,10 @@
 .. function:: enable_callback_tracebacks(flag)
 
    By default you will not get any tracebacks in user-defined functions,
-   aggregates, converters, authorizer callbacks etc. If you want to debug them, you
-   can call this function with *flag* as True. Afterwards, you will get tracebacks
-   from callbacks on ``sys.stderr``. Use :const:`False` to disable the feature
-   again.
+   aggregates, converters, authorizer callbacks etc. If you want to debug them,
+   you can call this function with *flag* set to ``True``. Afterwards, you will
+   get tracebacks from callbacks on ``sys.stderr``. Use :const:`False` to
+   disable the feature again.
 
 
 .. _sqlite3-connection-objects:
diff -r 3a1db0d2747e Doc/library/ssl.rst
--- a/Doc/library/ssl.rst
+++ b/Doc/library/ssl.rst
@@ -30,6 +30,18 @@
    operating system socket APIs.  The installed version of OpenSSL may also
    cause variations in behavior.
 
+.. warning::
+   The ssl module won't validate certificates by default.  When used in
+   client mode, this means you are vulnerable to man-in-the-middle attacks.
+
+.. warning::
+
+   OpenSSL's internal random number generator does not properly handle fork.
+   Applications must change the PRNG state of the parent process if they use
+   any SSL feature with :func:`os.fork`. Any successful call of
+   :func:`~ssl.RAND_add`, :func:`~ssl.RAND_bytes` or
+   :func:`~ssl.RAND_pseudo_bytes` is sufficient.
+
 This section documents the objects and functions in the ``ssl`` module; for more
 general information about TLS, SSL, and certificates, the reader is referred to
 the documents in the "See Also" section at the bottom.
@@ -57,13 +69,16 @@
 
    Takes an instance ``sock`` of :class:`socket.socket`, and returns an instance
    of :class:`ssl.SSLSocket`, a subtype of :class:`socket.socket`, which wraps
-   the underlying socket in an SSL context.  For client-side sockets, the
-   context construction is lazy; if the underlying socket isn't connected yet,
-   the context construction will be performed after :meth:`connect` is called on
-   the socket.  For server-side sockets, if the socket has no remote peer, it is
-   assumed to be a listening socket, and the server-side SSL wrapping is
-   automatically performed on client connections accepted via the :meth:`accept`
-   method.  :func:`wrap_socket` may raise :exc:`SSLError`.
+   the underlying socket in an SSL context.  ``sock`` must be a
+   :data:`~socket.SOCK_STREAM` socket; other socket types are unsupported.
+
+   For client-side sockets, the context construction is lazy; if the
+   underlying socket isn't connected yet, the context construction will be
+   performed after :meth:`connect` is called on the socket.  For
+   server-side sockets, if the socket has no remote peer, it is assumed
+   to be a listening socket, and the server-side SSL wrapping is
+   automatically performed on client connections accepted via the
+   :meth:`accept` method.  :func:`wrap_socket` may raise :exc:`SSLError`.
 
    The ``keyfile`` and ``certfile`` parameters specify optional files which
    contain a certificate to be used to identify the local side of the
@@ -154,7 +169,7 @@
 
 .. function:: RAND_status()
 
-   Returns True if the SSL pseudo-random number generator has been seeded with
+   Returns ``True`` if the SSL pseudo-random number generator has been seeded with
    'enough' randomness, and False otherwise.  You can use :func:`ssl.RAND_egd`
    and :func:`ssl.RAND_add` to increase the randomness of the pseudo-random
    number generator.
diff -r 3a1db0d2747e Doc/library/stdtypes.rst
--- a/Doc/library/stdtypes.rst
+++ b/Doc/library/stdtypes.rst
@@ -1668,9 +1668,8 @@
       Previously, all negative indices were truncated to zero.
 
 (6)
-   The :meth:`pop` method is only supported by the list and array types.  The
-   optional argument *i* defaults to ``-1``, so that by default the last item is
-   removed and returned.
+   The :meth:`pop` method's optional argument *i* defaults to ``-1``, so that
+   by default the last item is removed and returned.
 
 (7)
    The :meth:`sort` and :meth:`reverse` methods modify the list in place for
@@ -1783,7 +1782,7 @@
 
    .. method:: isdisjoint(other)
 
-      Return True if the set has no elements in common with *other*.  Sets are
+      Return ``True`` if the set has no elements in common with *other*.  Sets are
       disjoint if and only if their intersection is the empty set.
 
       .. versionadded:: 2.6
diff -r 3a1db0d2747e Doc/library/string.rst
--- a/Doc/library/string.rst
+++ b/Doc/library/string.rst
@@ -330,7 +330,7 @@
    precision: `integer`
    type: "b" | "c" | "d" | "e" | "E" | "f" | "F" | "g" | "G" | "n" | "o" | "s" | "x" | "X" | "%"
 
-If a valid *align* value is specified, it can be preceeded by a *fill*
+If a valid *align* value is specified, it can be preceded by a *fill*
 character that can be any character and defaults to a space if omitted.
 Note that it is not possible to use ``{`` and ``}`` as *fill* char while
 using the :meth:`str.format` method; this limitation however doesn't
diff -r 3a1db0d2747e Doc/library/struct.rst
--- a/Doc/library/struct.rst
+++ b/Doc/library/struct.rst
@@ -284,7 +284,7 @@
 For the ``'?'`` format character, the return value is either :const:`True` or
 :const:`False`. When packing, the truth value of the argument object is used.
 Either 0 or 1 in the native or standard bool representation will be packed, and
-any non-zero value will be True when unpacking.
+any non-zero value will be ``True`` when unpacking.
 
 
 
diff -r 3a1db0d2747e Doc/library/sys.rst
--- a/Doc/library/sys.rst
+++ b/Doc/library/sys.rst
@@ -1077,5 +1077,5 @@
 
 .. rubric:: Citations
 
-.. [C99] ISO/IEC 9899:1999.  "Programming languages -- C."  A public draft of this standard is available at http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf .
+.. [C99] ISO/IEC 9899:1999.  "Programming languages -- C."  A public draft of this standard is available at http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf\ .
 
diff -r 3a1db0d2747e Doc/library/telnetlib.rst
--- a/Doc/library/telnetlib.rst
+++ b/Doc/library/telnetlib.rst
@@ -208,7 +208,7 @@
 .. method:: Telnet.set_option_negotiation_callback(callback)
 
    Each time a telnet option is read on the input flow, this *callback* (if set) is
-   called with the following parameters : callback(telnet socket, command
+   called with the following parameters: callback(telnet socket, command
    (DO/DONT/WILL/WONT), option).  No other action is done afterwards by telnetlib.
 
 
diff -r 3a1db0d2747e Doc/library/tkinter.rst
--- a/Doc/library/tkinter.rst
+++ b/Doc/library/tkinter.rst
@@ -188,7 +188,7 @@
       The Tk/Tcl development is largely taking place at ActiveState.
 
    `Tcl and the Tk Toolkit <http://www.amazon.com/exec/obidos/ASIN/020163337X>`_
-      The book by John Ousterhout, the inventor of Tcl .
+      The book by John Ousterhout, the inventor of Tcl.
 
    `Practical Programming in Tcl and Tk <http://www.amazon.com/exec/obidos/ASIN/0130220280>`_
       Brent Welch's encyclopedic book.
@@ -452,7 +452,7 @@
 Example::
 
    >>> print fred.config()
-   {'relief' : ('relief', 'relief', 'Relief', 'raised', 'groove')}
+   {'relief': ('relief', 'relief', 'Relief', 'raised', 'groove')}
 
 Of course, the dictionary printed will include all the options available and
 their values.  This is meant only as an example.
@@ -625,7 +625,7 @@
    preceded with an ``@``, as in ``"@/usr/contrib/bitmap/gumby.bit"``.
 
 boolean
-   You can pass integers 0 or 1 or the strings ``"yes"`` or ``"no"`` .
+   You can pass integers 0 or 1 or the strings ``"yes"`` or ``"no"``.
 
 callback
    This is any Python function that takes no arguments.  For example::
diff -r 3a1db0d2747e Doc/library/trace.rst
--- a/Doc/library/trace.rst
+++ b/Doc/library/trace.rst
@@ -41,7 +41,7 @@
 
 At least one of the following options must be specified when invoking
 :mod:`trace`.  The :option:`--listfuncs <-l>` option is mutually exclusive with
-the :option:`--trace <-t>` and :option:`--counts <-c>` options . When
+the :option:`--trace <-t>` and :option:`--counts <-c>` options. When
 :option:`--listfuncs <-l>` is provided, neither :option:`--counts <-c>` nor
 :option:`--trace <-t>` are accepted, and vice versa.
 
diff -r 3a1db0d2747e Doc/library/ttk.rst
--- a/Doc/library/ttk.rst
+++ b/Doc/library/ttk.rst
@@ -267,8 +267,8 @@
 
    .. method:: instate(statespec, callback=None, *args, **kw)
 
-      Test the widget's state. If a callback is not specified, returns True
-      if the widget state matches *statespec* and False otherwise. If callback
+      Test the widget's state. If a callback is not specified, returns ``True``
+      if the widget state matches *statespec* and ``False`` otherwise. If callback
       is specified then it is called with *args* if widget state matches
       *statespec*.
 
@@ -919,7 +919,7 @@
 
    .. method:: exists(item)
 
-      Returns True if the specified *item* is present in the tree.
+      Returns ``True`` if the specified *item* is present in the tree.
 
 
    .. method:: focus([item=None])
@@ -1065,7 +1065,7 @@
 
       Ensure that *item* is visible.
 
-      Sets all of *item*'s ancestors open option to True, and scrolls the
+      Sets all of *item*'s ancestors open option to ``True``, and scrolls the
       widget if necessary so that *item* is within the visible portion of
       the tree.
 
diff -r 3a1db0d2747e Doc/library/turtle.rst
--- a/Doc/library/turtle.rst
+++ b/Doc/library/turtle.rst
@@ -1049,8 +1049,8 @@
 
    Write text - the string representation of *arg* - at the current turtle
    position according to *align* ("left", "center" or right") and with the given
-   font.  If *move* is True, the pen is moved to the bottom-right corner of the
-   text.  By default, *move* is False.
+   font.  If *move* is true, the pen is moved to the bottom-right corner of the
+   text.  By default, *move* is ``False``.
 
    >>> turtle.write("Home = ", True, align="center")
    >>> turtle.write((0,0), True)
@@ -1086,7 +1086,7 @@
 
 .. function:: isvisible()
 
-   Return True if the Turtle is shown, False if it's hidden.
+   Return ``True`` if the Turtle is shown, ``False`` if it's hidden.
 
    >>> turtle.hideturtle()
    >>> turtle.isvisible()
diff -r 3a1db0d2747e Doc/library/unittest.rst
--- a/Doc/library/unittest.rst
+++ b/Doc/library/unittest.rst
@@ -1808,6 +1808,10 @@
       if __name__ == '__main__':
           unittest.main(verbosity=2)
 
+   The *defaultTest* argument is the name of the test to run if no test names
+   are specified via *argv*.  If not specified or ``None`` and no test names are
+   provided via *argv*, all tests found in *module* are run.
+
    The *argv* argument can be a list of options passed to the program, with the
    first element being the program name.  If not specified or ``None``,
    the values of :data:`sys.argv` are used.
diff -r 3a1db0d2747e Doc/library/urllib2.rst
--- a/Doc/library/urllib2.rst
+++ b/Doc/library/urllib2.rst
@@ -166,7 +166,7 @@
    should be the request-host of the request for the page containing the image.
 
    *unverifiable* should indicate whether the request is unverifiable, as defined
-   by RFC 2965.  It defaults to False.  An unverifiable request is one whose URL
+   by RFC 2965.  It defaults to ``False``.  An unverifiable request is one whose URL
    the user did not have the option to approve.  For example, if the request is for
    an image in an HTML document, and the user had no option to approve the
    automatic fetching of the image, this should be true.
diff -r 3a1db0d2747e Doc/library/weakref.rst
--- a/Doc/library/weakref.rst
+++ b/Doc/library/weakref.rst
@@ -163,7 +163,7 @@
 
 .. method:: WeakKeyDictionary.iterkeyrefs()
 
-   Return an :term:`iterator` that yields the weak references to the keys.
+   Return an iterable of the weak references to the keys.
 
    .. versionadded:: 2.5
 
@@ -195,7 +195,7 @@
 
 .. method:: WeakValueDictionary.itervaluerefs()
 
-   Return an :term:`iterator` that yields the weak references to the values.
+   Return an iterable of the weak references to the values.
 
    .. versionadded:: 2.5
 
diff -r 3a1db0d2747e Doc/library/xml.dom.minidom.rst
--- a/Doc/library/xml.dom.minidom.rst
+++ b/Doc/library/xml.dom.minidom.rst
@@ -276,4 +276,4 @@
 .. [#] The encoding string included in XML output should conform to the
    appropriate standards. For example, "UTF-8" is valid, but "UTF8" is
    not. See http://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl
-   and http://www.iana.org/assignments/character-sets .
+   and http://www.iana.org/assignments/character-sets\ .
diff -r 3a1db0d2747e Doc/library/xml.rst
--- a/Doc/library/xml.rst
+++ b/Doc/library/xml.rst
@@ -32,7 +32,7 @@
 ..
 
 * :mod:`xml.dom`: the DOM API definition
-* :mod:`xml.dom.minidom`: a lightweight DOM implementation
+* :mod:`xml.dom.minidom`: a minimal DOM implementation
 * :mod:`xml.dom.pulldom`: support for building partial DOM trees
 
 ..
diff -r 3a1db0d2747e Doc/library/zipimport.rst
--- a/Doc/library/zipimport.rst
+++ b/Doc/library/zipimport.rst
@@ -115,7 +115,7 @@
 
    .. method:: is_package(fullname)
 
-      Return True if the module specified by *fullname* is a package. Raise
+      Return ``True`` if the module specified by *fullname* is a package. Raise
       :exc:`ZipImportError` if the module couldn't be found.
 
 
diff -r 3a1db0d2747e Doc/license.rst
--- a/Doc/license.rst
+++ b/Doc/license.rst
@@ -84,7 +84,7 @@
    analyze, test, perform and/or display publicly, prepare derivative works,
    distribute, and otherwise use Python |release| alone or in any derivative
    version, provided, however, that PSF's License Agreement and PSF's notice of
-   copyright, i.e., "Copyright © 2001-2013 Python Software Foundation; All Rights
+   copyright, i.e., "Copyright © 2001-2014 Python Software Foundation; All Rights
    Reserved" are retained in Python |release| alone or in any derivative version
    prepared by Licensee.
 
@@ -746,8 +746,8 @@
      *
      */
 
- Original SSLeay License
- -----------------------
+  Original SSLeay License
+  -----------------------
 
     /* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
      * All rights reserved.
diff -r 3a1db0d2747e Doc/reference/datamodel.rst
--- a/Doc/reference/datamodel.rst
+++ b/Doc/reference/datamodel.rst
@@ -207,7 +207,7 @@
             single: True
 
          These represent the truth values False and True.  The two objects
-         representing the values False and True are the only Boolean objects.
+         representing the values ``False`` and ``True`` are the only Boolean objects.
          The Boolean type is a subtype of plain integers, and Boolean values
          behave like the values 0 and 1, respectively, in almost all contexts,
          the exception being that when converted to a string, the strings
diff -r 3a1db0d2747e Doc/tools/sphinxext/susp-ignored.csv
--- a/Doc/tools/sphinxext/susp-ignored.csv
+++ b/Doc/tools/sphinxext/susp-ignored.csv
@@ -8,6 +8,10 @@
 extending/extending,,:myfunction,"PyArg_ParseTuple(args, ""D:myfunction"", &c);"
 extending/newtypes,,:call,"if (!PyArg_ParseTuple(args, ""sss:call"", &arg1, &arg2, &arg3)) {"
 extending/windows,,:initspam,/export:initspam
+faq/programming,,:reduce,"print (lambda Ru,Ro,Iu,Io,IM,Sx,Sy:reduce(lambda x,y:x+y,map(lambda y,"
+faq/programming,,:reduce,"Sx=Sx,Sy=Sy:reduce(lambda x,y:x+y,map(lambda x,xc=Ru,yc=yc,Ru=Ru,Ro=Ro,"
+faq/programming,,:chr,">=4.0) or 1+f(xc,yc,x*x-y*y+xc,2.0*x*y+yc,k-1,f):f(xc,yc,x,y,k,f):chr("
+faq/programming,,::,for x in sequence[::-1]:
 howto/cporting,,:encode,"if (!PyArg_ParseTuple(args, ""O:encode_object"", &myobj))"
 howto/cporting,,:say,"if (!PyArg_ParseTuple(args, ""U:say_hello"", &name))"
 howto/curses,,:black,"They are: 0:black, 1:red, 2:green, 3:yellow, 4:blue, 5:magenta, 6:cyan, and"
@@ -39,10 +43,15 @@
 howto/logging,,:logger,severity:logger name:message
 howto/logging,,:message,severity:logger name:message
 howto/logging,,:This,DEBUG:root:This message should go to the log file
+howto/pyporting,75,::,# make sure to use :: Python *and* :: Python :: 3 so
+howto/pyporting,75,::,"'Programming Language :: Python',"
+howto/pyporting,75,::,'Programming Language :: Python :: 3'
 howto/regex,,::,
 howto/regex,,:foo,(?:foo)
 howto/urllib2,,:example,"for example ""joe@password:example.com"""
 library/audioop,,:ipos,"# factor = audioop.findfactor(in_test[ipos*2:ipos*2+len(out_test)],"
+library/bisect,,:hi,all(val >= x for val in a[i:hi])
+library/bisect,,:hi,all(val > x for val in a[i:hi])
 library/cookie,,`,!#$%&'*+-.^_`|~
 library/datetime,,:MM,
 library/datetime,,:SS,
@@ -92,8 +101,9 @@
 library/profile,,:lineno,filename:lineno(function)
 library/pyexpat,,:elem1,<py:elem1 />
 library/pyexpat,,:py,"xmlns:py = ""http://www.python.org/ns/"">"
-library/smtplib,,:port,"as well as a regular host:port server."
+library/smtplib,,:port,method must support that as well as a regular host:port
 library/socket,,::,'5aef:2b::8'
+library/socket,,::,"(10, 1, 6, '', ('2001:888:2000:d::a2', 80, 0, 0))]"
 library/sqlite3,,:memory,
 library/sqlite3,,:who,"cur.execute(""select * from people where name_last=:who and age=:age"", {""who"": who, ""age"": age})"
 library/sqlite3,,:age,"cur.execute(""select * from people where name_last=:who and age=:age"", {""who"": who, ""age"": age})"
@@ -105,6 +115,7 @@
 library/ssl,,:Some,"Locality Name (eg, city) []:Some City"
 library/ssl,,:US,Country Name (2 letter code) [AU]:US
 library/stdtypes,,:len,s[len(s):len(s)]
+library/stdtypes,,:end,s[start:end]
 library/string,,:end,s[start:end]
 library/subprocess,,`,"output=`mycmd myarg`"
 library/subprocess,,`,"output=`dmesg | grep hda`"
@@ -116,6 +127,7 @@
 library/turtle,,::,Example::
 library/urllib,,:port,:port
 library/urllib2,,:password,"""joe:password@python.org"""
+library/urllib2,,:close,Connection:close
 library/uuid,,:uuid,urn:uuid:12345678-1234-5678-1234-567812345678
 library/xmlrpclib,,:pass,http://user:pass@host:port/path
 library/xmlrpclib,,:pass,user:pass
@@ -123,6 +135,10 @@
 license,,`,THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 license,,:zooko,mailto:zooko@zooko.com
 license,,`,THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+license,,`,* THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+license,,`,* THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+license,,`,"``Software''), to deal in the Software without restriction, including"
+license,,`,"THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,"
 reference/datamodel,,:step,a[i:j:step]
 reference/datamodel,,:max,
 reference/expressions,,:index,x[index:index]
@@ -150,6 +166,7 @@
 using/cmdline,,:message,action:message:category:module:line
 using/cmdline,,:module,action:message:category:module:line
 using/cmdline,,:errorhandler,:errorhandler
+using/unix,,:Packaging,http://en.opensuse.org/Portal:Packaging
 whatsnew/2.0,418,:len,
 whatsnew/2.3,,::,
 whatsnew/2.3,,:config,
@@ -163,24 +180,8 @@
 whatsnew/2.5,,:memory,:memory:
 whatsnew/2.5,,:step,[start:stop:step]
 whatsnew/2.5,,:stop,[start:stop:step]
-faq/programming,,:reduce,"print (lambda Ru,Ro,Iu,Io,IM,Sx,Sy:reduce(lambda x,y:x+y,map(lambda y,"
-faq/programming,,:reduce,"Sx=Sx,Sy=Sy:reduce(lambda x,y:x+y,map(lambda x,xc=Ru,yc=yc,Ru=Ru,Ro=Ro,"
-faq/programming,,:chr,">=4.0) or 1+f(xc,yc,x*x-y*y+xc,2.0*x*y+yc,k-1,f):f(xc,yc,x,y,k,f):chr("
-faq/programming,,::,for x in sequence[::-1]:
-library/bisect,,:hi,all(val >= x for val in a[i:hi])
-library/bisect,,:hi,all(val > x for val in a[i:hi])
-library/socket,,::,"(10, 1, 6, '', ('2001:888:2000:d::a2', 80, 0, 0))]"
-library/stdtypes,,:end,s[start:end]
-license,,`,* THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
-license,,`,* THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
-license,,`,"``Software''), to deal in the Software without restriction, including"
-license,,`,"THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,"
 whatsnew/2.7,735,:Sunday,'2009:4:Sunday'
 whatsnew/2.7,862,::,"export PYTHONWARNINGS=all,error:::Cookie:0"
 whatsnew/2.7,862,:Cookie,"export PYTHONWARNINGS=all,error:::Cookie:0"
 whatsnew/2.7,,::,>>> urlparse.urlparse('http://[1080::8:800:200C:417A]/foo')
 whatsnew/2.7,,::,"ParseResult(scheme='http', netloc='[1080::8:800:200C:417A]',"
-howto/pyporting,75,::,# make sure to use :: Python *and* :: Python :: 3 so
-howto/pyporting,75,::,"'Programming Language :: Python',"
-howto/pyporting,75,::,'Programming Language :: Python :: 3'
-library/urllib2,67,:close,Connection:close
diff -r 3a1db0d2747e Doc/tutorial/controlflow.rst
--- a/Doc/tutorial/controlflow.rst
+++ b/Doc/tutorial/controlflow.rst
@@ -19,14 +19,14 @@
    >>> x = int(raw_input("Please enter an integer: "))
    Please enter an integer: 42
    >>> if x < 0:
-   ...      x = 0
-   ...      print 'Negative changed to zero'
+   ...     x = 0
+   ...     print 'Negative changed to zero'
    ... elif x == 0:
-   ...      print 'Zero'
+   ...     print 'Zero'
    ... elif x == 1:
-   ...      print 'Single'
+   ...     print 'Single'
    ... else:
-   ...      print 'More'
+   ...     print 'More'
    ...
    More
 
diff -r 3a1db0d2747e Doc/tutorial/inputoutput.rst
--- a/Doc/tutorial/inputoutput.rst
+++ b/Doc/tutorial/inputoutput.rst
@@ -358,47 +358,64 @@
 Reference for a complete guide to file objects.
 
 
-.. _tut-pickle:
+.. _tut-json:
 
-The :mod:`pickle` Module
-------------------------
+Saving structured data with :mod:`json`
+---------------------------------------
 
-.. index:: module: pickle
+.. index:: module: json
 
-Strings can easily be written to and read from a file. Numbers take a bit more
+Strings can easily be written to and read from a file.  Numbers take a bit more
 effort, since the :meth:`read` method only returns strings, which will have to
 be passed to a function like :func:`int`, which takes a string like ``'123'``
-and returns its numeric value 123.  However, when you want to save more complex
-data types like lists, dictionaries, or class instances, things get a lot more
-complicated.
+and returns its numeric value 123.  When you want to save more complex data
+types like nested lists and dictionaries, parsing and serializing by hand
+becomes complicated.
 
-Rather than have users be constantly writing and debugging code to save
-complicated data types, Python provides a standard module called :mod:`pickle`.
-This is an amazing module that can take almost any Python object (even some
-forms of Python code!), and convert it to a string representation; this process
-is called :dfn:`pickling`.  Reconstructing the object from the string
-representation is called :dfn:`unpickling`.  Between pickling and unpickling,
-the string representing the object may have been stored in a file or data, or
+Rather than having users constantly writing and debugging code to save
+complicated data types to files, Python allows you to use the popular data
+interchange format called `JSON (JavaScript Object Notation)
+<http://json.org>`_.  The standard module called :mod:`json` can take Python
+data hierarchies, and convert them to string representations; this process is
+called :dfn:`serializing`.  Reconstructing the data from the string representation
+is called :dfn:`deserializing`.  Between serializing and deserializing, the
+string representing the object may have been stored in a file or data, or
 sent over a network connection to some distant machine.
 
-If you have an object ``x``, and a file object ``f`` that's been opened for
-writing, the simplest way to pickle the object takes only one line of code::
+.. note::
+   The JSON format is commonly used by modern applications to allow for data
+   exchange.  Many programmers are already familiar with it, which makes
+   it a good choice for interoperability.
 
-   pickle.dump(x, f)
+If you have an object ``x``, you can view its JSON string representation with a
+simple line of code::
 
-To unpickle the object again, if ``f`` is a file object which has been opened
-for reading::
+   >>> json.dumps([1, 'simple', 'list'])
+   '[1, "simple", "list"]'
 
-   x = pickle.load(f)
+Another variant of the :func:`~json.dumps` function, called :func:`~json.dump`,
+simply serializes the object to a file.  So if ``f`` is a :term:`file object`
+opened for writing, we can do this::
 
-(There are other variants of this, used when pickling many objects or when you
-don't want to write the pickled data to a file; consult the complete
-documentation for :mod:`pickle` in the Python Library Reference.)
+   json.dump(x, f)
 
-:mod:`pickle` is the standard way to make Python objects which can be stored and
-reused by other programs or by a future invocation of the same program; the
-technical term for this is a :dfn:`persistent` object.  Because :mod:`pickle` is
-so widely used, many authors who write Python extensions take care to ensure
-that new data types such as matrices can be properly pickled and unpickled.
+To decode the object again, if ``f`` is a :term:`file object` which has
+been opened for reading::
 
+   x = json.load(f)
 
+This simple serialization technique can handle lists and dictionaries, but
+serializing arbitrary class instances in JSON requires a bit of extra effort.
+The reference for the :mod:`json` module contains an explanation of this.
+
+.. seealso::
+
+   :mod:`pickle` - the pickle module
+
+   Contrary to :ref:`JSON <tut-json>`, *pickle* is a protocol which allows
+   the serialization of arbitrarily complex Python objects.  As such, it is
+   specific to Python and cannot be used to communicate with applications
+   written in other languages.  It is also insecure by default:
+   deserializing pickle data coming from an untrusted source can execute
+   arbitrary code, if the data was crafted by a skilled attacker.
+
diff -r 3a1db0d2747e Doc/whatsnew/2.4.rst
--- a/Doc/whatsnew/2.4.rst
+++ b/Doc/whatsnew/2.4.rst
@@ -846,7 +846,7 @@
      ['A', 'b', 'c', 'D']
 
   Finally, the *reverse* parameter takes a Boolean value.  If the value is true,
-  the list will be sorted into reverse order. Instead of ``L.sort() ;
+  the list will be sorted into reverse order. Instead of ``L.sort();
   L.reverse()``, you can now write ``L.sort(reverse=True)``.
 
   The results of sorting are now guaranteed to be stable.  This means that two
diff -r 3a1db0d2747e Doc/whatsnew/2.5.rst
--- a/Doc/whatsnew/2.5.rst
+++ b/Doc/whatsnew/2.5.rst
@@ -286,7 +286,7 @@
 :mod:`pkg.string` and look for the standard module; generally you had to look at
 the contents of ``sys.modules``, which is slightly unclean.    Holger Krekel's
 :mod:`py.std` package provides a tidier way to perform imports from the standard
-library, ``import py ; py.std.string.join()``, but that package isn't available
+library, ``import py; py.std.string.join()``, but that package isn't available
 on all Python installations.
 
 Reading code which relies on relative imports is also less clear, because a
diff -r 3a1db0d2747e Doc/whatsnew/2.6.rst
--- a/Doc/whatsnew/2.6.rst
+++ b/Doc/whatsnew/2.6.rst
@@ -1887,7 +1887,7 @@
     >>> dq=deque(maxlen=3)
     >>> dq
     deque([], maxlen=3)
-    >>> dq.append(1) ; dq.append(2) ; dq.append(3)
+    >>> dq.append(1); dq.append(2); dq.append(3)
     >>> dq
     deque([1, 2, 3], maxlen=3)
     >>> dq.append(4)
@@ -2779,12 +2779,12 @@
 types. The following example encodes and decodes a dictionary::
 
        >>> import json
-       >>> data = {"spam" : "foo", "parrot" : 42}
+       >>> data = {"spam": "foo", "parrot": 42}
        >>> in_json = json.dumps(data) # Encode the data
        >>> in_json
        '{"parrot": 42, "spam": "foo"}'
        >>> json.loads(in_json) # Decode into a Python object
-       {"spam" : "foo", "parrot" : 42}
+       {"spam": "foo", "parrot": 42}
 
 It's also possible to write your own decoders and encoders to support
 more types. Pretty-printing of the JSON strings is also supported.
diff -r 3a1db0d2747e Include/import.h
--- a/Include/import.h
+++ b/Include/import.h
@@ -40,8 +40,8 @@
 PyAPI_FUNC(int) _PyImport_IsScript(struct filedescr *);
 PyAPI_FUNC(void) _PyImport_ReInitLock(void);
 
-PyAPI_FUNC(PyObject *)_PyImport_FindExtension(char *, char *);
-PyAPI_FUNC(PyObject *)_PyImport_FixupExtension(char *, char *);
+PyAPI_FUNC(PyObject *) _PyImport_FindExtension(char *, char *);
+PyAPI_FUNC(PyObject *) _PyImport_FixupExtension(char *, char *);
 
 struct _inittab {
     char *name;
diff -r 3a1db0d2747e LICENSE
--- a/LICENSE
+++ b/LICENSE
@@ -74,7 +74,7 @@
 distribute, and otherwise use Python alone or in any derivative version,
 provided, however, that PSF's License Agreement and PSF's notice of copyright,
 i.e., "Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
-2011, 2012, 2013 Python Software Foundation; All Rights Reserved" are retained
+2011, 2012, 2013, 2014 Python Software Foundation; All Rights Reserved" are retained
 in Python alone or in any derivative version prepared by Licensee.
 
 3. In the event Licensee prepares a derivative work that is based on
diff -r 3a1db0d2747e Lib/HTMLParser.py
--- a/Lib/HTMLParser.py
+++ b/Lib/HTMLParser.py
@@ -22,9 +22,12 @@
 starttagopen = re.compile('<[a-zA-Z]')
 piclose = re.compile('>')
 commentclose = re.compile(r'--\s*>')
-tagfind = re.compile('([a-zA-Z][-.a-zA-Z0-9:_]*)(?:\s|/(?!>))*')
+
 # see http://www.w3.org/TR/html5/tokenization.html#tag-open-state
 # and http://www.w3.org/TR/html5/tokenization.html#tag-name-state
+# note: if you change tagfind/attrfind remember to update locatestarttagend too
+tagfind = re.compile('([a-zA-Z][^\t\n\r\f />\x00]*)(?:\s|/(?!>))*')
+# this regex is currently unused, but left for backward compatibility
 tagfind_tolerant = re.compile('[a-zA-Z][^\t\n\r\f />\x00]*')
 
 attrfind = re.compile(
@@ -32,7 +35,7 @@
     r'(\'[^\']*\'|"[^"]*"|(?![\'"])[^>\s]*))?(?:\s|/(?!>))*')
 
 locatestarttagend = re.compile(r"""
-  <[a-zA-Z][-.a-zA-Z0-9:_]*          # tag name
+  <[a-zA-Z][^\t\n\r\f />\x00]*       # tag name
   (?:[\s/]*                          # optional whitespace before attribute name
     (?:(?<=['"\s/])[^\s/>][^\s/=>]*  # attribute name
       (?:\s*=+\s*                    # value indicator
@@ -373,14 +376,14 @@
                 self.handle_data(rawdata[i:gtpos])
                 return gtpos
             # find the name: w3.org/TR/html5/tokenization.html#tag-name-state
-            namematch = tagfind_tolerant.match(rawdata, i+2)
+            namematch = tagfind.match(rawdata, i+2)
             if not namematch:
                 # w3.org/TR/html5/tokenization.html#end-tag-open-state
                 if rawdata[i:i+3] == '</>':
                     return i+3
                 else:
                     return self.parse_bogus_comment(i)
-            tagname = namematch.group().lower()
+            tagname = namematch.group(1).lower()
             # consume and ignore other stuff between the name and the >
             # Note: this is not 100% correct, since we might have things like
             # </tag attr=">">, but looking for > after tha name should cover
diff -r 3a1db0d2747e Lib/_MozillaCookieJar.py
--- a/Lib/_MozillaCookieJar.py
+++ b/Lib/_MozillaCookieJar.py
@@ -39,7 +39,7 @@
     magic_re = "#( Netscape)? HTTP Cookie File"
     header = """\
 # Netscape HTTP Cookie File
-# http://www.netscape.com/newsref/std/cookie_spec.html
+# http://curl.haxx.se/rfc/cookie_spec.html
 # This is a generated file!  Do not edit.
 
 """
diff -r 3a1db0d2747e Lib/_abcoll.py
--- a/Lib/_abcoll.py
+++ b/Lib/_abcoll.py
@@ -165,12 +165,12 @@
     def __gt__(self, other):
         if not isinstance(other, Set):
             return NotImplemented
-        return other < self
+        return other.__lt__(self)
 
     def __ge__(self, other):
         if not isinstance(other, Set):
             return NotImplemented
-        return other <= self
+        return other.__le__(self)
 
     def __eq__(self, other):
         if not isinstance(other, Set):
diff -r 3a1db0d2747e Lib/_weakrefset.py
--- a/Lib/_weakrefset.py
+++ b/Lib/_weakrefset.py
@@ -60,6 +60,8 @@
             for itemref in self.data:
                 item = itemref()
                 if item is not None:
+                    # Caveat: the iterator will keep a strong reference to
+                    # `item` until it is resumed or closed.
                     yield item
 
     def __len__(self):
diff -r 3a1db0d2747e Lib/aifc.py
--- a/Lib/aifc.py
+++ b/Lib/aifc.py
@@ -778,7 +778,7 @@
 
     def _ensure_header_written(self, datasize):
         if not self._nframeswritten:
-            if self._comptype in ('ULAW', 'ALAW'):
+            if self._comptype in ('ULAW', 'ulaw', 'ALAW', 'alaw'):
                 if not self._sampwidth:
                     self._sampwidth = 2
                 if self._sampwidth != 2:
@@ -844,7 +844,7 @@
         if self._datalength & 1:
             self._datalength = self._datalength + 1
         if self._aifc:
-            if self._comptype in ('ULAW', 'ALAW'):
+            if self._comptype in ('ULAW', 'ulaw', 'ALAW', 'alaw'):
                 self._datalength = self._datalength // 2
                 if self._datalength & 1:
                     self._datalength = self._datalength + 1
@@ -852,7 +852,10 @@
                 self._datalength = (self._datalength + 3) // 4
                 if self._datalength & 1:
                     self._datalength = self._datalength + 1
-        self._form_length_pos = self._file.tell()
+        try:
+            self._form_length_pos = self._file.tell()
+        except (AttributeError, IOError):
+            self._form_length_pos = None
         commlength = self._write_form_length(self._datalength)
         if self._aifc:
             self._file.write('AIFC')
@@ -864,7 +867,8 @@
         self._file.write('COMM')
         _write_ulong(self._file, commlength)
         _write_short(self._file, self._nchannels)
-        self._nframes_pos = self._file.tell()
+        if self._form_length_pos is not None:
+            self._nframes_pos = self._file.tell()
         _write_ulong(self._file, self._nframes)
         if self._comptype in ('ULAW', 'ulaw', 'ALAW', 'alaw', 'G722'):
             _write_short(self._file, 8)
@@ -875,7 +879,8 @@
             self._file.write(self._comptype)
             _write_string(self._file, self._compname)
         self._file.write('SSND')
-        self._ssnd_length_pos = self._file.tell()
+        if self._form_length_pos is not None:
+            self._ssnd_length_pos = self._file.tell()
         _write_ulong(self._file, self._datalength + 8)
         _write_ulong(self._file, 0)
         _write_ulong(self._file, 0)
diff -r 3a1db0d2747e Lib/argparse.py
--- a/Lib/argparse.py
+++ b/Lib/argparse.py
@@ -168,6 +168,8 @@
         self._prog = prog
         self._indent_increment = indent_increment
         self._max_help_position = max_help_position
+        self._max_help_position = min(max_help_position,
+                                      max(width - 20, indent_increment * 2))
         self._width = width
 
         self._current_indent = 0
@@ -339,7 +341,7 @@
                     else:
                         line_len = len(indent) - 1
                     for part in parts:
-                        if line_len + 1 + len(part) > text_width:
+                        if line_len + 1 + len(part) > text_width and line:
                             lines.append(indent + ' '.join(line))
                             line = []
                             line_len = len(indent) - 1
@@ -478,7 +480,7 @@
     def _format_text(self, text):
         if '%(prog)' in text:
             text = text % dict(prog=self._prog)
-        text_width = self._width - self._current_indent
+        text_width = max(self._width - self._current_indent, 11)
         indent = ' ' * self._current_indent
         return self._fill_text(text, text_width, indent) + '\n\n'
 
@@ -486,7 +488,7 @@
         # determine the required width and the entry label
         help_position = min(self._action_max_length + 2,
                             self._max_help_position)
-        help_width = self._width - help_position
+        help_width = max(self._width - help_position, 11)
         action_width = help_position - self._current_indent - 2
         action_header = self._format_action_invocation(action)
 
diff -r 3a1db0d2747e Lib/csv.py
--- a/Lib/csv.py
+++ b/Lib/csv.py
@@ -93,6 +93,10 @@
         self.line_num = self.reader.line_num
         return self._fieldnames
 
+    # Issue 20004: Because DictReader is a classic class, this setter is
+    # ignored.  At this point in 2.7's lifecycle, it is too late to change the
+    # base class for fear of breaking working code.  If you want to change
+    # fieldnames without overwriting the getter, set _fieldnames directly.
     @fieldnames.setter
     def fieldnames(self, value):
         self._fieldnames = value
@@ -140,8 +144,8 @@
         if self.extrasaction == "raise":
             wrong_fields = [k for k in rowdict if k not in self.fieldnames]
             if wrong_fields:
-                raise ValueError("dict contains fields not in fieldnames: " +
-                                 ", ".join(wrong_fields))
+                raise ValueError("dict contains fields not in fieldnames: "
+                                 + ", ".join([repr(x) for x in wrong_fields]))
         return [rowdict.get(key, self.restval) for key in self.fieldnames]
 
     def writerow(self, rowdict):
diff -r 3a1db0d2747e Lib/ctypes/test/test_arrays.py
--- a/Lib/ctypes/test/test_arrays.py
+++ b/Lib/ctypes/test/test_arrays.py
@@ -87,8 +87,8 @@
         self.assertEqual(values, [1, 2, 3, 4, 5])
 
     def test_classcache(self):
-        self.assertTrue(not ARRAY(c_int, 3) is ARRAY(c_int, 4))
-        self.assertTrue(ARRAY(c_int, 3) is ARRAY(c_int, 3))
+        self.assertIsNot(ARRAY(c_int, 3), ARRAY(c_int, 4))
+        self.assertIs(ARRAY(c_int, 3), ARRAY(c_int, 3))
 
     def test_from_address(self):
         # Failed with 0.9.8, reported by JUrner
@@ -128,7 +128,7 @@
         # Create a new array type based on it:
         t1 = my_int * 1
         t2 = my_int * 1
-        self.assertTrue(t1 is t2)
+        self.assertIs(t1, t2)
 
 if __name__ == '__main__':
     unittest.main()
diff -r 3a1db0d2747e Lib/ctypes/test/test_as_parameter.py
--- a/Lib/ctypes/test/test_as_parameter.py
+++ b/Lib/ctypes/test/test_as_parameter.py
@@ -134,7 +134,7 @@
         f.argtypes = [c_longlong, MyCallback]
 
         def callback(value):
-            self.assertTrue(isinstance(value, (int, long)))
+            self.assertIsInstance(value, (int, long))
             return value & 0x7FFFFFFF
 
         cb = MyCallback(callback)
diff -r 3a1db0d2747e Lib/ctypes/test/test_buffers.py
--- a/Lib/ctypes/test/test_buffers.py
+++ b/Lib/ctypes/test/test_buffers.py
@@ -7,12 +7,12 @@
         b = create_string_buffer(32)
         self.assertEqual(len(b), 32)
         self.assertEqual(sizeof(b), 32 * sizeof(c_char))
-        self.assertTrue(type(b[0]) is str)
+        self.assertIs(type(b[0]), str)
 
         b = create_string_buffer("abc")
         self.assertEqual(len(b), 4) # trailing nul char
         self.assertEqual(sizeof(b), 4 * sizeof(c_char))
-        self.assertTrue(type(b[0]) is str)
+        self.assertIs(type(b[0]), str)
         self.assertEqual(b[0], "a")
         self.assertEqual(b[:], "abc\0")
         self.assertEqual(b[::], "abc\0")
@@ -45,12 +45,12 @@
             b = create_unicode_buffer(32)
             self.assertEqual(len(b), 32)
             self.assertEqual(sizeof(b), 32 * sizeof(c_wchar))
-            self.assertTrue(type(b[0]) is unicode)
+            self.assertIs(type(b[0]), unicode)
 
             b = create_unicode_buffer(u"abc")
             self.assertEqual(len(b), 4) # trailing nul char
             self.assertEqual(sizeof(b), 4 * sizeof(c_wchar))
-            self.assertTrue(type(b[0]) is unicode)
+            self.assertIs(type(b[0]), unicode)
             self.assertEqual(b[0], u"a")
             self.assertEqual(b[:], "abc\0")
             self.assertEqual(b[::], "abc\0")
@@ -62,7 +62,7 @@
             b = create_unicode_buffer("abc")
             self.assertEqual(len(b), 4) # trailing nul char
             self.assertEqual(sizeof(b), 4 * sizeof(c_wchar))
-            self.assertTrue(type(b[0]) is unicode)
+            self.assertIs(type(b[0]), unicode)
             self.assertEqual(b[0], u"a")
             self.assertEqual(b[:], "abc\0")
             self.assertEqual(b[::], "abc\0")
diff -r 3a1db0d2747e Lib/ctypes/test/test_byteswap.py
--- a/Lib/ctypes/test/test_byteswap.py
+++ b/Lib/ctypes/test/test_byteswap.py
@@ -23,11 +23,11 @@
 
     def test_endian_short(self):
         if sys.byteorder == "little":
-            self.assertTrue(c_short.__ctype_le__ is c_short)
-            self.assertTrue(c_short.__ctype_be__.__ctype_le__ is c_short)
+            self.assertIs(c_short.__ctype_le__, c_short)
+            self.assertIs(c_short.__ctype_be__.__ctype_le__, c_short)
         else:
-            self.assertTrue(c_short.__ctype_be__ is c_short)
-            self.assertTrue(c_short.__ctype_le__.__ctype_be__ is c_short)
+            self.assertIs(c_short.__ctype_be__, c_short)
+            self.assertIs(c_short.__ctype_le__.__ctype_be__, c_short)
         s = c_short.__ctype_be__(0x1234)
         self.assertEqual(bin(struct.pack(">h", 0x1234)), "1234")
         self.assertEqual(bin(s), "1234")
@@ -50,11 +50,11 @@
 
     def test_endian_int(self):
         if sys.byteorder == "little":
-            self.assertTrue(c_int.__ctype_le__ is c_int)
-            self.assertTrue(c_int.__ctype_be__.__ctype_le__ is c_int)
+            self.assertIs(c_int.__ctype_le__, c_int)
+            self.assertIs(c_int.__ctype_be__.__ctype_le__, c_int)
         else:
-            self.assertTrue(c_int.__ctype_be__ is c_int)
-            self.assertTrue(c_int.__ctype_le__.__ctype_be__ is c_int)
+            self.assertIs(c_int.__ctype_be__, c_int)
+            self.assertIs(c_int.__ctype_le__.__ctype_be__, c_int)
 
         s = c_int.__ctype_be__(0x12345678)
         self.assertEqual(bin(struct.pack(">i", 0x12345678)), "12345678")
@@ -78,11 +78,11 @@
 
     def test_endian_longlong(self):
         if sys.byteorder == "little":
-            self.assertTrue(c_longlong.__ctype_le__ is c_longlong)
-            self.assertTrue(c_longlong.__ctype_be__.__ctype_le__ is c_longlong)
+            self.assertIs(c_longlong.__ctype_le__, c_longlong)
+            self.assertIs(c_longlong.__ctype_be__.__ctype_le__, c_longlong)
         else:
-            self.assertTrue(c_longlong.__ctype_be__ is c_longlong)
-            self.assertTrue(c_longlong.__ctype_le__.__ctype_be__ is c_longlong)
+            self.assertIs(c_longlong.__ctype_be__, c_longlong)
+            self.assertIs(c_longlong.__ctype_le__.__ctype_be__, c_longlong)
 
         s = c_longlong.__ctype_be__(0x1234567890ABCDEF)
         self.assertEqual(bin(struct.pack(">q", 0x1234567890ABCDEF)), "1234567890ABCDEF")
@@ -106,11 +106,11 @@
 
     def test_endian_float(self):
         if sys.byteorder == "little":
-            self.assertTrue(c_float.__ctype_le__ is c_float)
-            self.assertTrue(c_float.__ctype_be__.__ctype_le__ is c_float)
+            self.assertIs(c_float.__ctype_le__, c_float)
+            self.assertIs(c_float.__ctype_be__.__ctype_le__, c_float)
         else:
-            self.assertTrue(c_float.__ctype_be__ is c_float)
-            self.assertTrue(c_float.__ctype_le__.__ctype_be__ is c_float)
+            self.assertIs(c_float.__ctype_be__, c_float)
+            self.assertIs(c_float.__ctype_le__.__ctype_be__, c_float)
         s = c_float(math.pi)
         self.assertEqual(bin(struct.pack("f", math.pi)), bin(s))
         # Hm, what's the precision of a float compared to a double?
@@ -124,11 +124,11 @@
 
     def test_endian_double(self):
         if sys.byteorder == "little":
-            self.assertTrue(c_double.__ctype_le__ is c_double)
-            self.assertTrue(c_double.__ctype_be__.__ctype_le__ is c_double)
+            self.assertIs(c_double.__ctype_le__, c_double)
+            self.assertIs(c_double.__ctype_be__.__ctype_le__, c_double)
         else:
-            self.assertTrue(c_double.__ctype_be__ is c_double)
-            self.assertTrue(c_double.__ctype_le__.__ctype_be__ is c_double)
+            self.assertIs(c_double.__ctype_be__, c_double)
+            self.assertIs(c_double.__ctype_le__.__ctype_be__, c_double)
         s = c_double(math.pi)
         self.assertEqual(s.value, math.pi)
         self.assertEqual(bin(struct.pack("d", math.pi)), bin(s))
@@ -140,14 +140,14 @@
         self.assertEqual(bin(struct.pack(">d", math.pi)), bin(s))
 
     def test_endian_other(self):
-        self.assertTrue(c_byte.__ctype_le__ is c_byte)
-        self.assertTrue(c_byte.__ctype_be__ is c_byte)
+        self.assertIs(c_byte.__ctype_le__, c_byte)
+        self.assertIs(c_byte.__ctype_be__, c_byte)
 
-        self.assertTrue(c_ubyte.__ctype_le__ is c_ubyte)
-        self.assertTrue(c_ubyte.__ctype_be__ is c_ubyte)
+        self.assertIs(c_ubyte.__ctype_le__, c_ubyte)
+        self.assertIs(c_ubyte.__ctype_be__, c_ubyte)
 
-        self.assertTrue(c_char.__ctype_le__ is c_char)
-        self.assertTrue(c_char.__ctype_be__ is c_char)
+        self.assertIs(c_char.__ctype_le__, c_char)
+        self.assertIs(c_char.__ctype_be__, c_char)
 
     def test_struct_fields_1(self):
         if sys.byteorder == "little":
diff -r 3a1db0d2747e Lib/ctypes/test/test_cast.py
--- a/Lib/ctypes/test/test_cast.py
+++ b/Lib/ctypes/test/test_cast.py
@@ -38,14 +38,14 @@
 
         p = cast(array, POINTER(c_char_p))
         # array and p share a common _objects attribute
-        self.assertTrue(p._objects is array._objects)
+        self.assertIs(p._objects, array._objects)
         self.assertEqual(array._objects, {'0': "foo bar", id(array): array})
         p[0] = "spam spam"
         self.assertEqual(p._objects, {'0': "spam spam", id(array): array})
-        self.assertTrue(array._objects is p._objects)
+        self.assertIs(array._objects, p._objects)
         p[1] = "foo bar"
         self.assertEqual(p._objects, {'1': 'foo bar', '0': "spam spam", id(array): array})
-        self.assertTrue(array._objects is p._objects)
+        self.assertIs(array._objects, p._objects)
 
     def test_other(self):
         p = cast((c_int * 4)(1, 2, 3, 4), POINTER(c_int))
diff -r 3a1db0d2747e Lib/ctypes/test/test_frombuffer.py
--- a/Lib/ctypes/test/test_frombuffer.py
+++ b/Lib/ctypes/test/test_frombuffer.py
@@ -23,7 +23,7 @@
         a[0], a[-1] = 200, -200
         self.assertEqual(x[:], a.tolist())
 
-        self.assertTrue(a in x._objects.values())
+        self.assertIn(a, x._objects.values())
 
         self.assertRaises(ValueError,
                           c_int.from_buffer, a, -1)
diff -r 3a1db0d2747e Lib/ctypes/test/test_funcptr.py
--- a/Lib/ctypes/test/test_funcptr.py
+++ b/Lib/ctypes/test/test_funcptr.py
@@ -75,7 +75,7 @@
         ##                  "lpfnWndProc", WNDPROC_2(wndproc))
         # instead:
 
-        self.assertTrue(WNDPROC is WNDPROC_2)
+        self.assertIs(WNDPROC, WNDPROC_2)
         # 'wndclass.lpfnWndProc' leaks 94 references.  Why?
         self.assertEqual(wndclass.lpfnWndProc(1, 2, 3, 4), 10)
 
diff -r 3a1db0d2747e Lib/ctypes/test/test_functions.py
--- a/Lib/ctypes/test/test_functions.py
+++ b/Lib/ctypes/test/test_functions.py
@@ -306,7 +306,7 @@
         f.argtypes = [c_longlong, MyCallback]
 
         def callback(value):
-            self.assertTrue(isinstance(value, (int, long)))
+            self.assertIsInstance(value, (int, long))
             return value & 0x7FFFFFFF
 
         cb = MyCallback(callback)
diff -r 3a1db0d2747e Lib/ctypes/test/test_loading.py
--- a/Lib/ctypes/test/test_loading.py
+++ b/Lib/ctypes/test/test_loading.py
@@ -43,7 +43,7 @@
 
     if os.name in ("nt", "ce"):
         def test_load_library(self):
-            self.assertFalse(libc_name is None)
+            self.assertIsNotNone(libc_name)
             if is_resource_enabled("printing"):
                 print find_library("kernel32")
                 print find_library("user32")
diff -r 3a1db0d2747e Lib/ctypes/test/test_numbers.py
--- a/Lib/ctypes/test/test_numbers.py
+++ b/Lib/ctypes/test/test_numbers.py
@@ -181,10 +181,10 @@
             a = array(t._type_, [3.14])
             v = t.from_address(a.buffer_info()[0])
             self.assertEqual(v.value, a[0])
-            self.assertTrue(type(v) is t)
+            self.assertIs(type(v), t)
             a[0] = 2.3456e17
             self.assertEqual(v.value, a[0])
-            self.assertTrue(type(v) is t)
+            self.assertIs(type(v), t)
 
     def test_char_from_address(self):
         from ctypes import c_char
@@ -193,7 +193,7 @@
         a = array('c', 'x')
         v = c_char.from_address(a.buffer_info()[0])
         self.assertEqual(v.value, a[0])
-        self.assertTrue(type(v) is c_char)
+        self.assertIs(type(v), c_char)
 
         a[0] = '?'
         self.assertEqual(v.value, a[0])
diff -r 3a1db0d2747e Lib/ctypes/test/test_parameters.py
--- a/Lib/ctypes/test/test_parameters.py
+++ b/Lib/ctypes/test/test_parameters.py
@@ -55,7 +55,7 @@
         # c_char_p.from_param on a Python String packs the string
         # into a cparam object
         s = "123"
-        self.assertTrue(c_char_p.from_param(s)._obj is s)
+        self.assertIs(c_char_p.from_param(s)._obj, s)
 
         # new in 0.9.1: convert (encode) unicode to ascii
         self.assertEqual(c_char_p.from_param(u"123")._obj, "123")
@@ -66,7 +66,7 @@
         # calling c_char_p.from_param with a c_char_p instance
         # returns the argument itself:
         a = c_char_p("123")
-        self.assertTrue(c_char_p.from_param(a) is a)
+        self.assertIs(c_char_p.from_param(a), a)
 
     def test_cw_strings(self):
         from ctypes import byref
diff -r 3a1db0d2747e Lib/ctypes/test/test_pointers.py
--- a/Lib/ctypes/test/test_pointers.py
+++ b/Lib/ctypes/test/test_pointers.py
@@ -78,7 +78,7 @@
 
 ##        i = c_int(42)
 ##        callback(byref(i))
-##        self.assertTrue(i.value == 84)
+##        self.assertEqual(i.value, 84)
 
         doit(callback)
 ##        print self.result
@@ -91,11 +91,11 @@
             i = ct(42)
             p = pointer(i)
 ##            print type(p.contents), ct
-            self.assertTrue(type(p.contents) is ct)
+            self.assertIs(type(p.contents), ct)
             # p.contents is the same as p[0]
 ##            print p.contents
-##            self.assertTrue(p.contents == 42)
-##            self.assertTrue(p[0] == 42)
+##            self.assertEqual(p.contents, 42)
+##            self.assertEqual(p[0], 42)
 
             self.assertRaises(TypeError, delitem, p, 0)
 
diff -r 3a1db0d2747e Lib/ctypes/test/test_python_api.py
--- a/Lib/ctypes/test/test_python_api.py
+++ b/Lib/ctypes/test/test_python_api.py
@@ -61,7 +61,7 @@
         ref = grc(s)
         # id(python-object) is the address
         pyobj = PyObj_FromPtr(id(s))
-        self.assertTrue(s is pyobj)
+        self.assertIs(s, pyobj)
 
         self.assertEqual(grc(s), ref + 1)
         del pyobj
diff -r 3a1db0d2747e Lib/ctypes/test/test_refcounts.py
--- a/Lib/ctypes/test/test_refcounts.py
+++ b/Lib/ctypes/test/test_refcounts.py
@@ -24,7 +24,7 @@
         self.assertEqual(grc(callback), 2)
         cb = MyCallback(callback)
 
-        self.assertTrue(grc(callback) > 2)
+        self.assertGreater(grc(callback), 2)
         result = f(-10, cb)
         self.assertEqual(result, -18)
         cb = None
@@ -43,15 +43,15 @@
 
         # the CFuncPtr instance holds at least one refcount on func:
         f = OtherCallback(func)
-        self.assertTrue(grc(func) > 2)
+        self.assertGreater(grc(func), 2)
 
         # and may release it again
         del f
-        self.assertTrue(grc(func) >= 2)
+        self.assertGreaterEqual(grc(func), 2)
 
         # but now it must be gone
         gc.collect()
-        self.assertTrue(grc(func) == 2)
+        self.assertEqual(grc(func), 2)
 
         class X(ctypes.Structure):
             _fields_ = [("a", OtherCallback)]
@@ -59,11 +59,11 @@
         x.a = OtherCallback(func)
 
         # the CFuncPtr instance holds at least one refcount on func:
-        self.assertTrue(grc(func) > 2)
+        self.assertGreater(grc(func), 2)
 
         # and may release it again
         del x
-        self.assertTrue(grc(func) >= 2)
+        self.assertGreaterEqual(grc(func), 2)
 
         # and now it must be gone again
         gc.collect()
@@ -72,7 +72,7 @@
         f = OtherCallback(func)
 
         # the CFuncPtr instance holds at least one refcount on func:
-        self.assertTrue(grc(func) > 2)
+        self.assertGreater(grc(func), 2)
 
         # create a cycle
         f.cycle = f
diff -r 3a1db0d2747e Lib/ctypes/test/test_strings.py
--- a/Lib/ctypes/test/test_strings.py
+++ b/Lib/ctypes/test/test_strings.py
@@ -115,24 +115,24 @@
 
         # New in releases later than 0.4.0:
         # c_string(number) returns an empty string of size number
-        self.assertTrue(len(c_string(32).raw) == 32)
+        self.assertEqual(len(c_string(32).raw), 32)
         self.assertRaises(ValueError, c_string, -1)
         self.assertRaises(ValueError, c_string, 0)
 
         # These tests fail, because it is no longer initialized
-##        self.assertTrue(c_string(2).value == "")
-##        self.assertTrue(c_string(2).raw == "\000\000")
-        self.assertTrue(c_string(2).raw[-1] == "\000")
-        self.assertTrue(len(c_string(2).raw) == 2)
+##        self.assertEqual(c_string(2).value, "")
+##        self.assertEqual(c_string(2).raw, "\000\000")
+        self.assertEqual(c_string(2).raw[-1], "\000")
+        self.assertEqual(len(c_string(2).raw), 2)
 
     def XX_test_initialized_strings(self):
 
-        self.assertTrue(c_string("ab", 4).raw[:2] == "ab")
-        self.assertTrue(c_string("ab", 4).raw[:2:] == "ab")
-        self.assertTrue(c_string("ab", 4).raw[:2:-1] == "ba")
-        self.assertTrue(c_string("ab", 4).raw[:2:2] == "a")
-        self.assertTrue(c_string("ab", 4).raw[-1] == "\000")
-        self.assertTrue(c_string("ab", 2).raw == "a\000")
+        self.assertEqual(c_string("ab", 4).raw[:2], "ab")
+        self.assertEqual(c_string("ab", 4).raw[:2:], "ab")
+        self.assertEqual(c_string("ab", 4).raw[:2:-1], "ba")
+        self.assertEqual(c_string("ab", 4).raw[:2:2], "a")
+        self.assertEqual(c_string("ab", 4).raw[-1], "\000")
+        self.assertEqual(c_string("ab", 2).raw, "a\000")
 
     def XX_test_toolong(self):
         cs = c_string("abcdef")
@@ -163,22 +163,22 @@
             # XXX This behaviour is about to change:
             # len returns the size of the internal buffer in bytes.
             # This includes the terminating NUL character.
-            self.assertTrue(sizeof(cs) == 14)
+            self.assertEqual(sizeof(cs), 14)
 
             # The value property is the string up to the first terminating NUL.
-            self.assertTrue(cs.value == u"abcdef")
-            self.assertTrue(c_wstring(u"abc\000def").value == u"abc")
+            self.assertEqual(cs.value, u"abcdef")
+            self.assertEqual(c_wstring(u"abc\000def").value, u"abc")
 
-            self.assertTrue(c_wstring(u"abc\000def").value == u"abc")
+            self.assertEqual(c_wstring(u"abc\000def").value, u"abc")
 
             # The raw property is the total buffer contents:
-            self.assertTrue(cs.raw == u"abcdef\000")
-            self.assertTrue(c_wstring(u"abc\000def").raw == u"abc\000def\000")
+            self.assertEqual(cs.raw, u"abcdef\000")
+            self.assertEqual(c_wstring(u"abc\000def").raw, u"abc\000def\000")
 
             # We can change the value:
             cs.value = u"ab"
-            self.assertTrue(cs.value == u"ab")
-            self.assertTrue(cs.raw == u"ab\000\000\000\000\000")
+            self.assertEqual(cs.value, u"ab")
+            self.assertEqual(cs.raw, u"ab\000\000\000\000\000")
 
             self.assertRaises(TypeError, c_wstring, "123")
             self.assertRaises(ValueError, c_wstring, 0)
diff -r 3a1db0d2747e Lib/ctypes/test/test_structures.py
--- a/Lib/ctypes/test/test_structures.py
+++ b/Lib/ctypes/test/test_structures.py
@@ -380,9 +380,9 @@
 ##        class X(Structure):
 ##            _fields_ = []
 
-        self.assertTrue("in_dll" in dir(type(Structure)))
-        self.assertTrue("from_address" in dir(type(Structure)))
-        self.assertTrue("in_dll" in dir(type(Structure)))
+        self.assertIn("in_dll", dir(type(Structure)))
+        self.assertIn("from_address", dir(type(Structure)))
+        self.assertIn("in_dll", dir(type(Structure)))
 
     def test_positional_args(self):
         # see also http://bugs.python.org/issue5042
@@ -452,8 +452,8 @@
         try:
             Recursive._fields_ = [("next", Recursive)]
         except AttributeError, details:
-            self.assertTrue("Structure or union cannot contain itself" in
-                            str(details))
+            self.assertIn("Structure or union cannot contain itself",
+                          str(details))
         else:
             self.fail("Structure or union cannot contain itself")
 
@@ -469,8 +469,7 @@
         try:
             Second._fields_ = [("first", First)]
         except AttributeError, details:
-            self.assertTrue("_fields_ is final" in
-                            str(details))
+            self.assertIn("_fields_ is final", str(details))
         else:
             self.fail("AttributeError not raised")
 
diff -r 3a1db0d2747e Lib/distutils/command/build_py.py
--- a/Lib/distutils/command/build_py.py
+++ b/Lib/distutils/command/build_py.py
@@ -128,7 +128,8 @@
             # Each pattern has to be converted to a platform-specific path
             filelist = glob(os.path.join(src_dir, convert_path(pattern)))
             # Files that match more than one pattern are only added once
-            files.extend([fn for fn in filelist if fn not in files])
+            files.extend([fn for fn in filelist if fn not in files
+                and os.path.isfile(fn)])
         return files
 
     def build_package_data(self):
diff -r 3a1db0d2747e Lib/distutils/command/upload.py
--- a/Lib/distutils/command/upload.py
+++ b/Lib/distutils/command/upload.py
@@ -177,7 +177,7 @@
             status = result.getcode()
             reason = result.msg
             if self.show_response:
-                msg = '\n'.join(('-' * 75, r.read(), '-' * 75))
+                msg = '\n'.join(('-' * 75, result.read(), '-' * 75))
                 self.announce(msg, log.INFO)
         except socket.error, e:
             self.announce(str(e), log.ERROR)
diff -r 3a1db0d2747e Lib/distutils/config.py
--- a/Lib/distutils/config.py
+++ b/Lib/distutils/config.py
@@ -21,7 +21,7 @@
 class PyPIRCCommand(Command):
     """Base command that knows how to handle the .pypirc file
     """
-    DEFAULT_REPOSITORY = 'http://pypi.python.org/pypi'
+    DEFAULT_REPOSITORY = 'https://pypi.python.org/pypi'
     DEFAULT_REALM = 'pypi'
     repository = None
     realm = None
diff -r 3a1db0d2747e Lib/distutils/tests/test_archive_util.py
--- a/Lib/distutils/tests/test_archive_util.py
+++ b/Lib/distutils/tests/test_archive_util.py
@@ -199,7 +199,7 @@
                              dry_run=True)
         finally:
             os.chdir(old_dir)
-        self.assertTrue(not os.path.exists(tarball))
+        self.assertFalse(os.path.exists(tarball))
         self.assertEqual(len(w.warnings), 1)
 
     @unittest.skipUnless(zlib, "Requires zlib")
diff -r 3a1db0d2747e Lib/distutils/tests/test_bdist_rpm.py
--- a/Lib/distutils/tests/test_bdist_rpm.py
+++ b/Lib/distutils/tests/test_bdist_rpm.py
@@ -39,18 +39,15 @@
         sys.argv[:] = self.old_sys_argv[1]
         super(BuildRpmTestCase, self).tearDown()
 
+    # XXX I am unable yet to make this test work without
+    # spurious sdtout/stderr output under Mac OS X
+    @unittest.skipUnless(sys.platform.startswith('linux'),
+                         'spurious sdtout/stderr output under Mac OS X')
+    @unittest.skipIf(find_executable('rpm') is None,
+                     'the rpm command is not found')
+    @unittest.skipIf(find_executable('rpmbuild') is None,
+                     'the rpmbuild command is not found')
     def test_quiet(self):
-
-        # XXX I am unable yet to make this test work without
-        # spurious sdtout/stderr output under Mac OS X
-        if sys.platform != 'linux2':
-            return
-
-        # this test will run only if the rpm commands are found
-        if (find_executable('rpm') is None or
-            find_executable('rpmbuild') is None):
-            return
-
         # let's create a package
         tmp_dir = self.mkdtemp()
         pkg_dir = os.path.join(tmp_dir, 'foo')
@@ -77,25 +74,22 @@
         cmd.run()
 
         dist_created = os.listdir(os.path.join(pkg_dir, 'dist'))
-        self.assertTrue('foo-0.1-1.noarch.rpm' in dist_created)
+        self.assertIn('foo-0.1-1.noarch.rpm', dist_created)
 
         # bug #2945: upload ignores bdist_rpm files
         self.assertIn(('bdist_rpm', 'any', 'dist/foo-0.1-1.src.rpm'), dist.dist_files)
         self.assertIn(('bdist_rpm', 'any', 'dist/foo-0.1-1.noarch.rpm'), dist.dist_files)
 
+    # XXX I am unable yet to make this test work without
+    # spurious sdtout/stderr output under Mac OS X
+    @unittest.skipUnless(sys.platform.startswith('linux'),
+                         'spurious sdtout/stderr output under Mac OS X')
+    # http://bugs.python.org/issue1533164
+    @unittest.skipIf(find_executable('rpm') is None,
+                     'the rpm command is not found')
+    @unittest.skipIf(find_executable('rpmbuild') is None,
+                     'the rpmbuild command is not found')
     def test_no_optimize_flag(self):
-
-        # XXX I am unable yet to make this test work without
-        # spurious sdtout/stderr output under Mac OS X
-        if sys.platform != 'linux2':
-            return
-
-        # http://bugs.python.org/issue1533164
-        # this test will run only if the rpm command is found
-        if (find_executable('rpm') is None or
-            find_executable('rpmbuild') is None):
-            return
-
         # let's create a package that brakes bdist_rpm
         tmp_dir = self.mkdtemp()
         pkg_dir = os.path.join(tmp_dir, 'foo')
@@ -121,7 +115,7 @@
         cmd.run()
 
         dist_created = os.listdir(os.path.join(pkg_dir, 'dist'))
-        self.assertTrue('foo-0.1-1.noarch.rpm' in dist_created)
+        self.assertIn('foo-0.1-1.noarch.rpm', dist_created)
 
         # bug #2945: upload ignores bdist_rpm files
         self.assertIn(('bdist_rpm', 'any', 'dist/foo-0.1-1.src.rpm'), dist.dist_files)
diff -r 3a1db0d2747e Lib/distutils/tests/test_bdist_wininst.py
--- a/Lib/distutils/tests/test_bdist_wininst.py
+++ b/Lib/distutils/tests/test_bdist_wininst.py
@@ -23,7 +23,7 @@
         # and make sure it finds it and returns its content
         # no matter what platform we have
         exe_file = cmd.get_exe_bytes()
-        self.assertTrue(len(exe_file) > 10)
+        self.assertGreater(len(exe_file), 10)
 
 def test_suite():
     return unittest.makeSuite(BuildWinInstTestCase)
diff -r 3a1db0d2747e Lib/distutils/tests/test_build_clib.py
--- a/Lib/distutils/tests/test_build_clib.py
+++ b/Lib/distutils/tests/test_build_clib.py
@@ -102,11 +102,8 @@
         cmd.distribution.libraries = 'WONTWORK'
         self.assertRaises(DistutilsSetupError, cmd.finalize_options)
 
+    @unittest.skipIf(sys.platform == 'win32', "can't test on Windows")
     def test_run(self):
-        # can't test on windows
-        if sys.platform == 'win32':
-            return
-
         pkg_dir, dist = self.create_dist()
         cmd = build_clib(dist)
 
@@ -131,13 +128,13 @@
             if ccmd is None:
                 continue
             if find_executable(ccmd[0]) is None:
-                return # can't test
+                self.skipTest('The %r command is not found' % ccmd[0])
 
         # this should work
         cmd.run()
 
         # let's check the result
-        self.assertTrue('libfoo.a' in os.listdir(build_temp))
+        self.assertIn('libfoo.a', os.listdir(build_temp))
 
 def test_suite():
     return unittest.makeSuite(BuildCLibTestCase)
diff -r 3a1db0d2747e Lib/distutils/tests/test_build_ext.py
--- a/Lib/distutils/tests/test_build_ext.py
+++ b/Lib/distutils/tests/test_build_ext.py
@@ -65,9 +65,9 @@
             sys.stdout = old_stdout
 
         if ALREADY_TESTED:
-            return
+            self.skipTest('Already tested in %s' % ALREADY_TESTED)
         else:
-            ALREADY_TESTED = True
+            ALREADY_TESTED = type(self).__name__
 
         import xx
 
@@ -80,8 +80,8 @@
         if test_support.HAVE_DOCSTRINGS:
             doc = 'This is a template module just for instruction.'
             self.assertEqual(xx.__doc__, doc)
-        self.assertTrue(isinstance(xx.Null(), xx.Null))
-        self.assertTrue(isinstance(xx.Str(), xx.Str))
+        self.assertIsInstance(xx.Null(), xx.Null)
+        self.assertIsInstance(xx.Str(), xx.Str)
 
     def test_solaris_enable_shared(self):
         dist = Distribution({'name': 'xx'})
@@ -102,13 +102,11 @@
                 _config_vars['Py_ENABLE_SHARED'] = old_var
 
         # make sure we get some library dirs under solaris
-        self.assertTrue(len(cmd.library_dirs) > 0)
+        self.assertGreater(len(cmd.library_dirs), 0)
 
+    @unittest.skipIf(sys.version < '2.6',
+                     'site.USER_SITE was introduced in 2.6')
     def test_user_site(self):
-        # site.USER_SITE was introduced in 2.6
-        if sys.version < '2.6':
-            return
-
         import site
         dist = Distribution({'name': 'xx'})
         cmd = build_ext(dist)
@@ -143,10 +141,10 @@
         cmd.finalize_options()
 
         py_include = sysconfig.get_python_inc()
-        self.assertTrue(py_include in cmd.include_dirs)
+        self.assertIn(py_include, cmd.include_dirs)
 
         plat_py_include = sysconfig.get_python_inc(plat_specific=1)
-        self.assertTrue(plat_py_include in cmd.include_dirs)
+        self.assertIn(plat_py_include, cmd.include_dirs)
 
         # make sure cmd.libraries is turned into a list
         # if it's a string
@@ -226,13 +224,13 @@
                              'some': 'bar'})]
         cmd.check_extensions_list(exts)
         ext = exts[0]
-        self.assertTrue(isinstance(ext, Extension))
+        self.assertIsInstance(ext, Extension)
 
         # check_extensions_list adds in ext the values passed
         # when they are in ('include_dirs', 'library_dirs', 'libraries'
         # 'extra_objects', 'extra_compile_args', 'extra_link_args')
         self.assertEqual(ext.libraries, 'foo')
-        self.assertTrue(not hasattr(ext, 'some'))
+        self.assertFalse(hasattr(ext, 'some'))
 
         # 'macros' element of build info dict must be 1- or 2-tuple
         exts = [('foo.bar', {'sources': [''], 'libraries': 'foo',
@@ -414,9 +412,8 @@
         wanted = os.path.join(cmd.build_lib, 'UpdateManager', 'fdsend' + ext)
         self.assertEqual(ext_path, wanted)
 
+    @unittest.skipUnless(sys.platform == 'win32', 'these tests require Windows')
     def test_build_ext_path_cross_platform(self):
-        if sys.platform != 'win32':
-            return
         dist = Distribution({'name': 'UpdateManager'})
         cmd = build_ext(dist)
         cmd.ensure_finalized()
diff -r 3a1db0d2747e Lib/distutils/tests/test_build_py.py
--- a/Lib/distutils/tests/test_build_py.py
+++ b/Lib/distutils/tests/test_build_py.py
@@ -99,6 +99,37 @@
             os.chdir(cwd)
             sys.stdout = old_stdout
 
+    def test_dir_in_package_data(self):
+        """
+        A directory in package_data should not be added to the filelist.
+        """
+        # See bug 19286
+        sources = self.mkdtemp()
+        pkg_dir = os.path.join(sources, "pkg")
+
+        os.mkdir(pkg_dir)
+        open(os.path.join(pkg_dir, "__init__.py"), "w").close()
+
+        docdir = os.path.join(pkg_dir, "doc")
+        os.mkdir(docdir)
+        open(os.path.join(docdir, "testfile"), "w").close()
+
+        # create the directory that could be incorrectly detected as a file
+        os.mkdir(os.path.join(docdir, 'otherdir'))
+
+        os.chdir(sources)
+        dist = Distribution({"packages": ["pkg"],
+                             "package_data": {"pkg": ["doc/*"]}})
+        # script_name need not exist, it just need to be initialized
+        dist.script_name = os.path.join(sources, "setup.py")
+        dist.script_args = ["build"]
+        dist.parse_command_line()
+
+        try:
+            dist.run_commands()
+        except DistutilsFileError:
+            self.fail("failed package_data when data dir includes a dir")
+
     def test_dont_write_bytecode(self):
         # makes sure byte_compile is not used
         pkg_dir, dist = self.create_dist()
diff -r 3a1db0d2747e Lib/distutils/tests/test_build_scripts.py
--- a/Lib/distutils/tests/test_build_scripts.py
+++ b/Lib/distutils/tests/test_build_scripts.py
@@ -17,8 +17,8 @@
 
     def test_default_settings(self):
         cmd = self.get_build_scripts_cmd("/foo/bar", [])
-        self.assertTrue(not cmd.force)
-        self.assertTrue(cmd.build_dir is None)
+        self.assertFalse(cmd.force)
+        self.assertIsNone(cmd.build_dir)
 
         cmd.finalize_options()
 
@@ -38,7 +38,7 @@
 
         built = os.listdir(target)
         for name in expected:
-            self.assertTrue(name in built)
+            self.assertIn(name, built)
 
     def get_build_scripts_cmd(self, target, scripts):
         import sys
@@ -103,7 +103,7 @@
 
         built = os.listdir(target)
         for name in expected:
-            self.assertTrue(name in built)
+            self.assertIn(name, built)
 
 def test_suite():
     return unittest.makeSuite(BuildScriptsTestCase)
diff -r 3a1db0d2747e Lib/distutils/tests/test_ccompiler.py
--- a/Lib/distutils/tests/test_ccompiler.py
+++ b/Lib/distutils/tests/test_ccompiler.py
@@ -55,12 +55,9 @@
         finally:
             debug.DEBUG = False
 
+    @unittest.skipUnless(get_default_compiler() == 'unix',
+                         'not testing if default compiler is not unix')
     def test_customize_compiler(self):
-
-        # not testing if default compiler is not unix
-        if get_default_compiler() != 'unix':
-            return
-
         os.environ['AR'] = 'my_ar'
         os.environ['ARFLAGS'] = '-arflags'
 
diff -r 3a1db0d2747e Lib/distutils/tests/test_check.py
--- a/Lib/distutils/tests/test_check.py
+++ b/Lib/distutils/tests/test_check.py
@@ -56,9 +56,8 @@
         cmd = self._run(metadata)
         self.assertEqual(cmd._warnings, 0)
 
+    @unittest.skipUnless(HAS_DOCUTILS, "won't test without docutils")
     def test_check_document(self):
-        if not HAS_DOCUTILS: # won't test without docutils
-            return
         pkg_info, dist = self.create_dist()
         cmd = check(dist)
 
@@ -72,9 +71,8 @@
         msgs = cmd._check_rst_data(rest)
         self.assertEqual(len(msgs), 0)
 
+    @unittest.skipUnless(HAS_DOCUTILS, "won't test without docutils")
     def test_check_restructuredtext(self):
-        if not HAS_DOCUTILS: # won't test without docutils
-            return
         # let's see if it detects broken rest in long_description
         broken_rest = 'title\n===\n\ntest'
         pkg_info, dist = self.create_dist(long_description=broken_rest)
diff -r 3a1db0d2747e Lib/distutils/tests/test_clean.py
--- a/Lib/distutils/tests/test_clean.py
+++ b/Lib/distutils/tests/test_clean.py
@@ -36,7 +36,7 @@
 
         # make sure the files where removed
         for name, path in dirs:
-            self.assertTrue(not os.path.exists(path),
+            self.assertFalse(os.path.exists(path),
                          '%s was not removed' % path)
 
         # let's run the command again (should spit warnings but succeed)
diff -r 3a1db0d2747e Lib/distutils/tests/test_config.py
--- a/Lib/distutils/tests/test_config.py
+++ b/Lib/distutils/tests/test_config.py
@@ -89,7 +89,7 @@
         config = config.items()
         config.sort()
         waited = [('password', 'secret'), ('realm', 'pypi'),
-                  ('repository', 'http://pypi.python.org/pypi'),
+                  ('repository', 'https://pypi.python.org/pypi'),
                   ('server', 'server1'), ('username', 'me')]
         self.assertEqual(config, waited)
 
@@ -99,14 +99,14 @@
         config = config.items()
         config.sort()
         waited = [('password', 'secret'), ('realm', 'pypi'),
-                  ('repository', 'http://pypi.python.org/pypi'),
+                  ('repository', 'https://pypi.python.org/pypi'),
                   ('server', 'server-login'), ('username', 'tarek')]
         self.assertEqual(config, waited)
 
     def test_server_empty_registration(self):
         cmd = self._cmd(self.dist)
         rc = cmd._get_rc_file()
-        self.assertTrue(not os.path.exists(rc))
+        self.assertFalse(os.path.exists(rc))
         cmd._store_pypirc('tarek', 'xxx')
         self.assertTrue(os.path.exists(rc))
         f = open(rc)
diff -r 3a1db0d2747e Lib/distutils/tests/test_config_cmd.py
--- a/Lib/distutils/tests/test_config_cmd.py
+++ b/Lib/distutils/tests/test_config_cmd.py
@@ -37,9 +37,8 @@
         dump_file(this_file, 'I am the header')
         self.assertEqual(len(self._logs), numlines+1)
 
+    @unittest.skipIf(sys.platform == 'win32', "can't test on Windows")
     def test_search_cpp(self):
-        if sys.platform == 'win32':
-            return
         pkg_dir, dist = self.create_dist()
         cmd = config(dist)
 
@@ -81,7 +80,7 @@
         cmd._clean(f1, f2)
 
         for f in (f1, f2):
-            self.assertTrue(not os.path.exists(f))
+            self.assertFalse(os.path.exists(f))
 
 def test_suite():
     return unittest.makeSuite(ConfigTestCase)
diff -r 3a1db0d2747e Lib/distutils/tests/test_install.py
--- a/Lib/distutils/tests/test_install.py
+++ b/Lib/distutils/tests/test_install.py
@@ -65,11 +65,9 @@
         check_path(cmd.install_scripts, os.path.join(destination, "bin"))
         check_path(cmd.install_data, destination)
 
+    @unittest.skipIf(sys.version < '2.6',
+                     'site.USER_SITE was introduced in 2.6')
     def test_user_site(self):
-        # site.USER_SITE was introduced in 2.6
-        if sys.version < '2.6':
-            return
-
         # preparing the environment for the test
         self.old_user_base = site.USER_BASE
         self.old_user_site = site.USER_SITE
@@ -237,7 +235,7 @@
                 self.test_record()
         finally:
             install_module.DEBUG = False
-        self.assertTrue(len(self.logs) > old_logs_len)
+        self.assertGreater(len(self.logs), old_logs_len)
 
 
 def test_suite():
diff -r 3a1db0d2747e Lib/distutils/tests/test_install_lib.py
--- a/Lib/distutils/tests/test_install_lib.py
+++ b/Lib/distutils/tests/test_install_lib.py
@@ -65,7 +65,7 @@
         cmd.distribution.script_name = 'setup.py'
 
         # get_output should return 4 elements
-        self.assertTrue(len(cmd.get_outputs()) >= 2)
+        self.assertGreaterEqual(len(cmd.get_outputs()), 2)
 
     def test_get_inputs(self):
         pkg_dir, dist = self.create_dist()
@@ -98,7 +98,7 @@
         finally:
             sys.dont_write_bytecode = old_dont_write_bytecode
 
-        self.assertTrue('byte-compiling is disabled' in self.logs[0][1])
+        self.assertIn('byte-compiling is disabled', self.logs[0][1])
 
 def test_suite():
     return unittest.makeSuite(InstallLibTestCase)
diff -r 3a1db0d2747e Lib/distutils/tests/test_install_scripts.py
--- a/Lib/distutils/tests/test_install_scripts.py
+++ b/Lib/distutils/tests/test_install_scripts.py
@@ -24,10 +24,10 @@
             skip_build=1,
             )
         cmd = install_scripts(dist)
-        self.assertTrue(not cmd.force)
-        self.assertTrue(not cmd.skip_build)
-        self.assertTrue(cmd.build_dir is None)
-        self.assertTrue(cmd.install_dir is None)
+        self.assertFalse(cmd.force)
+        self.assertFalse(cmd.skip_build)
+        self.assertIsNone(cmd.build_dir)
+        self.assertIsNone(cmd.install_dir)
 
         cmd.finalize_options()
 
@@ -72,7 +72,7 @@
 
         installed = os.listdir(target)
         for name in expected:
-            self.assertTrue(name in installed)
+            self.assertIn(name, installed)
 
 
 def test_suite():
diff -r 3a1db0d2747e Lib/distutils/tests/test_msvc9compiler.py
--- a/Lib/distutils/tests/test_msvc9compiler.py
+++ b/Lib/distutils/tests/test_msvc9compiler.py
@@ -128,7 +128,7 @@
         # windows registeries versions.
         path = r'Control Panel\Desktop'
         v = Reg.get_value(path, u'dragfullwindows')
-        self.assertTrue(v in (u'0', u'1', u'2'))
+        self.assertIn(v, (u'0', u'1', u'2'))
 
         import _winreg
         HKCU = _winreg.HKEY_CURRENT_USER
@@ -136,7 +136,7 @@
         self.assertEqual(keys, None)
 
         keys = Reg.read_keys(HKCU, r'Control Panel')
-        self.assertTrue('Desktop' in keys)
+        self.assertIn('Desktop', keys)
 
     def test_remove_visual_c_ref(self):
         from distutils.msvc9compiler import MSVCCompiler
@@ -174,7 +174,7 @@
 
         compiler = MSVCCompiler()
         got = compiler._remove_visual_c_ref(manifest)
-        self.assertIs(got, None)
+        self.assertIsNone(got)
 
 
 def test_suite():
diff -r 3a1db0d2747e Lib/distutils/tests/test_register.py
--- a/Lib/distutils/tests/test_register.py
+++ b/Lib/distutils/tests/test_register.py
@@ -99,7 +99,7 @@
         cmd = self._get_cmd()
 
         # we shouldn't have a .pypirc file yet
-        self.assertTrue(not os.path.exists(self.rc))
+        self.assertFalse(os.path.exists(self.rc))
 
         # patching raw_input and getpass.getpass
         # so register gets happy
@@ -144,7 +144,7 @@
         req1 = dict(self.conn.reqs[0].headers)
         req2 = dict(self.conn.reqs[1].headers)
         self.assertEqual(req2['Content-length'], req1['Content-length'])
-        self.assertTrue('xxx' in self.conn.reqs[1].data)
+        self.assertIn('xxx', self.conn.reqs[1].data)
 
     def test_password_not_in_file(self):
 
@@ -174,7 +174,7 @@
         req = self.conn.reqs[0]
         headers = dict(req.headers)
         self.assertEqual(headers['Content-length'], '608')
-        self.assertTrue('tarek' in req.data)
+        self.assertIn('tarek', req.data)
 
     def test_password_reset(self):
         # this test runs choice 3
@@ -192,7 +192,7 @@
         req = self.conn.reqs[0]
         headers = dict(req.headers)
         self.assertEqual(headers['Content-length'], '290')
-        self.assertTrue('tarek' in req.data)
+        self.assertIn('tarek', req.data)
 
     @unittest.skipUnless(docutils is not None, 'needs docutils')
     def test_strict(self):
diff -r 3a1db0d2747e Lib/distutils/tests/test_sdist.py
--- a/Lib/distutils/tests/test_sdist.py
+++ b/Lib/distutils/tests/test_sdist.py
@@ -134,12 +134,6 @@
 
     @unittest.skipUnless(zlib, "requires zlib")
     def test_make_distribution(self):
-
-        # check if tar and gzip are installed
-        if (find_executable('tar') is None or
-            find_executable('gzip') is None):
-            return
-
         # now building a sdist
         dist, cmd = self.get_cmd()
 
@@ -325,13 +319,11 @@
 
     @unittest.skipUnless(zlib, "requires zlib")
     @unittest.skipUnless(UID_GID_SUPPORT, "Requires grp and pwd support")
+    @unittest.skipIf(find_executable('tar') is None,
+                     "The tar command is not found")
+    @unittest.skipIf(find_executable('gzip') is None,
+                     "The gzip command is not found")
     def test_make_distribution_owner_group(self):
-
-        # check if tar and gzip are installed
-        if (find_executable('tar') is None or
-            find_executable('gzip') is None):
-            return
-
         # now building a sdist
         dist, cmd = self.get_cmd()
 
diff -r 3a1db0d2747e Lib/distutils/tests/test_sysconfig.py
--- a/Lib/distutils/tests/test_sysconfig.py
+++ b/Lib/distutils/tests/test_sysconfig.py
@@ -95,7 +95,7 @@
 
         import sysconfig as global_sysconfig
         if sysconfig.get_config_var('CUSTOMIZED_OSX_COMPILER'):
-            return
+            self.skipTest('compiler flags customized')
         self.assertEqual(global_sysconfig.get_config_var('LDSHARED'), sysconfig.get_config_var('LDSHARED'))
         self.assertEqual(global_sysconfig.get_config_var('CC'), sysconfig.get_config_var('CC'))
 
diff -r 3a1db0d2747e Lib/distutils/tests/test_unixccompiler.py
--- a/Lib/distutils/tests/test_unixccompiler.py
+++ b/Lib/distutils/tests/test_unixccompiler.py
@@ -21,12 +21,8 @@
         sys.platform = self._backup_platform
         sysconfig.get_config_var = self._backup_get_config_var
 
+    @unittest.skipIf(sys.platform == 'win32', "can't test on Windows")
     def test_runtime_libdir_option(self):
-
-        # not tested under windows
-        if sys.platform == 'win32':
-            return
-
         # Issue#5900
         #
         # Ensure RUNPATH is added to extension modules with RPATH if
diff -r 3a1db0d2747e Lib/distutils/tests/test_upload.py
--- a/Lib/distutils/tests/test_upload.py
+++ b/Lib/distutils/tests/test_upload.py
@@ -78,7 +78,7 @@
         cmd.finalize_options()
         for attr, waited in (('username', 'me'), ('password', 'secret'),
                              ('realm', 'pypi'),
-                             ('repository', 'http://pypi.python.org/pypi')):
+                             ('repository', 'https://pypi.python.org/pypi')):
             self.assertEqual(getattr(cmd, attr), waited)
 
     def test_saved_password(self):
@@ -119,10 +119,10 @@
         self.assertTrue(headers['Content-type'].startswith('multipart/form-data'))
         self.assertEqual(self.last_open.req.get_method(), 'POST')
         self.assertEqual(self.last_open.req.get_full_url(),
-                         'http://pypi.python.org/pypi')
-        self.assertTrue('xxx' in self.last_open.req.data)
+                         'https://pypi.python.org/pypi')
+        self.assertIn('xxx', self.last_open.req.data)
         auth = self.last_open.req.headers['Authorization']
-        self.assertFalse('\n' in auth)
+        self.assertNotIn('\n', auth)
 
 def test_suite():
     return unittest.makeSuite(uploadTestCase)
diff -r 3a1db0d2747e Lib/doctest.py
--- a/Lib/doctest.py
+++ b/Lib/doctest.py
@@ -326,6 +326,32 @@
     else:
         return '#'
 
+def _strip_exception_details(msg):
+    # Support for IGNORE_EXCEPTION_DETAIL.
+    # Get rid of everything except the exception name; in particular, drop
+    # the possibly dotted module path (if any) and the exception message (if
+    # any).  We assume that a colon is never part of a dotted name, or of an
+    # exception name.
+    # E.g., given
+    #    "foo.bar.MyError: la di da"
+    # return "MyError"
+    # Or for "abc.def" or "abc.def:\n" return "def".
+
+    start, end = 0, len(msg)
+    # The exception name must appear on the first line.
+    i = msg.find("\n")
+    if i >= 0:
+        end = i
+    # retain up to the first colon (if any)
+    i = msg.find(':', 0, end)
+    if i >= 0:
+        end = i
+    # retain just the exception name
+    i = msg.rfind('.', 0, end)
+    if i >= 0:
+        start = i+1
+    return msg[start: end]
+
 class _OutputRedirectingPdb(pdb.Pdb):
     """
     A specialized version of the python debugger that redirects stdout
@@ -1323,10 +1349,9 @@
 
                 # Another chance if they didn't care about the detail.
                 elif self.optionflags & IGNORE_EXCEPTION_DETAIL:
-                    m1 = re.match(r'(?:[^:]*\.)?([^:]*:)', example.exc_msg)
-                    m2 = re.match(r'(?:[^:]*\.)?([^:]*:)', exc_msg)
-                    if m1 and m2 and check(m1.group(1), m2.group(1),
-                                           self.optionflags):
+                    if check(_strip_exception_details(example.exc_msg),
+                             _strip_exception_details(exc_msg),
+                             self.optionflags):
                         outcome = SUCCESS
 
             # Report the outcome.
diff -r 3a1db0d2747e Lib/email/test/test_email.py
--- a/Lib/email/test/test_email.py
+++ b/Lib/email/test/test_email.py
@@ -267,12 +267,12 @@
         msg['From'] = 'Me'
         msg['to'] = 'You'
         # Check for case insensitivity
-        self.assertTrue('from' in msg)
-        self.assertTrue('From' in msg)
-        self.assertTrue('FROM' in msg)
-        self.assertTrue('to' in msg)
-        self.assertTrue('To' in msg)
-        self.assertTrue('TO' in msg)
+        self.assertIn('from', msg)
+        self.assertIn('From', msg)
+        self.assertIn('FROM', msg)
+        self.assertIn('to', msg)
+        self.assertIn('To', msg)
+        self.assertIn('TO', msg)
 
     def test_as_string(self):
         eq = self.assertEqual
@@ -1002,7 +1002,6 @@
 
     def test_add_header(self):
         eq = self.assertEqual
-        unless = self.assertTrue
         self._au.add_header('Content-Disposition', 'attachment',
                             filename='audiotest.au')
         eq(self._au['content-disposition'],
@@ -1013,12 +1012,12 @@
            'audiotest.au')
         missing = []
         eq(self._au.get_param('attachment', header='content-disposition'), '')
-        unless(self._au.get_param('foo', failobj=missing,
-                                  header='content-disposition') is missing)
+        self.assertIs(self._au.get_param('foo', failobj=missing,
+                                         header='content-disposition'), missing)
         # Try some missing stuff
-        unless(self._au.get_param('foobar', missing) is missing)
-        unless(self._au.get_param('attachment', missing,
-                                  header='foobar') is missing)
+        self.assertIs(self._au.get_param('foobar', missing), missing)
+        self.assertIs(self._au.get_param('attachment', missing,
+                                         header='foobar'), missing)
 
 
 
@@ -1045,7 +1044,6 @@
 
     def test_add_header(self):
         eq = self.assertEqual
-        unless = self.assertTrue
         self._im.add_header('Content-Disposition', 'attachment',
                             filename='dingusfish.gif')
         eq(self._im['content-disposition'],
@@ -1056,12 +1054,12 @@
            'dingusfish.gif')
         missing = []
         eq(self._im.get_param('attachment', header='content-disposition'), '')
-        unless(self._im.get_param('foo', failobj=missing,
-                                  header='content-disposition') is missing)
+        self.assertIs(self._im.get_param('foo', failobj=missing,
+                                         header='content-disposition'), missing)
         # Try some missing stuff
-        unless(self._im.get_param('foobar', missing) is missing)
-        unless(self._im.get_param('attachment', missing,
-                                  header='foobar') is missing)
+        self.assertIs(self._im.get_param('foobar', missing), missing)
+        self.assertIs(self._im.get_param('attachment', missing,
+                                         header='foobar'), missing)
 
 
 
@@ -1072,17 +1070,16 @@
 
     def test_types(self):
         eq = self.assertEqual
-        unless = self.assertTrue
         eq(self._msg.get_content_type(), 'text/plain')
         eq(self._msg.get_param('charset'), 'us-ascii')
         missing = []
-        unless(self._msg.get_param('foobar', missing) is missing)
-        unless(self._msg.get_param('charset', missing, header='foobar')
-               is missing)
+        self.assertIs(self._msg.get_param('foobar', missing), missing)
+        self.assertIs(self._msg.get_param('charset', missing, header='foobar'),
+                      missing)
 
     def test_payload(self):
         self.assertEqual(self._msg.get_payload(), 'hello there')
-        self.assertTrue(not self._msg.is_multipart())
+        self.assertFalse(self._msg.is_multipart())
 
     def test_charset(self):
         eq = self.assertEqual
@@ -1101,7 +1098,7 @@
         msg = MIMEText(u'hello there')
         eq(msg.get_charset(), 'us-ascii')
         eq(msg['content-type'], 'text/plain; charset="us-ascii"')
-        self.assertTrue('hello there' in msg.as_string())
+        self.assertIn('hello there', msg.as_string())
 
     def test_8bit_unicode_input(self):
         teststr = u'\u043a\u0438\u0440\u0438\u043b\u0438\u0446\u0430'
@@ -1162,21 +1159,20 @@
     def test_hierarchy(self):
         # convenience
         eq = self.assertEqual
-        unless = self.assertTrue
         raises = self.assertRaises
         # tests
         m = self._msg
-        unless(m.is_multipart())
+        self.assertTrue(m.is_multipart())
         eq(m.get_content_type(), 'multipart/mixed')
         eq(len(m.get_payload()), 2)
         raises(IndexError, m.get_payload, 2)
         m0 = m.get_payload(0)
         m1 = m.get_payload(1)
-        unless(m0 is self._txt)
-        unless(m1 is self._im)
+        self.assertIs(m0, self._txt)
+        self.assertIs(m1, self._im)
         eq(m.get_payload(), [m0, m1])
-        unless(not m0.is_multipart())
-        unless(not m1.is_multipart())
+        self.assertFalse(m0.is_multipart())
+        self.assertFalse(m1.is_multipart())
 
     def test_empty_multipart_idempotent(self):
         text = """\
@@ -1506,23 +1502,22 @@
         eq(msg.get_content_subtype(), 'plain')
 
     def test_same_boundary_inner_outer(self):
-        unless = self.assertTrue
         msg = self._msgobj('msg_15.txt')
         # XXX We can probably eventually do better
         inner = msg.get_payload(0)
-        unless(hasattr(inner, 'defects'))
+        self.assertTrue(hasattr(inner, 'defects'))
         self.assertEqual(len(inner.defects), 1)
-        unless(isinstance(inner.defects[0],
-                          Errors.StartBoundaryNotFoundDefect))
+        self.assertIsInstance(inner.defects[0],
+                              Errors.StartBoundaryNotFoundDefect)
 
     def test_multipart_no_boundary(self):
-        unless = self.assertTrue
         msg = self._msgobj('msg_25.txt')
-        unless(isinstance(msg.get_payload(), str))
+        self.assertIsInstance(msg.get_payload(), str)
         self.assertEqual(len(msg.defects), 2)
-        unless(isinstance(msg.defects[0], Errors.NoBoundaryInMultipartDefect))
-        unless(isinstance(msg.defects[1],
-                          Errors.MultipartInvariantViolationDefect))
+        self.assertIsInstance(msg.defects[0],
+                              Errors.NoBoundaryInMultipartDefect)
+        self.assertIsInstance(msg.defects[1],
+                              Errors.MultipartInvariantViolationDefect)
 
     def test_invalid_content_type(self):
         eq = self.assertEqual
@@ -1574,13 +1569,13 @@
 """)
 
     def test_lying_multipart(self):
-        unless = self.assertTrue
         msg = self._msgobj('msg_41.txt')
-        unless(hasattr(msg, 'defects'))
+        self.assertTrue(hasattr(msg, 'defects'))
         self.assertEqual(len(msg.defects), 2)
-        unless(isinstance(msg.defects[0], Errors.NoBoundaryInMultipartDefect))
-        unless(isinstance(msg.defects[1],
-                          Errors.MultipartInvariantViolationDefect))
+        self.assertIsInstance(msg.defects[0],
+                              Errors.NoBoundaryInMultipartDefect)
+        self.assertIsInstance(msg.defects[1],
+                              Errors.MultipartInvariantViolationDefect)
 
     def test_missing_start_boundary(self):
         outer = self._msgobj('msg_42.txt')
@@ -1594,8 +1589,8 @@
         # [*] This message is missing its start boundary
         bad = outer.get_payload(1).get_payload(0)
         self.assertEqual(len(bad.defects), 1)
-        self.assertTrue(isinstance(bad.defects[0],
-                                   Errors.StartBoundaryNotFoundDefect))
+        self.assertIsInstance(bad.defects[0],
+                              Errors.StartBoundaryNotFoundDefect)
 
     def test_first_line_is_continuation_header(self):
         eq = self.assertEqual
@@ -1604,8 +1599,8 @@
         eq(msg.keys(), [])
         eq(msg.get_payload(), 'Line 2\nLine 3')
         eq(len(msg.defects), 1)
-        self.assertTrue(isinstance(msg.defects[0],
-                                   Errors.FirstHeaderLineIsContinuationDefect))
+        self.assertIsInstance(msg.defects[0],
+                              Errors.FirstHeaderLineIsContinuationDefect)
         eq(msg.defects[0].line, ' Line 1\n')
 
 
@@ -1687,17 +1682,16 @@
 
     def test_valid_argument(self):
         eq = self.assertEqual
-        unless = self.assertTrue
         subject = 'A sub-message'
         m = Message()
         m['Subject'] = subject
         r = MIMEMessage(m)
         eq(r.get_content_type(), 'message/rfc822')
         payload = r.get_payload()
-        unless(isinstance(payload, list))
+        self.assertIsInstance(payload, list)
         eq(len(payload), 1)
         subpart = payload[0]
-        unless(subpart is m)
+        self.assertIs(subpart, m)
         eq(subpart['subject'], subject)
 
     def test_bad_multipart(self):
@@ -1731,24 +1725,22 @@
 
     def test_parse_message_rfc822(self):
         eq = self.assertEqual
-        unless = self.assertTrue
         msg = self._msgobj('msg_11.txt')
         eq(msg.get_content_type(), 'message/rfc822')
         payload = msg.get_payload()
-        unless(isinstance(payload, list))
+        self.assertIsInstance(payload, list)
         eq(len(payload), 1)
         submsg = payload[0]
-        self.assertTrue(isinstance(submsg, Message))
+        self.assertIsInstance(submsg, Message)
         eq(submsg['subject'], 'An enclosed message')
         eq(submsg.get_payload(), 'Here is the body of the message.\n')
 
     def test_dsn(self):
         eq = self.assertEqual
-        unless = self.assertTrue
         # msg 16 is a Delivery Status Notification, see RFC 1894
         msg = self._msgobj('msg_16.txt')
         eq(msg.get_content_type(), 'multipart/report')
-        unless(msg.is_multipart())
+        self.assertTrue(msg.is_multipart())
         eq(len(msg.get_payload()), 3)
         # Subpart 1 is a text/plain, human readable section
         subpart = msg.get_payload(0)
@@ -1777,13 +1769,13 @@
         # message/delivery-status should treat each block as a bunch of
         # headers, i.e. a bunch of Message objects.
         dsn1 = subpart.get_payload(0)
-        unless(isinstance(dsn1, Message))
+        self.assertIsInstance(dsn1, Message)
         eq(dsn1['original-envelope-id'], '0GK500B4HD0888@cougar.noc.ucla.edu')
         eq(dsn1.get_param('dns', header='reporting-mta'), '')
         # Try a missing one <wink>
         eq(dsn1.get_param('nsd', header='reporting-mta'), None)
         dsn2 = subpart.get_payload(1)
-        unless(isinstance(dsn2, Message))
+        self.assertIsInstance(dsn2, Message)
         eq(dsn2['action'], 'failed')
         eq(dsn2.get_params(header='original-recipient'),
            [('rfc822', ''), ('jangel1@cougar.noc.ucla.edu', '')])
@@ -1792,10 +1784,10 @@
         subpart = msg.get_payload(2)
         eq(subpart.get_content_type(), 'message/rfc822')
         payload = subpart.get_payload()
-        unless(isinstance(payload, list))
+        self.assertIsInstance(payload, list)
         eq(len(payload), 1)
         subsubpart = payload[0]
-        unless(isinstance(subsubpart, Message))
+        self.assertIsInstance(subsubpart, Message)
         eq(subsubpart.get_content_type(), 'text/plain')
         eq(subsubpart['message-id'],
            '<002001c144a6$8752e060$56104586@oxy.edu>')
@@ -2094,7 +2086,6 @@
 
     def test_content_type(self):
         eq = self.assertEqual
-        unless = self.assertTrue
         # Get a message object and reset the seek pointer for other tests
         msg, text = self._msgobj('msg_05.txt')
         eq(msg.get_content_type(), 'multipart/report')
@@ -2116,29 +2107,28 @@
         eq(msg2.get_payload(), 'Yadda yadda yadda\n')
         msg3 = msg.get_payload(2)
         eq(msg3.get_content_type(), 'message/rfc822')
-        self.assertTrue(isinstance(msg3, Message))
+        self.assertIsInstance(msg3, Message)
         payload = msg3.get_payload()
-        unless(isinstance(payload, list))
+        self.assertIsInstance(payload, list)
         eq(len(payload), 1)
         msg4 = payload[0]
-        unless(isinstance(msg4, Message))
+        self.assertIsInstance(msg4, Message)
         eq(msg4.get_payload(), 'Yadda yadda yadda\n')
 
     def test_parser(self):
         eq = self.assertEqual
-        unless = self.assertTrue
         msg, text = self._msgobj('msg_06.txt')
         # Check some of the outer headers
         eq(msg.get_content_type(), 'message/rfc822')
         # Make sure the payload is a list of exactly one sub-Message, and that
         # that submessage has a type of text/plain
         payload = msg.get_payload()
-        unless(isinstance(payload, list))
+        self.assertIsInstance(payload, list)
         eq(len(payload), 1)
         msg1 = payload[0]
-        self.assertTrue(isinstance(msg1, Message))
+        self.assertIsInstance(msg1, Message)
         eq(msg1.get_content_type(), 'text/plain')
-        self.assertTrue(isinstance(msg1.get_payload(), str))
+        self.assertIsInstance(msg1.get_payload(), str)
         eq(msg1.get_payload(), '\n')
 
 
@@ -2175,7 +2165,6 @@
             fp.close()
 
     def test_message_from_string_with_class(self):
-        unless = self.assertTrue
         fp = openfile('msg_01.txt')
         try:
             text = fp.read()
@@ -2186,7 +2175,7 @@
             pass
 
         msg = email.message_from_string(text, MyMessage)
-        unless(isinstance(msg, MyMessage))
+        self.assertIsInstance(msg, MyMessage)
         # Try something more complicated
         fp = openfile('msg_02.txt')
         try:
@@ -2195,10 +2184,9 @@
             fp.close()
         msg = email.message_from_string(text, MyMessage)
         for subpart in msg.walk():
-            unless(isinstance(subpart, MyMessage))
+            self.assertIsInstance(subpart, MyMessage)
 
     def test_message_from_file_with_class(self):
-        unless = self.assertTrue
         # Create a subclass
         class MyMessage(Message):
             pass
@@ -2208,7 +2196,7 @@
             msg = email.message_from_file(fp, MyMessage)
         finally:
             fp.close()
-        unless(isinstance(msg, MyMessage))
+        self.assertIsInstance(msg, MyMessage)
         # Try something more complicated
         fp = openfile('msg_02.txt')
         try:
@@ -2216,7 +2204,7 @@
         finally:
             fp.close()
         for subpart in msg.walk():
-            unless(isinstance(subpart, MyMessage))
+            self.assertIsInstance(subpart, MyMessage)
 
     def test__all__(self):
         module = __import__('email')
@@ -2591,9 +2579,9 @@
                     break
                 om.append(ol)
                 n1 += 1
-            self.assertTrue(n == n1)
-        self.assertTrue(len(om) == nt)
-        self.assertTrue(''.join([il for il, n in imt]) == ''.join(om))
+            self.assertEqual(n, n1)
+        self.assertEqual(len(om), nt)
+        self.assertEqual(''.join([il for il, n in imt]), ''.join(om))
 
 
 
@@ -2610,7 +2598,7 @@
         eq(msg['to'], 'ppp@zzz.org')
         eq(msg.get_content_type(), 'multipart/mixed')
         self.assertFalse(msg.is_multipart())
-        self.assertTrue(isinstance(msg.get_payload(), str))
+        self.assertIsInstance(msg.get_payload(), str)
 
     def test_whitespace_continuation(self):
         eq = self.assertEqual
@@ -3027,7 +3015,7 @@
         h = Header("I am the very model of a modern Major-General; I've information vegetable, animal, and mineral; I know the kings of England, and I quote the fights historical from Marathon to Waterloo, in order categorical; I'm very well acquainted, too, with matters mathematical; I understand equations, both the simple and quadratical; about binomial theorem I'm teeming with a lot o' news, with many cheerful facts about the square of the hypotenuse.",
                    maxlinelen=76)
         for l in h.encode(splitchars=' ').split('\n '):
-            self.assertTrue(len(l) <= 76)
+            self.assertLessEqual(len(l), 76)
 
     def test_multilingual(self):
         eq = self.ndiffAssertEqual
@@ -3279,7 +3267,7 @@
 '''
         msg = email.message_from_string(m)
         param = msg.get_param('NAME')
-        self.assertFalse(isinstance(param, tuple))
+        self.assertNotIsInstance(param, tuple)
         self.assertEqual(
             param,
             'file____C__DOCUMENTS_20AND_20SETTINGS_FABIEN_LOCAL_20SETTINGS_TEMP_nsmail.htm')
@@ -3432,7 +3420,7 @@
 """
         msg = email.message_from_string(m)
         param = msg.get_param('name')
-        self.assertFalse(isinstance(param, tuple))
+        self.assertNotIsInstance(param, tuple)
         self.assertEqual(param, "Frank's Document")
 
     def test_rfc2231_tick_attack_extended(self):
@@ -3456,7 +3444,7 @@
 """
         msg = email.message_from_string(m)
         param = msg.get_param('name')
-        self.assertFalse(isinstance(param, tuple))
+        self.assertNotIsInstance(param, tuple)
         self.assertEqual(param, "us-ascii'en-us'Frank's Document")
 
     def test_rfc2231_no_extended_values(self):
diff -r 3a1db0d2747e Lib/email/test/test_email_renamed.py
--- a/Lib/email/test/test_email_renamed.py
+++ b/Lib/email/test/test_email_renamed.py
@@ -231,12 +231,12 @@
         msg['From'] = 'Me'
         msg['to'] = 'You'
         # Check for case insensitivity
-        self.assertTrue('from' in msg)
-        self.assertTrue('From' in msg)
-        self.assertTrue('FROM' in msg)
-        self.assertTrue('to' in msg)
-        self.assertTrue('To' in msg)
-        self.assertTrue('TO' in msg)
+        self.assertIn('from', msg)
+        self.assertIn('From', msg)
+        self.assertIn('FROM', msg)
+        self.assertIn('to', msg)
+        self.assertIn('To', msg)
+        self.assertIn('TO', msg)
 
     def test_as_string(self):
         eq = self.assertEqual
@@ -916,7 +916,6 @@
 
     def test_add_header(self):
         eq = self.assertEqual
-        unless = self.assertTrue
         self._au.add_header('Content-Disposition', 'attachment',
                             filename='audiotest.au')
         eq(self._au['content-disposition'],
@@ -927,12 +926,13 @@
            'audiotest.au')
         missing = []
         eq(self._au.get_param('attachment', header='content-disposition'), '')
-        unless(self._au.get_param('foo', failobj=missing,
-                                  header='content-disposition') is missing)
+        self.assertIs(self._au.get_param('foo', failobj=missing,
+                                         header='content-disposition'),
+                      missing)
         # Try some missing stuff
-        unless(self._au.get_param('foobar', missing) is missing)
-        unless(self._au.get_param('attachment', missing,
-                                  header='foobar') is missing)
+        self.assertIs(self._au.get_param('foobar', missing), missing)
+        self.assertIs(self._au.get_param('attachment', missing,
+                                         header='foobar'), missing)
 
 
 
@@ -959,7 +959,6 @@
 
     def test_add_header(self):
         eq = self.assertEqual
-        unless = self.assertTrue
         self._im.add_header('Content-Disposition', 'attachment',
                             filename='dingusfish.gif')
         eq(self._im['content-disposition'],
@@ -970,12 +969,13 @@
            'dingusfish.gif')
         missing = []
         eq(self._im.get_param('attachment', header='content-disposition'), '')
-        unless(self._im.get_param('foo', failobj=missing,
-                                  header='content-disposition') is missing)
+        self.assertIs(self._im.get_param('foo', failobj=missing,
+                                         header='content-disposition'),
+                      missing)
         # Try some missing stuff
-        unless(self._im.get_param('foobar', missing) is missing)
-        unless(self._im.get_param('attachment', missing,
-                                  header='foobar') is missing)
+        self.assertIs(self._im.get_param('foobar', missing), missing)
+        self.assertIs(self._im.get_param('attachment', missing,
+                                         header='foobar'), missing)
 
 
 
@@ -1035,17 +1035,16 @@
 
     def test_types(self):
         eq = self.assertEqual
-        unless = self.assertTrue
         eq(self._msg.get_content_type(), 'text/plain')
         eq(self._msg.get_param('charset'), 'us-ascii')
         missing = []
-        unless(self._msg.get_param('foobar', missing) is missing)
-        unless(self._msg.get_param('charset', missing, header='foobar')
-               is missing)
+        self.assertIs(self._msg.get_param('foobar', missing), missing)
+        self.assertIs(self._msg.get_param('charset', missing, header='foobar'),
+                      missing)
 
     def test_payload(self):
         self.assertEqual(self._msg.get_payload(), 'hello there')
-        self.assertTrue(not self._msg.is_multipart())
+        self.assertFalse(self._msg.is_multipart())
 
     def test_charset(self):
         eq = self.assertEqual
@@ -1100,21 +1099,20 @@
     def test_hierarchy(self):
         # convenience
         eq = self.assertEqual
-        unless = self.assertTrue
         raises = self.assertRaises
         # tests
         m = self._msg
-        unless(m.is_multipart())
+        self.assertTrue(m.is_multipart())
         eq(m.get_content_type(), 'multipart/mixed')
         eq(len(m.get_payload()), 2)
         raises(IndexError, m.get_payload, 2)
         m0 = m.get_payload(0)
         m1 = m.get_payload(1)
-        unless(m0 is self._txt)
-        unless(m1 is self._im)
+        self.assertIs(m0, self._txt)
+        self.assertIs(m1, self._im)
         eq(m.get_payload(), [m0, m1])
-        unless(not m0.is_multipart())
-        unless(not m1.is_multipart())
+        self.assertFalse(m0.is_multipart())
+        self.assertFalse(m1.is_multipart())
 
     def test_empty_multipart_idempotent(self):
         text = """\
@@ -1444,23 +1442,22 @@
         eq(msg.get_content_subtype(), 'plain')
 
     def test_same_boundary_inner_outer(self):
-        unless = self.assertTrue
         msg = self._msgobj('msg_15.txt')
         # XXX We can probably eventually do better
         inner = msg.get_payload(0)
-        unless(hasattr(inner, 'defects'))
+        self.assertTrue(hasattr(inner, 'defects'))
         self.assertEqual(len(inner.defects), 1)
-        unless(isinstance(inner.defects[0],
-                          errors.StartBoundaryNotFoundDefect))
+        self.assertIsInstance(inner.defects[0],
+                              errors.StartBoundaryNotFoundDefect)
 
     def test_multipart_no_boundary(self):
-        unless = self.assertTrue
         msg = self._msgobj('msg_25.txt')
-        unless(isinstance(msg.get_payload(), str))
+        self.assertIsInstance(msg.get_payload(), str)
         self.assertEqual(len(msg.defects), 2)
-        unless(isinstance(msg.defects[0], errors.NoBoundaryInMultipartDefect))
-        unless(isinstance(msg.defects[1],
-                          errors.MultipartInvariantViolationDefect))
+        self.assertIsInstance(msg.defects[0],
+                              errors.NoBoundaryInMultipartDefect)
+        self.assertIsInstance(msg.defects[1],
+                              errors.MultipartInvariantViolationDefect)
 
     def test_invalid_content_type(self):
         eq = self.assertEqual
@@ -1512,13 +1509,13 @@
 """)
 
     def test_lying_multipart(self):
-        unless = self.assertTrue
         msg = self._msgobj('msg_41.txt')
-        unless(hasattr(msg, 'defects'))
+        self.assertTrue(hasattr(msg, 'defects'))
         self.assertEqual(len(msg.defects), 2)
-        unless(isinstance(msg.defects[0], errors.NoBoundaryInMultipartDefect))
-        unless(isinstance(msg.defects[1],
-                          errors.MultipartInvariantViolationDefect))
+        self.assertIsInstance(msg.defects[0],
+                              errors.NoBoundaryInMultipartDefect)
+        self.assertIsInstance(msg.defects[1],
+                              errors.MultipartInvariantViolationDefect)
 
     def test_missing_start_boundary(self):
         outer = self._msgobj('msg_42.txt')
@@ -1532,8 +1529,8 @@
         # [*] This message is missing its start boundary
         bad = outer.get_payload(1).get_payload(0)
         self.assertEqual(len(bad.defects), 1)
-        self.assertTrue(isinstance(bad.defects[0],
-                                   errors.StartBoundaryNotFoundDefect))
+        self.assertIsInstance(bad.defects[0],
+                              errors.StartBoundaryNotFoundDefect)
 
     def test_first_line_is_continuation_header(self):
         eq = self.assertEqual
@@ -1542,8 +1539,8 @@
         eq(msg.keys(), [])
         eq(msg.get_payload(), 'Line 2\nLine 3')
         eq(len(msg.defects), 1)
-        self.assertTrue(isinstance(msg.defects[0],
-                                   errors.FirstHeaderLineIsContinuationDefect))
+        self.assertIsInstance(msg.defects[0],
+                              errors.FirstHeaderLineIsContinuationDefect)
         eq(msg.defects[0].line, ' Line 1\n')
 
 
@@ -1609,17 +1606,16 @@
 
     def test_valid_argument(self):
         eq = self.assertEqual
-        unless = self.assertTrue
         subject = 'A sub-message'
         m = Message()
         m['Subject'] = subject
         r = MIMEMessage(m)
         eq(r.get_content_type(), 'message/rfc822')
         payload = r.get_payload()
-        unless(isinstance(payload, list))
+        self.assertIsInstance(payload, list)
         eq(len(payload), 1)
         subpart = payload[0]
-        unless(subpart is m)
+        self.assertIs(subpart, m)
         eq(subpart['subject'], subject)
 
     def test_bad_multipart(self):
@@ -1653,24 +1649,22 @@
 
     def test_parse_message_rfc822(self):
         eq = self.assertEqual
-        unless = self.assertTrue
         msg = self._msgobj('msg_11.txt')
         eq(msg.get_content_type(), 'message/rfc822')
         payload = msg.get_payload()
-        unless(isinstance(payload, list))
+        self.assertIsInstance(payload, list)
         eq(len(payload), 1)
         submsg = payload[0]
-        self.assertTrue(isinstance(submsg, Message))
+        self.assertIsInstance(submsg, Message)
         eq(submsg['subject'], 'An enclosed message')
         eq(submsg.get_payload(), 'Here is the body of the message.\n')
 
     def test_dsn(self):
         eq = self.assertEqual
-        unless = self.assertTrue
         # msg 16 is a Delivery Status Notification, see RFC 1894
         msg = self._msgobj('msg_16.txt')
         eq(msg.get_content_type(), 'multipart/report')
-        unless(msg.is_multipart())
+        self.assertTrue(msg.is_multipart())
         eq(len(msg.get_payload()), 3)
         # Subpart 1 is a text/plain, human readable section
         subpart = msg.get_payload(0)
@@ -1699,13 +1693,13 @@
         # message/delivery-status should treat each block as a bunch of
         # headers, i.e. a bunch of Message objects.
         dsn1 = subpart.get_payload(0)
-        unless(isinstance(dsn1, Message))
+        self.assertIsInstance(dsn1, Message)
         eq(dsn1['original-envelope-id'], '0GK500B4HD0888@cougar.noc.ucla.edu')
         eq(dsn1.get_param('dns', header='reporting-mta'), '')
         # Try a missing one <wink>
         eq(dsn1.get_param('nsd', header='reporting-mta'), None)
         dsn2 = subpart.get_payload(1)
-        unless(isinstance(dsn2, Message))
+        self.assertIsInstance(dsn2, Message)
         eq(dsn2['action'], 'failed')
         eq(dsn2.get_params(header='original-recipient'),
            [('rfc822', ''), ('jangel1@cougar.noc.ucla.edu', '')])
@@ -1714,10 +1708,10 @@
         subpart = msg.get_payload(2)
         eq(subpart.get_content_type(), 'message/rfc822')
         payload = subpart.get_payload()
-        unless(isinstance(payload, list))
+        self.assertIsInstance(payload, list)
         eq(len(payload), 1)
         subsubpart = payload[0]
-        unless(isinstance(subsubpart, Message))
+        self.assertIsInstance(subsubpart, Message)
         eq(subsubpart.get_content_type(), 'text/plain')
         eq(subsubpart['message-id'],
            '<002001c144a6$8752e060$56104586@oxy.edu>')
@@ -2013,7 +2007,6 @@
 
     def test_content_type(self):
         eq = self.assertEqual
-        unless = self.assertTrue
         # Get a message object and reset the seek pointer for other tests
         msg, text = self._msgobj('msg_05.txt')
         eq(msg.get_content_type(), 'multipart/report')
@@ -2035,29 +2028,28 @@
         eq(msg2.get_payload(), 'Yadda yadda yadda\n')
         msg3 = msg.get_payload(2)
         eq(msg3.get_content_type(), 'message/rfc822')
-        self.assertTrue(isinstance(msg3, Message))
+        self.assertIsInstance(msg3, Message)
         payload = msg3.get_payload()
-        unless(isinstance(payload, list))
+        self.assertIsInstance(payload, list)
         eq(len(payload), 1)
         msg4 = payload[0]
-        unless(isinstance(msg4, Message))
+        self.assertIsInstance(msg4, Message)
         eq(msg4.get_payload(), 'Yadda yadda yadda\n')
 
     def test_parser(self):
         eq = self.assertEqual
-        unless = self.assertTrue
         msg, text = self._msgobj('msg_06.txt')
         # Check some of the outer headers
         eq(msg.get_content_type(), 'message/rfc822')
         # Make sure the payload is a list of exactly one sub-Message, and that
         # that submessage has a type of text/plain
         payload = msg.get_payload()
-        unless(isinstance(payload, list))
+        self.assertIsInstance(payload, list)
         eq(len(payload), 1)
         msg1 = payload[0]
-        self.assertTrue(isinstance(msg1, Message))
+        self.assertIsInstance(msg1, Message)
         eq(msg1.get_content_type(), 'text/plain')
-        self.assertTrue(isinstance(msg1.get_payload(), str))
+        self.assertIsInstance(msg1.get_payload(), str)
         eq(msg1.get_payload(), '\n')
 
 
@@ -2094,7 +2086,6 @@
             fp.close()
 
     def test_message_from_string_with_class(self):
-        unless = self.assertTrue
         fp = openfile('msg_01.txt')
         try:
             text = fp.read()
@@ -2105,7 +2096,7 @@
             pass
 
         msg = email.message_from_string(text, MyMessage)
-        unless(isinstance(msg, MyMessage))
+        self.assertIsInstance(msg, MyMessage)
         # Try something more complicated
         fp = openfile('msg_02.txt')
         try:
@@ -2114,10 +2105,9 @@
             fp.close()
         msg = email.message_from_string(text, MyMessage)
         for subpart in msg.walk():
-            unless(isinstance(subpart, MyMessage))
+            self.assertIsInstance(subpart, MyMessage)
 
     def test_message_from_file_with_class(self):
-        unless = self.assertTrue
         # Create a subclass
         class MyMessage(Message):
             pass
@@ -2127,7 +2117,7 @@
             msg = email.message_from_file(fp, MyMessage)
         finally:
             fp.close()
-        unless(isinstance(msg, MyMessage))
+        self.assertIsInstance(msg, MyMessage)
         # Try something more complicated
         fp = openfile('msg_02.txt')
         try:
@@ -2135,7 +2125,7 @@
         finally:
             fp.close()
         for subpart in msg.walk():
-            unless(isinstance(subpart, MyMessage))
+            self.assertIsInstance(subpart, MyMessage)
 
     def test__all__(self):
         module = __import__('email')
@@ -2460,7 +2450,7 @@
         eq(msg['to'], 'ppp@zzz.org')
         eq(msg.get_content_type(), 'multipart/mixed')
         self.assertFalse(msg.is_multipart())
-        self.assertTrue(isinstance(msg.get_payload(), str))
+        self.assertIsInstance(msg.get_payload(), str)
 
     def test_whitespace_continuation(self):
         eq = self.assertEqual
@@ -2856,7 +2846,7 @@
         h = Header("I am the very model of a modern Major-General; I've information vegetable, animal, and mineral; I know the kings of England, and I quote the fights historical from Marathon to Waterloo, in order categorical; I'm very well acquainted, too, with matters mathematical; I understand equations, both the simple and quadratical; about binomial theorem I'm teeming with a lot o' news, with many cheerful facts about the square of the hypotenuse.",
                    maxlinelen=76)
         for l in h.encode(splitchars=' ').split('\n '):
-            self.assertTrue(len(l) <= 76)
+            self.assertLessEqual(len(l), 76)
 
     def test_multilingual(self):
         eq = self.ndiffAssertEqual
diff -r 3a1db0d2747e Lib/httplib.py
--- a/Lib/httplib.py
+++ b/Lib/httplib.py
@@ -565,7 +565,7 @@
         # connection, and the user is reading more bytes than will be provided
         # (for example, reading in 1k chunks)
         s = self.fp.read(amt)
-        if not s:
+        if not s and amt:
             # Ideally, we would raise IncompleteRead if the content-length
             # wasn't satisfied, but it might break compatibility.
             self.close()
diff -r 3a1db0d2747e Lib/idlelib/PyShell.py
--- a/Lib/idlelib/PyShell.py
+++ b/Lib/idlelib/PyShell.py
@@ -1338,8 +1338,16 @@
     def write(self, s):
         if self.closed:
             raise ValueError("write to closed file")
-        if not isinstance(s, (basestring, bytearray)):
-            raise TypeError('must be string, not ' + type(s).__name__)
+        if type(s) not in (unicode, str, bytearray):
+            # See issue #19481
+            if isinstance(s, unicode):
+                s = unicode.__getslice__(s, None, None)
+            elif isinstance(s, str):
+                s = str.__str__(s)
+            elif isinstance(s, bytearray):
+                s = bytearray.__str__(s)
+            else:
+                raise TypeError('must be string, not ' + type(s).__name__)
         return self.shell.write(s, self.tags)
 
 
@@ -1385,6 +1393,9 @@
         line = self._line_buffer or self.shell.readline()
         if size < 0:
             size = len(line)
+        eol = line.find('\n', 0, size)
+        if eol >= 0:
+            size = eol + 1
         self._line_buffer = line[size:]
         return line[:size]
 
@@ -1538,20 +1549,22 @@
                     args.remove(filename)
             if not args:
                 flist.new()
+
     if enable_shell:
         shell = flist.open_shell()
         if not shell:
             return # couldn't open shell
-
         if macosxSupport.runningAsOSXApp() and flist.dict:
             # On OSX: when the user has double-clicked on a file that causes
             # IDLE to be launched the shell window will open just in front of
             # the file she wants to see. Lower the interpreter window when
             # there are open files.
             shell.top.lower()
+    else:
+        shell = flist.pyshell
 
-    shell = flist.pyshell
-    # handle remaining options:
+    # Handle remaining options. If any of these are set, enable_shell
+    # was set also, so shell must be true to reach here.
     if debug:
         shell.open_debugger()
     if startup:
@@ -1559,7 +1572,7 @@
                    os.environ.get("PYTHONSTARTUP")
         if filename and os.path.isfile(filename):
             shell.interp.execfile(filename)
-    if shell and cmd or script:
+    if cmd or script:
         shell.interp.runcommand("""if 1:
             import sys as _sys
             _sys.argv = %r
@@ -1570,13 +1583,14 @@
         elif script:
             shell.interp.prepend_syspath(script)
             shell.interp.execfile(script)
-
-    # Check for problematic OS X Tk versions and print a warning message
-    # in the IDLE shell window; this is less intrusive than always opening
-    # a separate window.
-    tkversionwarning = macosxSupport.tkVersionWarning(root)
-    if tkversionwarning:
-        shell.interp.runcommand(''.join(("print('", tkversionwarning, "')")))
+    elif shell:
+        # If there is a shell window and no cmd or script in progress,
+        # check for problematic OS X Tk versions and print a warning
+        # message in the IDLE shell window; this is less intrusive
+        # than always opening a separate window.
+        tkversionwarning = macosxSupport.tkVersionWarning(root)
+        if tkversionwarning:
+            shell.interp.runcommand("print('%s')" % tkversionwarning)
 
     while flist.inversedict:  # keep IDLE running while files are open.
         root.mainloop()
diff -r 3a1db0d2747e Lib/imaplib.py
--- a/Lib/imaplib.py
+++ b/Lib/imaplib.py
@@ -35,6 +35,15 @@
 IMAP4_SSL_PORT = 993
 AllowedVersions = ('IMAP4REV1', 'IMAP4')        # Most recent first
 
+# Maximal line length when calling readline(). This is to prevent
+# reading arbitrary length lines. RFC 3501 and 2060 (IMAP 4rev1)
+# don't specify a line length. RFC 2683 however suggests limiting client
+# command lines to 1000 octets and server command lines to 8000 octets.
+# We have selected 10000 for some extra margin and since that is supposedly
+# also what UW and Panda IMAP does.
+_MAXLINE = 10000
+
+
 #       Commands
 
 Commands = {
@@ -237,7 +246,10 @@
 
     def readline(self):
         """Read line from remote."""
-        return self.file.readline()
+        line = self.file.readline(_MAXLINE + 1)
+        if len(line) > _MAXLINE:
+            raise self.error("got more than %d bytes" % _MAXLINE)
+        return line
 
 
     def send(self, data):
diff -r 3a1db0d2747e Lib/json/decoder.py
--- a/Lib/json/decoder.py
+++ b/Lib/json/decoder.py
@@ -62,6 +62,16 @@
 
 DEFAULT_ENCODING = "utf-8"
 
+def _decode_uXXXX(s, pos):
+    esc = s[pos + 1:pos + 5]
+    if len(esc) == 4 and esc[1] not in 'xX':
+        try:
+            return int(esc, 16)
+        except ValueError:
+            pass
+    msg = "Invalid \\uXXXX escape"
+    raise ValueError(errmsg(msg, s, pos))
+
 def py_scanstring(s, end, encoding=None, strict=True,
         _b=BACKSLASH, _m=STRINGCHUNK.match):
     """Scan the string s for a JSON string. End is the index of the
@@ -116,25 +126,16 @@
             end += 1
         else:
             # Unicode escape sequence
-            esc = s[end + 1:end + 5]
-            next_end = end + 5
-            if len(esc) != 4:
-                msg = "Invalid \\uXXXX escape"
-                raise ValueError(errmsg(msg, s, end))
-            uni = int(esc, 16)
+            uni = _decode_uXXXX(s, end)
+            end += 5
             # Check for surrogate pair on UCS-4 systems
-            if 0xd800 <= uni <= 0xdbff and sys.maxunicode > 65535:
-                msg = "Invalid \\uXXXX\\uXXXX surrogate pair"
-                if not s[end + 5:end + 7] == '\\u':
-                    raise ValueError(errmsg(msg, s, end))
-                esc2 = s[end + 7:end + 11]
-                if len(esc2) != 4:
-                    raise ValueError(errmsg(msg, s, end))
-                uni2 = int(esc2, 16)
-                uni = 0x10000 + (((uni - 0xd800) << 10) | (uni2 - 0xdc00))
-                next_end += 6
+            if sys.maxunicode > 65535 and \
+               0xd800 <= uni <= 0xdbff and s[end:end + 2] == '\\u':
+                uni2 = _decode_uXXXX(s, end + 1)
+                if 0xdc00 <= uni2 <= 0xdfff:
+                    uni = 0x10000 + (((uni - 0xd800) << 10) | (uni2 - 0xdc00))
+                    end += 6
             char = unichr(uni)
-            end = next_end
         # Append the unescaped character
         _append(char)
     return u''.join(chunks), end
diff -r 3a1db0d2747e Lib/json/tests/test_scanstring.py
--- a/Lib/json/tests/test_scanstring.py
+++ b/Lib/json/tests/test_scanstring.py
@@ -5,10 +5,6 @@
 class TestScanstring(object):
     def test_scanstring(self):
         scanstring = self.json.decoder.scanstring
-        self.assertEqual(
-            scanstring('"z\\ud834\\udd20x"', 1, None, True),
-            (u'z\U0001d120x', 16))
-
         if sys.maxunicode == 65535:
             self.assertEqual(
                 scanstring(u'"z\U0001d120x"', 1, None, True),
@@ -94,6 +90,58 @@
             scanstring('["Bad value", truth]', 2, None, True),
             (u'Bad value', 12))
 
+    def test_surrogates(self):
+        scanstring = self.json.decoder.scanstring
+        def assertScan(given, expect):
+            self.assertEqual(scanstring(given, 1, None, True),
+                             (expect, len(given)))
+            if not isinstance(given, unicode):
+                given = unicode(given)
+                self.assertEqual(scanstring(given, 1, None, True),
+                                 (expect, len(given)))
+
+        surrogates = unichr(0xd834) + unichr(0xdd20)
+        assertScan('"z\\ud834\\u0079x"', u'z\ud834yx')
+        assertScan('"z\\ud834\\udd20x"', u'z\U0001d120x')
+        assertScan('"z\\ud834\\ud834\\udd20x"', u'z\ud834\U0001d120x')
+        assertScan('"z\\ud834x"', u'z\ud834x')
+        assertScan(u'"z\\ud834\udd20x12345"', u'z%sx12345' % surrogates)
+        assertScan('"z\\udd20x"', u'z\udd20x')
+        assertScan(u'"z\ud834\udd20x"', u'z\ud834\udd20x')
+        assertScan(u'"z\ud834\\udd20x"', u'z%sx' % surrogates)
+        assertScan(u'"z\ud834x"', u'z\ud834x')
+
+    def test_bad_escapes(self):
+        scanstring = self.json.decoder.scanstring
+        bad_escapes = [
+            '"\\"',
+            '"\\x"',
+            '"\\u"',
+            '"\\u0"',
+            '"\\u01"',
+            '"\\u012"',
+            '"\\uz012"',
+            '"\\u0z12"',
+            '"\\u01z2"',
+            '"\\u012z"',
+            '"\\u0x12"',
+            '"\\u0X12"',
+            '"\\ud834\\"',
+            '"\\ud834\\u"',
+            '"\\ud834\\ud"',
+            '"\\ud834\\udd"',
+            '"\\ud834\\udd2"',
+            '"\\ud834\\uzdd2"',
+            '"\\ud834\\udzd2"',
+            '"\\ud834\\uddz2"',
+            '"\\ud834\\udd2z"',
+            '"\\ud834\\u0x20"',
+            '"\\ud834\\u0X20"',
+        ]
+        for s in bad_escapes:
+            with self.assertRaises(ValueError):
+                scanstring(s, 1, None, True)
+
     def test_issue3623(self):
         self.assertRaises(ValueError, self.json.decoder.scanstring, b"xxx", 1,
                           "xxx")
diff -r 3a1db0d2747e Lib/lib-tk/Tix.py
--- a/Lib/lib-tk/Tix.py
+++ b/Lib/lib-tk/Tix.py
@@ -122,13 +122,9 @@
         elif cnf:
             cnf = _cnfmerge(cnf)
         if cnf is None:
-            cnf = {}
-            for x in self.tk.split(self.tk.call('tix', 'configure')):
-                cnf[x[0][1:]] = (x[0][1:],) + x[1:]
-            return cnf
+            return self._getconfigure('tix', 'configure')
         if isinstance(cnf, StringType):
-            x = self.tk.split(self.tk.call('tix', 'configure', '-'+cnf))
-            return (x[0][1:],) + x[1:]
+            return self._getconfigure1('tix', 'configure', '-'+cnf)
         return self.tk.call(('tix', 'configure') + self._options(cnf))
 
     def tix_filedialog(self, dlgclass=None):
@@ -380,7 +376,7 @@
         """Return the name of all subwidgets."""
         try:
             x = self.tk.call(self._w, 'subwidgets', '-all')
-            return self.tk.split(x)
+            return self.tk.splitlist(x)
         except TclError:
             return None
 
@@ -473,13 +469,6 @@
             self.tk.call('destroy', self._w)
 
 
-# Useful func. to split Tcl lists and return as a dict. From Tkinter.py
-def _lst2dict(lst):
-    dict = {}
-    for x in lst:
-        dict[x[0][1:]] = (x[0][1:],) + x[1:]
-    return dict
-
 # Useful class to create a display style - later shared by many items.
 # Contributed by Steffen Kremser
 class DisplayStyle:
@@ -515,10 +504,8 @@
         self.tk.call(self.stylename, 'configure', '-%s'%key, value)
 
     def config(self, cnf={}, **kw):
-        return _lst2dict(
-            self.tk.split(
-            self.tk.call(
-                  self.stylename, 'configure', *self._options(cnf,kw))))
+        return self._getconfigure(
+            self.stylename, 'configure', *self._options(cnf,kw))
 
     def __getitem__(self,key):
         return self.tk.call(self.stylename, 'cget', '-%s'%key)
@@ -928,9 +915,7 @@
 
     def header_configure(self, col, cnf={}, **kw):
         if cnf is None:
-            return _lst2dict(
-                self.tk.split(
-                self.tk.call(self._w, 'header', 'configure', col)))
+            return self._getconfigure(self._w, 'header', 'configure', col)
         self.tk.call(self._w, 'header', 'configure', col,
                      *self._options(cnf, kw))
 
@@ -955,9 +940,8 @@
 
     def indicator_configure(self, entry, cnf={}, **kw):
         if cnf is None:
-            return _lst2dict(
-                self.tk.split(
-                self.tk.call(self._w, 'indicator', 'configure', entry)))
+            return self._getconfigure(
+                self._w, 'indicator', 'configure', entry)
         self.tk.call(
               self._w, 'indicator', 'configure', entry, *self._options(cnf, kw))
 
@@ -1017,9 +1001,7 @@
 
     def item_configure(self, entry, col, cnf={}, **kw):
         if cnf is None:
-            return _lst2dict(
-                self.tk.split(
-                self.tk.call(self._w, 'item', 'configure', entry, col)))
+            return self._getconfigure(self._w, 'item', 'configure', entry, col)
         self.tk.call(self._w, 'item', 'configure', entry, col,
               *self._options(cnf, kw))
 
@@ -1038,9 +1020,7 @@
 
     def entryconfigure(self, entry, cnf={}, **kw):
         if cnf is None:
-            return _lst2dict(
-                self.tk.split(
-                self.tk.call(self._w, 'entryconfigure', entry)))
+            return self._getconfigure(self._w, 'entryconfigure', entry)
         self.tk.call(self._w, 'entryconfigure', entry,
               *self._options(cnf, kw))
 
@@ -1255,9 +1235,7 @@
 
     def paneconfigure(self, entry, cnf={}, **kw):
         if cnf is None:
-            return _lst2dict(
-                self.tk.split(
-                self.tk.call(self._w, 'paneconfigure', entry)))
+            return self._getconfigure(self._w, 'paneconfigure', entry)
         self.tk.call(self._w, 'paneconfigure', entry, *self._options(cnf, kw))
 
     def panes(self):
diff -r 3a1db0d2747e Lib/lib-tk/Tkinter.py
--- a/Lib/lib-tk/Tkinter.py
+++ b/Lib/lib-tk/Tkinter.py
@@ -76,9 +76,9 @@
         else:
             value = '{%s}' % _join(value)
     else:
-        if isinstance(value, basestring):
-            value = unicode(value)
-        else:
+        if isinstance(value, str):
+            value = unicode(value, 'utf-8')
+        elif not isinstance(value, unicode):
             value = str(value)
         if not value:
             value = '{}'
@@ -223,11 +223,13 @@
             _varnum += 1
         if value is not None:
             self.set(value)
-        elif not self._tk.call("info", "exists", self._name):
+        elif not self._tk.getboolean(self._tk.call("info", "exists", self._name)):
             self.set(self._default)
     def __del__(self):
         """Unset the variable in Tcl."""
-        self._tk.globalunsetvar(self._name)
+        if (self._tk is not None and
+            self._tk.getboolean(self._tk.call("info", "exists", self._name))):
+            self._tk.globalunsetvar(self._name)
     def __str__(self):
         """Return the name of the variable in Tcl."""
         return self._name
@@ -1234,6 +1236,19 @@
         exc, val, tb = sys.exc_type, sys.exc_value, sys.exc_traceback
         root = self._root()
         root.report_callback_exception(exc, val, tb)
+
+    def _getconfigure(self, *args):
+        """Call Tcl configure command and return the result as a dict."""
+        cnf = {}
+        for x in self.tk.splitlist(self.tk.call(*args)):
+            x = self.tk.splitlist(x)
+            cnf[x[0][1:]] = (x[0][1:],) + x[1:]
+        return cnf
+
+    def _getconfigure1(self, *args):
+        x = self.tk.splitlist(self.tk.call(*args))
+        return (x[0][1:],) + x[1:]
+
     def _configure(self, cmd, cnf, kw):
         """Internal function."""
         if kw:
@@ -1241,15 +1256,9 @@
         elif cnf:
             cnf = _cnfmerge(cnf)
         if cnf is None:
-            cnf = {}
-            for x in self.tk.split(
-                    self.tk.call(_flatten((self._w, cmd)))):
-                cnf[x[0][1:]] = (x[0][1:],) + x[1:]
-            return cnf
+            return self._getconfigure(_flatten((self._w, cmd)))
         if type(cnf) is StringType:
-            x = self.tk.split(
-                    self.tk.call(_flatten((self._w, cmd, '-'+cnf))))
-            return (x[0][1:],) + x[1:]
+            return self._getconfigure1(_flatten((self._w, cmd, '-'+cnf)))
         self.tk.call(_flatten((self._w, cmd)) + self._options(cnf))
     # These used to be defined in Widget:
     def configure(self, cnf=None, **kw):
@@ -1271,8 +1280,8 @@
         raise TypeError("Tkinter objects don't support 'in' tests.")
     def keys(self):
         """Return a list of all resource names of this widget."""
-        return map(lambda x: x[0][1:],
-               self.tk.split(self.tk.call(self._w, 'configure')))
+        return [x[0][1:] for x in
+                self.tk.splitlist(self.tk.call(self._w, 'configure'))]
     def __str__(self):
         """Return the window path name of this widget."""
         return self._w
@@ -1447,11 +1456,11 @@
 
     def image_names(self):
         """Return a list of all existing image names."""
-        return self.tk.call('image', 'names')
+        return self.tk.splitlist(self.tk.call('image', 'names'))
 
     def image_types(self):
         """Return a list of all available image types (e.g. phote bitmap)."""
-        return self.tk.call('image', 'types')
+        return self.tk.splitlist(self.tk.call('image', 'types'))
 
 
 class CallWrapper:
@@ -1565,7 +1574,10 @@
         if len(wlist) > 1:
             wlist = (wlist,) # Tk needs a list of windows here
         args = ('wm', 'colormapwindows', self._w) + wlist
-        return map(self._nametowidget, self.tk.call(args))
+        if wlist:
+            self.tk.call(args)
+        else:
+            return map(self._nametowidget, self.tk.splitlist(self.tk.call(args)))
     colormapwindows = wm_colormapwindows
     def wm_command(self, value=None):
         """Store VALUE in WM_COMMAND property. It is the command
@@ -2908,8 +2920,9 @@
     def debug(self, boolean=None):
         """Turn on the internal consistency checks of the B-Tree inside the text
         widget according to BOOLEAN."""
-        return self.tk.getboolean(self.tk.call(
-            self._w, 'debug', boolean))
+        if boolean is None:
+            return self.tk.getboolean(self.tk.call(self._w, 'debug'))
+        self.tk.call(self._w, 'debug', boolean)
     def delete(self, index1, index2=None):
         """Delete the characters between INDEX1 and INDEX2 (not included)."""
         self.tk.call(self._w, 'delete', index1, index2)
@@ -3364,8 +3377,11 @@
         Valid resource names: background, data, file, foreground, maskdata, maskfile."""
         Image.__init__(self, 'bitmap', name, cnf, master, **kw)
 
-def image_names(): return _default_root.tk.call('image', 'names')
-def image_types(): return _default_root.tk.call('image', 'types')
+def image_names():
+    return _default_root.tk.splitlist(_default_root.tk.call('image', 'names'))
+
+def image_types():
+    return _default_root.tk.splitlist(_default_root.tk.call('image', 'types'))
 
 
 class Spinbox(Widget, XView):
@@ -3411,7 +3427,7 @@
         bounding box may refer to a region outside the
         visible area of the window.
         """
-        return self.tk.call(self._w, 'bbox', index)
+        return self._getints(self.tk.call(self._w, 'bbox', index)) or None
 
     def delete(self, first, last=None):
         """Delete one or more elements of the spinbox.
@@ -3724,23 +3740,17 @@
 
         """
         if cnf is None and not kw:
-            cnf = {}
-            for x in self.tk.split(
-                self.tk.call(self._w,
-                         'paneconfigure', tagOrId)):
-                cnf[x[0][1:]] = (x[0][1:],) + x[1:]
-            return cnf
+            return self._getconfigure(self._w, 'paneconfigure', tagOrId)
         if type(cnf) == StringType and not kw:
-            x = self.tk.split(self.tk.call(
-                self._w, 'paneconfigure', tagOrId, '-'+cnf))
-            return (x[0][1:],) + x[1:]
+            return self._getconfigure1(
+                self._w, 'paneconfigure', tagOrId, '-'+cnf)
         self.tk.call((self._w, 'paneconfigure', tagOrId) +
                  self._options(cnf, kw))
     paneconfig = paneconfigure
 
     def panes(self):
         """Returns an ordered list of the child panes."""
-        return self.tk.call(self._w, 'panes')
+        return self.tk.splitlist(self.tk.call(self._w, 'panes'))
 
 ######################################################################
 # Extensions:
diff -r 3a1db0d2747e Lib/lib-tk/test/test_tkinter/test_text.py
--- a/Lib/lib-tk/test/test_tkinter/test_text.py
+++ b/Lib/lib-tk/test/test_tkinter/test_text.py
@@ -14,6 +14,17 @@
     def tearDown(self):
         self.text.destroy()
 
+    def test_debug(self):
+        text = self.text
+        olddebug = text.debug()
+        try:
+            text.debug(0)
+            self.assertEqual(text.debug(), 0)
+            text.debug(1)
+            self.assertEqual(text.debug(), 1)
+        finally:
+            text.debug(olddebug)
+            self.assertEqual(text.debug(), olddebug)
 
     def test_search(self):
         text = self.text
diff -r 3a1db0d2747e Lib/lib-tk/test/test_tkinter/test_variables.py
--- /dev/null
+++ b/Lib/lib-tk/test/test_tkinter/test_variables.py
@@ -0,0 +1,152 @@
+import unittest
+
+from Tkinter import Variable, StringVar, IntVar, DoubleVar, BooleanVar, Tk, TclError
+
+
+class TestBase(unittest.TestCase):
+
+    def setUp(self):
+        self.root = Tk()
+
+    def tearDown(self):
+        self.root.destroy()
+
+
+class TestVariable(TestBase):
+
+    def info_exists(self, *args):
+        return self.root.getboolean(self.root.call("info", "exists", *args))
+
+    def test_default(self):
+        v = Variable(self.root)
+        self.assertEqual("", v.get())
+        self.assertRegexpMatches(str(v), r"^PY_VAR(\d+)$")
+
+    def test_name_and_value(self):
+        v = Variable(self.root, "sample string", "varname")
+        self.assertEqual("sample string", v.get())
+        self.assertEqual("varname", str(v))
+
+    def test___del__(self):
+        self.assertFalse(self.info_exists("varname"))
+        v = Variable(self.root, "sample string", "varname")
+        self.assertTrue(self.info_exists("varname"))
+        del v
+        self.assertFalse(self.info_exists("varname"))
+
+    def test_dont_unset_not_existing(self):
+        self.assertFalse(self.info_exists("varname"))
+        v1 = Variable(self.root, name="name")
+        v2 = Variable(self.root, name="name")
+        del v1
+        self.assertFalse(self.info_exists("name"))
+        # shouldn't raise exception
+        del v2
+        self.assertFalse(self.info_exists("name"))
+
+    def test___eq__(self):
+        # values doesn't matter, only class and name are checked
+        v1 = Variable(self.root, name="abc")
+        v2 = Variable(self.root, name="abc")
+        self.assertEqual(v1, v2)
+
+        v3 = Variable(self.root, name="abc")
+        v4 = StringVar(self.root, name="abc")
+        self.assertNotEqual(v3, v4)
+
+    def test_invalid_name(self):
+        with self.assertRaises(TypeError):
+            Variable(self.root, name=123)
+
+
+class TestStringVar(TestBase):
+
+    def test_default(self):
+        v = StringVar(self.root)
+        self.assertEqual("", v.get())
+
+    def test_get(self):
+        v = StringVar(self.root, "abc", "name")
+        self.assertEqual("abc", v.get())
+        self.root.globalsetvar("name", "value")
+        self.assertEqual("value", v.get())
+
+
+class TestIntVar(TestBase):
+
+    def test_default(self):
+        v = IntVar(self.root)
+        self.assertEqual(0, v.get())
+
+    def test_get(self):
+        v = IntVar(self.root, 123, "name")
+        self.assertEqual(123, v.get())
+        self.root.globalsetvar("name", "345")
+        self.assertEqual(345, v.get())
+
+    def test_invalid_value(self):
+        v = IntVar(self.root, name="name")
+        self.root.globalsetvar("name", "value")
+        with self.assertRaises(ValueError):
+            v.get()
+        self.root.globalsetvar("name", "345.0")
+        with self.assertRaises(ValueError):
+            v.get()
+
+
+class TestDoubleVar(TestBase):
+
+    def test_default(self):
+        v = DoubleVar(self.root)
+        self.assertEqual(0.0, v.get())
+
+    def test_get(self):
+        v = DoubleVar(self.root, 1.23, "name")
+        self.assertAlmostEqual(1.23, v.get())
+        self.root.globalsetvar("name", "3.45")
+        self.assertAlmostEqual(3.45, v.get())
+
+    def test_get_from_int(self):
+        v = DoubleVar(self.root, 1.23, "name")
+        self.assertAlmostEqual(1.23, v.get())
+        self.root.globalsetvar("name", "3.45")
+        self.assertAlmostEqual(3.45, v.get())
+        self.root.globalsetvar("name", "456")
+        self.assertAlmostEqual(456, v.get())
+
+    def test_invalid_value(self):
+        v = DoubleVar(self.root, name="name")
+        self.root.globalsetvar("name", "value")
+        with self.assertRaises(ValueError):
+            v.get()
+
+
+class TestBooleanVar(TestBase):
+
+    def test_default(self):
+        v = BooleanVar(self.root)
+        self.assertEqual(False, v.get())
+
+    def test_get(self):
+        v = BooleanVar(self.root, True, "name")
+        self.assertAlmostEqual(True, v.get())
+        self.root.globalsetvar("name", "0")
+        self.assertAlmostEqual(False, v.get())
+
+    def test_invalid_value_domain(self):
+        v = BooleanVar(self.root, name="name")
+        self.root.globalsetvar("name", "value")
+        with self.assertRaises(TclError):
+            v.get()
+        self.root.globalsetvar("name", "1.0")
+        with self.assertRaises(TclError):
+            v.get()
+
+
+tests_gui = (TestVariable, TestStringVar, TestIntVar,
+             TestDoubleVar, TestBooleanVar)
+
+
+if __name__ == "__main__":
+    from test.support import run_unittest
+    run_unittest(*tests_gui)
diff -r 3a1db0d2747e Lib/lib-tk/test/test_tkinter/test_widgets.py
--- /dev/null
+++ b/Lib/lib-tk/test/test_tkinter/test_widgets.py
@@ -0,0 +1,951 @@
+import unittest
+import Tkinter
+import os
+import sys
+from test.test_support import requires, run_unittest
+
+from test_ttk.support import (tcl_version, requires_tcl, get_tk_patchlevel,
+                              widget_eq)
+from widget_tests import (
+    add_standard_options, noconv, noconv_meth, int_round, pixels_round,
+    AbstractWidgetTest, StandardOptionsTests,
+    IntegerSizeTests, PixelSizeTests,
+    setUpModule)
+
+requires('gui')
+
+
+class AbstractToplevelTest(AbstractWidgetTest, PixelSizeTests):
+    _conv_pad_pixels = noconv_meth
+
+    def test_class(self):
+        widget = self.create()
+        self.assertEqual(widget['class'],
+                         widget.__class__.__name__.title())
+        self.checkInvalidParam(widget, 'class', 'Foo',
+                errmsg="can't modify -class option after widget is created")
+        widget2 = self.create(class_='Foo')
+        self.assertEqual(widget2['class'], 'Foo')
+
+    def test_colormap(self):
+        widget = self.create()
+        self.assertEqual(widget['colormap'], '')
+        self.checkInvalidParam(widget, 'colormap', 'new',
+                errmsg="can't modify -colormap option after widget is created")
+        widget2 = self.create(colormap='new')
+        self.assertEqual(widget2['colormap'], 'new')
+
+    def test_container(self):
+        widget = self.create()
+        self.assertEqual(widget['container'], 0 if self.wantobjects else '0')
+        self.checkInvalidParam(widget, 'container', 1,
+                errmsg="can't modify -container option after widget is created")
+        widget2 = self.create(container=True)
+        self.assertEqual(widget2['container'], 1 if self.wantobjects else '1')
+
+    def test_visual(self):
+        widget = self.create()
+        self.assertEqual(widget['visual'], '')
+        self.checkInvalidParam(widget, 'visual', 'default',
+                errmsg="can't modify -visual option after widget is created")
+        widget2 = self.create(visual='default')
+        self.assertEqual(widget2['visual'], 'default')
+
+
+@add_standard_options(StandardOptionsTests)
+class ToplevelTest(AbstractToplevelTest, unittest.TestCase):
+    OPTIONS = (
+        'background', 'borderwidth',
+        'class', 'colormap', 'container', 'cursor', 'height',
+        'highlightbackground', 'highlightcolor', 'highlightthickness',
+        'menu', 'padx', 'pady', 'relief', 'screen',
+        'takefocus', 'use', 'visual', 'width',
+    )
+
+    def _create(self, **kwargs):
+        return Tkinter.Toplevel(self.root, **kwargs)
+
+    def test_menu(self):
+        widget = self.create()
+        menu = Tkinter.Menu(self.root)
+        self.checkParam(widget, 'menu', menu, eq=widget_eq)
+        self.checkParam(widget, 'menu', '')
+
+    def test_screen(self):
+        widget = self.create()
+        self.assertEqual(widget['screen'], '')
+        try:
+            display = os.environ['DISPLAY']
+        except KeyError:
+            self.skipTest('No $DISPLAY set.')
+        self.checkInvalidParam(widget, 'screen', display,
+                errmsg="can't modify -screen option after widget is created")
+        widget2 = self.create(screen=display)
+        self.assertEqual(widget2['screen'], display)
+
+    def test_use(self):
+        widget = self.create()
+        self.assertEqual(widget['use'], '')
+        parent = self.create(container=True)
+        wid = parent.winfo_id()
+        widget2 = self.create(use=wid)
+        self.assertEqual(int(widget2['use']), wid)
+
+
+@add_standard_options(StandardOptionsTests)
+class FrameTest(AbstractToplevelTest, unittest.TestCase):
+    OPTIONS = (
+        'background', 'borderwidth',
+        'class', 'colormap', 'container', 'cursor', 'height',
+        'highlightbackground', 'highlightcolor', 'highlightthickness',
+        'relief', 'takefocus', 'visual', 'width',
+    )
+
+    def _create(self, **kwargs):
+        return Tkinter.Frame(self.root, **kwargs)
+
+
+@add_standard_options(StandardOptionsTests)
+class LabelFrameTest(AbstractToplevelTest, unittest.TestCase):
+    OPTIONS = (
+        'background', 'borderwidth',
+        'class', 'colormap', 'container', 'cursor',
+        'font', 'foreground', 'height',
+        'highlightbackground', 'highlightcolor', 'highlightthickness',
+        'labelanchor', 'labelwidget', 'padx', 'pady', 'relief',
+        'takefocus', 'text', 'visual', 'width',
+    )
+
+    def _create(self, **kwargs):
+        return Tkinter.LabelFrame(self.root, **kwargs)
+
+    def test_labelanchor(self):
+        widget = self.create()
+        self.checkEnumParam(widget, 'labelanchor',
+                            'e', 'en', 'es', 'n', 'ne', 'nw',
+                            's', 'se', 'sw', 'w', 'wn', 'ws')
+        self.checkInvalidParam(widget, 'labelanchor', 'center')
+
+    def test_labelwidget(self):
+        widget = self.create()
+        label = Tkinter.Label(self.root, text='Mupp', name='foo')
+        self.checkParam(widget, 'labelwidget', label, expected='.foo')
+        label.destroy()
+
+
+class AbstractLabelTest(AbstractWidgetTest, IntegerSizeTests):
+    _conv_pixels = noconv_meth
+
+    def test_highlightthickness(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'highlightthickness',
+                              0, 1.3, 2.6, 6, -2, '10p')
+
+
+@add_standard_options(StandardOptionsTests)
+class LabelTest(AbstractLabelTest, unittest.TestCase):
+    OPTIONS = (
+        'activebackground', 'activeforeground', 'anchor',
+        'background', 'bitmap', 'borderwidth', 'compound', 'cursor',
+        'disabledforeground', 'font', 'foreground', 'height',
+        'highlightbackground', 'highlightcolor', 'highlightthickness',
+        'image', 'justify', 'padx', 'pady', 'relief', 'state',
+        'takefocus', 'text', 'textvariable',
+        'underline', 'width', 'wraplength',
+    )
+
+    def _create(self, **kwargs):
+        return Tkinter.Label(self.root, **kwargs)
+
+
+@add_standard_options(StandardOptionsTests)
+class ButtonTest(AbstractLabelTest, unittest.TestCase):
+    OPTIONS = (
+        'activebackground', 'activeforeground', 'anchor',
+        'background', 'bitmap', 'borderwidth',
+        'command', 'compound', 'cursor', 'default',
+        'disabledforeground', 'font', 'foreground', 'height',
+        'highlightbackground', 'highlightcolor', 'highlightthickness',
+        'image', 'justify', 'overrelief', 'padx', 'pady', 'relief',
+        'repeatdelay', 'repeatinterval',
+        'state', 'takefocus', 'text', 'textvariable',
+        'underline', 'width', 'wraplength')
+
+    def _create(self, **kwargs):
+        return Tkinter.Button(self.root, **kwargs)
+
+    def test_default(self):
+        widget = self.create()
+        self.checkEnumParam(widget, 'default', 'active', 'disabled', 'normal')
+
+
+@add_standard_options(StandardOptionsTests)
+class CheckbuttonTest(AbstractLabelTest, unittest.TestCase):
+    OPTIONS = (
+        'activebackground', 'activeforeground', 'anchor',
+        'background', 'bitmap', 'borderwidth',
+        'command', 'compound', 'cursor',
+        'disabledforeground', 'font', 'foreground', 'height',
+        'highlightbackground', 'highlightcolor', 'highlightthickness',
+        'image', 'indicatoron', 'justify',
+        'offrelief', 'offvalue', 'onvalue', 'overrelief',
+        'padx', 'pady', 'relief', 'selectcolor', 'selectimage', 'state',
+        'takefocus', 'text', 'textvariable',
+        'tristateimage', 'tristatevalue',
+        'underline', 'variable', 'width', 'wraplength',
+    )
+
+    def _create(self, **kwargs):
+        return Tkinter.Checkbutton(self.root, **kwargs)
+
+
+    def test_offvalue(self):
+        widget = self.create()
+        self.checkParams(widget, 'offvalue', 1, 2.3, '', 'any string')
+
+    def test_onvalue(self):
+        widget = self.create()
+        self.checkParams(widget, 'onvalue', 1, 2.3, '', 'any string')
+
+
+@add_standard_options(StandardOptionsTests)
+class RadiobuttonTest(AbstractLabelTest, unittest.TestCase):
+    OPTIONS = (
+        'activebackground', 'activeforeground', 'anchor',
+        'background', 'bitmap', 'borderwidth',
+        'command', 'compound', 'cursor',
+        'disabledforeground', 'font', 'foreground', 'height',
+        'highlightbackground', 'highlightcolor', 'highlightthickness',
+        'image', 'indicatoron', 'justify', 'offrelief', 'overrelief',
+        'padx', 'pady', 'relief', 'selectcolor', 'selectimage', 'state',
+        'takefocus', 'text', 'textvariable',
+        'tristateimage', 'tristatevalue',
+        'underline', 'value', 'variable', 'width', 'wraplength',
+    )
+
+    def _create(self, **kwargs):
+        return Tkinter.Radiobutton(self.root, **kwargs)
+
+    def test_value(self):
+        widget = self.create()
+        self.checkParams(widget, 'value', 1, 2.3, '', 'any string')
+
+
+@add_standard_options(StandardOptionsTests)
+class MenubuttonTest(AbstractLabelTest, unittest.TestCase):
+    OPTIONS = (
+        'activebackground', 'activeforeground', 'anchor',
+        'background', 'bitmap', 'borderwidth',
+        'compound', 'cursor', 'direction',
+        'disabledforeground', 'font', 'foreground', 'height',
+        'highlightbackground', 'highlightcolor', 'highlightthickness',
+        'image', 'indicatoron', 'justify', 'menu',
+        'padx', 'pady', 'relief', 'state',
+        'takefocus', 'text', 'textvariable',
+        'underline', 'width', 'wraplength',
+    )
+    _conv_pixels = staticmethod(pixels_round)
+
+    def _create(self, **kwargs):
+        return Tkinter.Menubutton(self.root, **kwargs)
+
+    def test_direction(self):
+        widget = self.create()
+        self.checkEnumParam(widget, 'direction',
+                'above', 'below', 'flush', 'left', 'right')
+
+    def test_height(self):
+        widget = self.create()
+        self.checkIntegerParam(widget, 'height', 100, -100, 0, conv=str)
+
+    test_highlightthickness = StandardOptionsTests.test_highlightthickness.im_func
+
+    @unittest.skipIf(sys.platform == 'darwin',
+                     'crashes with Cocoa Tk (issue19733)')
+    def test_image(self):
+        widget = self.create()
+        image = Tkinter.PhotoImage('image1')
+        self.checkParam(widget, 'image', image, conv=str)
+        errmsg = 'image "spam" doesn\'t exist'
+        with self.assertRaises(Tkinter.TclError) as cm:
+            widget['image'] = 'spam'
+        if errmsg is not None:
+            self.assertEqual(str(cm.exception), errmsg)
+        with self.assertRaises(Tkinter.TclError) as cm:
+            widget.configure({'image': 'spam'})
+        if errmsg is not None:
+            self.assertEqual(str(cm.exception), errmsg)
+
+    def test_menu(self):
+        widget = self.create()
+        menu = Tkinter.Menu(widget, name='menu')
+        self.checkParam(widget, 'menu', menu, eq=widget_eq)
+        menu.destroy()
+
+    def test_padx(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'padx', 3, 4.4, 5.6, '12m')
+        self.checkParam(widget, 'padx', -2, expected=0)
+
+    def test_pady(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'pady', 3, 4.4, 5.6, '12m')
+        self.checkParam(widget, 'pady', -2, expected=0)
+
+    def test_width(self):
+        widget = self.create()
+        self.checkIntegerParam(widget, 'width', 402, -402, 0, conv=str)
+
+
+class OptionMenuTest(MenubuttonTest, unittest.TestCase):
+
+    def _create(self, default='b', values=('a', 'b', 'c'), **kwargs):
+        return Tkinter.OptionMenu(self.root, None, default, *values, **kwargs)
+
+
+@add_standard_options(IntegerSizeTests, StandardOptionsTests)
+class EntryTest(AbstractWidgetTest, unittest.TestCase):
+    OPTIONS = (
+        'background', 'borderwidth', 'cursor',
+        'disabledbackground', 'disabledforeground',
+        'exportselection', 'font', 'foreground',
+        'highlightbackground', 'highlightcolor', 'highlightthickness',
+        'insertbackground', 'insertborderwidth',
+        'insertofftime', 'insertontime', 'insertwidth',
+        'invalidcommand', 'justify', 'readonlybackground', 'relief',
+        'selectbackground', 'selectborderwidth', 'selectforeground',
+        'show', 'state', 'takefocus', 'textvariable',
+        'validate', 'validatecommand', 'width', 'xscrollcommand',
+    )
+
+    def _create(self, **kwargs):
+        return Tkinter.Entry(self.root, **kwargs)
+
+    def test_disabledbackground(self):
+        widget = self.create()
+        self.checkColorParam(widget, 'disabledbackground')
+
+    def test_insertborderwidth(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'insertborderwidth', 0, 1.3, -2)
+        self.checkParam(widget, 'insertborderwidth', 2, expected=1)
+        self.checkParam(widget, 'insertborderwidth', '10p', expected=1)
+
+    def test_insertwidth(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'insertwidth', 1.3, 3.6, '10p')
+        self.checkParam(widget, 'insertwidth', 0.1, expected=2)
+        self.checkParam(widget, 'insertwidth', -2, expected=2)
+        if pixels_round(0.9) <= 0:
+            self.checkParam(widget, 'insertwidth', 0.9, expected=2)
+        else:
+            self.checkParam(widget, 'insertwidth', 0.9, expected=1)
+
+    def test_invalidcommand(self):
+        widget = self.create()
+        self.checkCommandParam(widget, 'invalidcommand')
+        self.checkCommandParam(widget, 'invcmd')
+
+    def test_readonlybackground(self):
+        widget = self.create()
+        self.checkColorParam(widget, 'readonlybackground')
+
+    def test_show(self):
+        widget = self.create()
+        self.checkParam(widget, 'show', '*')
+        self.checkParam(widget, 'show', '')
+        self.checkParam(widget, 'show', ' ')
+
+    def test_state(self):
+        widget = self.create()
+        self.checkEnumParam(widget, 'state',
+                            'disabled', 'normal', 'readonly')
+
+    def test_validate(self):
+        widget = self.create()
+        self.checkEnumParam(widget, 'validate',
+                'all', 'key', 'focus', 'focusin', 'focusout', 'none')
+
+    def test_validatecommand(self):
+        widget = self.create()
+        self.checkCommandParam(widget, 'validatecommand')
+        self.checkCommandParam(widget, 'vcmd')
+
+
+@add_standard_options(StandardOptionsTests)
+class SpinboxTest(EntryTest, unittest.TestCase):
+    OPTIONS = (
+        'activebackground', 'background', 'borderwidth',
+        'buttonbackground', 'buttoncursor', 'buttondownrelief', 'buttonuprelief',
+        'command', 'cursor', 'disabledbackground', 'disabledforeground',
+        'exportselection', 'font', 'foreground', 'format', 'from',
+        'highlightbackground', 'highlightcolor', 'highlightthickness',
+        'increment',
+        'insertbackground', 'insertborderwidth',
+        'insertofftime', 'insertontime', 'insertwidth',
+        'invalidcommand', 'justify', 'relief', 'readonlybackground',
+        'repeatdelay', 'repeatinterval',
+        'selectbackground', 'selectborderwidth', 'selectforeground',
+        'state', 'takefocus', 'textvariable', 'to',
+        'validate', 'validatecommand', 'values',
+        'width', 'wrap', 'xscrollcommand',
+    )
+
+    def _create(self, **kwargs):
+        return Tkinter.Spinbox(self.root, **kwargs)
+
+    test_show = None
+
+    def test_buttonbackground(self):
+        widget = self.create()
+        self.checkColorParam(widget, 'buttonbackground')
+
+    def test_buttoncursor(self):
+        widget = self.create()
+        self.checkCursorParam(widget, 'buttoncursor')
+
+    def test_buttondownrelief(self):
+        widget = self.create()
+        self.checkReliefParam(widget, 'buttondownrelief')
+
+    def test_buttonuprelief(self):
+        widget = self.create()
+        self.checkReliefParam(widget, 'buttonuprelief')
+
+    def test_format(self):
+        widget = self.create()
+        self.checkParam(widget, 'format', '%2f')
+        self.checkParam(widget, 'format', '%2.2f')
+        self.checkParam(widget, 'format', '%.2f')
+        self.checkParam(widget, 'format', '%2.f')
+        self.checkInvalidParam(widget, 'format', '%2e-1f')
+        self.checkInvalidParam(widget, 'format', '2.2')
+        self.checkInvalidParam(widget, 'format', '%2.-2f')
+        self.checkParam(widget, 'format', '%-2.02f')
+        self.checkParam(widget, 'format', '% 2.02f')
+        self.checkParam(widget, 'format', '% -2.200f')
+        self.checkParam(widget, 'format', '%09.200f')
+        self.checkInvalidParam(widget, 'format', '%d')
+
+    def test_from(self):
+        widget = self.create()
+        self.checkParam(widget, 'to', 100.0)
+        self.checkFloatParam(widget, 'from', -10, 10.2, 11.7)
+        self.checkInvalidParam(widget, 'from', 200,
+                errmsg='-to value must be greater than -from value')
+
+    def test_increment(self):
+        widget = self.create()
+        self.checkFloatParam(widget, 'increment', -1, 1, 10.2, 12.8, 0)
+
+    def test_to(self):
+        widget = self.create()
+        self.checkParam(widget, 'from', -100.0)
+        self.checkFloatParam(widget, 'to', -10, 10.2, 11.7)
+        self.checkInvalidParam(widget, 'to', -200,
+                errmsg='-to value must be greater than -from value')
+
+    def test_values(self):
+        # XXX
+        widget = self.create()
+        self.assertEqual(widget['values'], '')
+        self.checkParam(widget, 'values', 'mon tue wed thur')
+        self.checkParam(widget, 'values', ('mon', 'tue', 'wed', 'thur'),
+                        expected='mon tue wed thur')
+        self.checkParam(widget, 'values', (42, 3.14, '', 'any string'),
+                        expected='42 3.14 {} {any string}')
+        self.checkParam(widget, 'values', '')
+
+    def test_wrap(self):
+        widget = self.create()
+        self.checkBooleanParam(widget, 'wrap')
+
+    def test_bbox(self):
+        widget = self.create()
+        bbox = widget.bbox(0)
+        self.assertEqual(len(bbox), 4)
+        for item in bbox:
+            self.assertIsInstance(item, int)
+
+        self.assertRaises(Tkinter.TclError, widget.bbox, 'noindex')
+        self.assertRaises(Tkinter.TclError, widget.bbox, None)
+        self.assertRaises(TypeError, widget.bbox)
+        self.assertRaises(TypeError, widget.bbox, 0, 1)
+
+
+@add_standard_options(StandardOptionsTests)
+class TextTest(AbstractWidgetTest, unittest.TestCase):
+    OPTIONS = (
+        'autoseparators', 'background', 'blockcursor', 'borderwidth',
+        'cursor', 'endline', 'exportselection',
+        'font', 'foreground', 'height',
+        'highlightbackground', 'highlightcolor', 'highlightthickness',
+        'inactiveselectbackground', 'insertbackground', 'insertborderwidth',
+        'insertofftime', 'insertontime', 'insertunfocussed', 'insertwidth',
+        'maxundo', 'padx', 'pady', 'relief',
+        'selectbackground', 'selectborderwidth', 'selectforeground',
+        'setgrid', 'spacing1', 'spacing2', 'spacing3', 'startline', 'state',
+        'tabs', 'tabstyle', 'takefocus', 'undo', 'width', 'wrap',
+        'xscrollcommand', 'yscrollcommand',
+    )
+    if tcl_version < (8, 5):
+        wantobjects = False
+
+    def _create(self, **kwargs):
+        return Tkinter.Text(self.root, **kwargs)
+
+    def test_autoseparators(self):
+        widget = self.create()
+        self.checkBooleanParam(widget, 'autoseparators')
+
+    @requires_tcl(8, 5)
+    def test_blockcursor(self):
+        widget = self.create()
+        self.checkBooleanParam(widget, 'blockcursor')
+
+    @requires_tcl(8, 5)
+    def test_endline(self):
+        widget = self.create()
+        text = '\n'.join('Line %d' for i in range(100))
+        widget.insert('end', text)
+        self.checkParam(widget, 'endline', 200, expected='')
+        self.checkParam(widget, 'endline', -10, expected='')
+        self.checkInvalidParam(widget, 'endline', 'spam',
+                errmsg='expected integer but got "spam"')
+        self.checkParam(widget, 'endline', 50)
+        self.checkParam(widget, 'startline', 15)
+        self.checkInvalidParam(widget, 'endline', 10,
+                errmsg='-startline must be less than or equal to -endline')
+
+    def test_height(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'height', 100, 101.2, 102.6, '3c')
+        self.checkParam(widget, 'height', -100, expected=1)
+        self.checkParam(widget, 'height', 0, expected=1)
+
+    def test_maxundo(self):
+        widget = self.create()
+        self.checkIntegerParam(widget, 'maxundo', 0, 5, -1)
+
+    @requires_tcl(8, 5)
+    def test_inactiveselectbackground(self):
+        widget = self.create()
+        self.checkColorParam(widget, 'inactiveselectbackground')
+
+    @requires_tcl(8, 6)
+    def test_insertunfocussed(self):
+        widget = self.create()
+        self.checkEnumParam(widget, 'insertunfocussed',
+                            'hollow', 'none', 'solid')
+
+    def test_selectborderwidth(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'selectborderwidth',
+                              1.3, 2.6, -2, '10p', conv=noconv,
+                              keep_orig=tcl_version >= (8, 5))
+
+    def test_spacing1(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'spacing1', 20, 21.4, 22.6, '0.5c')
+        self.checkParam(widget, 'spacing1', -5, expected=0)
+
+    def test_spacing2(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'spacing2', 5, 6.4, 7.6, '0.1c')
+        self.checkParam(widget, 'spacing2', -1, expected=0)
+
+    def test_spacing3(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'spacing3', 20, 21.4, 22.6, '0.5c')
+        self.checkParam(widget, 'spacing3', -10, expected=0)
+
+    @requires_tcl(8, 5)
+    def test_startline(self):
+        widget = self.create()
+        text = '\n'.join('Line %d' for i in range(100))
+        widget.insert('end', text)
+        self.checkParam(widget, 'startline', 200, expected='')
+        self.checkParam(widget, 'startline', -10, expected='')
+        self.checkInvalidParam(widget, 'startline', 'spam',
+                errmsg='expected integer but got "spam"')
+        self.checkParam(widget, 'startline', 10)
+        self.checkParam(widget, 'endline', 50)
+        self.checkInvalidParam(widget, 'startline', 70,
+                errmsg='-startline must be less than or equal to -endline')
+
+    def test_state(self):
+        widget = self.create()
+        if tcl_version < (8, 5):
+            self.checkParams(widget, 'state', 'disabled', 'normal')
+        else:
+            self.checkEnumParam(widget, 'state', 'disabled', 'normal')
+
+    def test_tabs(self):
+        widget = self.create()
+        if get_tk_patchlevel() < (8, 5, 11):
+            self.checkParam(widget, 'tabs', (10.2, 20.7, '1i', '2i'),
+                            expected=('10.2', '20.7', '1i', '2i'))
+        else:
+            self.checkParam(widget, 'tabs', (10.2, 20.7, '1i', '2i'))
+        self.checkParam(widget, 'tabs', '10.2 20.7 1i 2i',
+                        expected=('10.2', '20.7', '1i', '2i'))
+        self.checkParam(widget, 'tabs', '2c left 4c 6c center',
+                        expected=('2c', 'left', '4c', '6c', 'center'))
+        self.checkInvalidParam(widget, 'tabs', 'spam',
+                               errmsg='bad screen distance "spam"',
+                               keep_orig=tcl_version >= (8, 5))
+
+    @requires_tcl(8, 5)
+    def test_tabstyle(self):
+        widget = self.create()
+        self.checkEnumParam(widget, 'tabstyle', 'tabular', 'wordprocessor')
+
+    def test_undo(self):
+        widget = self.create()
+        self.checkBooleanParam(widget, 'undo')
+
+    def test_width(self):
+        widget = self.create()
+        self.checkIntegerParam(widget, 'width', 402)
+        self.checkParam(widget, 'width', -402, expected=1)
+        self.checkParam(widget, 'width', 0, expected=1)
+
+    def test_wrap(self):
+        widget = self.create()
+        if tcl_version < (8, 5):
+            self.checkParams(widget, 'wrap', 'char', 'none', 'word')
+        else:
+            self.checkEnumParam(widget, 'wrap', 'char', 'none', 'word')
+
+    def test_bbox(self):
+        widget = self.create()
+        bbox = widget.bbox('1.1')
+        self.assertEqual(len(bbox), 4)
+        for item in bbox:
+            self.assertIsInstance(item, int)
+
+        self.assertIsNone(widget.bbox('end'))
+        self.assertRaises(Tkinter.TclError, widget.bbox, 'noindex')
+        self.assertRaises(Tkinter.TclError, widget.bbox, None)
+        self.assertRaises(Tkinter.TclError, widget.bbox)
+        self.assertRaises(Tkinter.TclError, widget.bbox, '1.1', 'end')
+
+
+@add_standard_options(PixelSizeTests, StandardOptionsTests)
+class CanvasTest(AbstractWidgetTest, unittest.TestCase):
+    OPTIONS = (
+        'background', 'borderwidth',
+        'closeenough', 'confine', 'cursor', 'height',
+        'highlightbackground', 'highlightcolor', 'highlightthickness',
+        'insertbackground', 'insertborderwidth',
+        'insertofftime', 'insertontime', 'insertwidth',
+        'relief', 'scrollregion',
+        'selectbackground', 'selectborderwidth', 'selectforeground',
+        'state', 'takefocus',
+        'xscrollcommand', 'xscrollincrement',
+        'yscrollcommand', 'yscrollincrement', 'width',
+    )
+
+    _conv_pixels = staticmethod(int_round)
+    wantobjects = False
+
+    def _create(self, **kwargs):
+        return Tkinter.Canvas(self.root, **kwargs)
+
+    def test_closeenough(self):
+        widget = self.create()
+        self.checkFloatParam(widget, 'closeenough', 24, 2.4, 3.6, -3,
+                             conv=float)
+
+    def test_confine(self):
+        widget = self.create()
+        self.checkBooleanParam(widget, 'confine')
+
+    def test_scrollregion(self):
+        widget = self.create()
+        self.checkParam(widget, 'scrollregion', '0 0 200 150')
+        self.checkParam(widget, 'scrollregion', (0, 0, 200, 150),
+                        expected='0 0 200 150')
+        self.checkParam(widget, 'scrollregion', '')
+        self.checkInvalidParam(widget, 'scrollregion', 'spam',
+                               errmsg='bad scrollRegion "spam"')
+        self.checkInvalidParam(widget, 'scrollregion', (0, 0, 200, 'spam'))
+        self.checkInvalidParam(widget, 'scrollregion', (0, 0, 200))
+        self.checkInvalidParam(widget, 'scrollregion', (0, 0, 200, 150, 0))
+
+    def test_state(self):
+        widget = self.create()
+        self.checkEnumParam(widget, 'state', 'disabled', 'normal',
+                errmsg='bad state value "{}": must be normal or disabled')
+
+    def test_xscrollincrement(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'xscrollincrement',
+                              40, 0, 41.2, 43.6, -40, '0.5i')
+
+    def test_yscrollincrement(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'yscrollincrement',
+                              10, 0, 11.2, 13.6, -10, '0.1i')
+
+
+@add_standard_options(IntegerSizeTests, StandardOptionsTests)
+class ListboxTest(AbstractWidgetTest, unittest.TestCase):
+    OPTIONS = (
+        'activestyle', 'background', 'borderwidth', 'cursor',
+        'disabledforeground', 'exportselection',
+        'font', 'foreground', 'height',
+        'highlightbackground', 'highlightcolor', 'highlightthickness',
+        'listvariable', 'relief',
+        'selectbackground', 'selectborderwidth', 'selectforeground',
+        'selectmode', 'setgrid', 'state',
+        'takefocus', 'width', 'xscrollcommand', 'yscrollcommand',
+    )
+
+    def _create(self, **kwargs):
+        return Tkinter.Listbox(self.root, **kwargs)
+
+    def test_activestyle(self):
+        widget = self.create()
+        self.checkEnumParam(widget, 'activestyle',
+                            'dotbox', 'none', 'underline')
+
+    def test_listvariable(self):
+        widget = self.create()
+        var = Tkinter.DoubleVar()
+        self.checkVariableParam(widget, 'listvariable', var)
+
+    def test_selectmode(self):
+        widget = self.create()
+        self.checkParam(widget, 'selectmode', 'single')
+        self.checkParam(widget, 'selectmode', 'browse')
+        self.checkParam(widget, 'selectmode', 'multiple')
+        self.checkParam(widget, 'selectmode', 'extended')
+
+    def test_state(self):
+        widget = self.create()
+        self.checkEnumParam(widget, 'state', 'disabled', 'normal')
+
+@add_standard_options(PixelSizeTests, StandardOptionsTests)
+class ScaleTest(AbstractWidgetTest, unittest.TestCase):
+    OPTIONS = (
+        'activebackground', 'background', 'bigincrement', 'borderwidth',
+        'command', 'cursor', 'digits', 'font', 'foreground', 'from',
+        'highlightbackground', 'highlightcolor', 'highlightthickness',
+        'label', 'length', 'orient', 'relief',
+        'repeatdelay', 'repeatinterval',
+        'resolution', 'showvalue', 'sliderlength', 'sliderrelief', 'state',
+        'takefocus', 'tickinterval', 'to', 'troughcolor', 'variable', 'width',
+    )
+    default_orient = 'vertical'
+
+    def _create(self, **kwargs):
+        return Tkinter.Scale(self.root, **kwargs)
+
+    def test_bigincrement(self):
+        widget = self.create()
+        self.checkFloatParam(widget, 'bigincrement', 12.4, 23.6, -5)
+
+    def test_digits(self):
+        widget = self.create()
+        self.checkIntegerParam(widget, 'digits', 5, 0)
+
+    def test_from(self):
+        widget = self.create()
+        self.checkFloatParam(widget, 'from', 100, 14.9, 15.1, conv=round)
+
+    def test_label(self):
+        widget = self.create()
+        self.checkParam(widget, 'label', 'any string')
+        self.checkParam(widget, 'label', '')
+
+    def test_length(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'length', 130, 131.2, 135.6, '5i')
+
+    def test_resolution(self):
+        widget = self.create()
+        self.checkFloatParam(widget, 'resolution', 4.2, 0, 6.7, -2)
+
+    def test_showvalue(self):
+        widget = self.create()
+        self.checkBooleanParam(widget, 'showvalue')
+
+    def test_sliderlength(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'sliderlength',
+                              10, 11.2, 15.6, -3, '3m')
+
+    def test_sliderrelief(self):
+        widget = self.create()
+        self.checkReliefParam(widget, 'sliderrelief')
+
+    def test_tickinterval(self):
+        widget = self.create()
+        self.checkFloatParam(widget, 'tickinterval', 1, 4.3, 7.6, 0,
+                             conv=round)
+        self.checkParam(widget, 'tickinterval', -2, expected=2,
+                        conv=round)
+
+    def test_to(self):
+        widget = self.create()
+        self.checkFloatParam(widget, 'to', 300, 14.9, 15.1, -10,
+                             conv=round)
+
+
+@add_standard_options(PixelSizeTests, StandardOptionsTests)
+class ScrollbarTest(AbstractWidgetTest, unittest.TestCase):
+    OPTIONS = (
+        'activebackground', 'activerelief',
+        'background', 'borderwidth',
+        'command', 'cursor', 'elementborderwidth',
+        'highlightbackground', 'highlightcolor', 'highlightthickness',
+        'jump', 'orient', 'relief',
+        'repeatdelay', 'repeatinterval',
+        'takefocus', 'troughcolor', 'width',
+    )
+    _conv_pixels = staticmethod(int_round)
+    wantobjects = False
+    default_orient = 'vertical'
+
+    def _create(self, **kwargs):
+        return Tkinter.Scrollbar(self.root, **kwargs)
+
+    def test_activerelief(self):
+        widget = self.create()
+        self.checkReliefParam(widget, 'activerelief')
+
+    def test_elementborderwidth(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'elementborderwidth', 4.3, 5.6, -2, '1m')
+
+    def test_orient(self):
+        widget = self.create()
+        self.checkEnumParam(widget, 'orient', 'vertical', 'horizontal',
+                errmsg='bad orientation "{}": must be vertical or horizontal')
+
+
+@add_standard_options(StandardOptionsTests)
+class PanedWindowTest(AbstractWidgetTest, unittest.TestCase):
+    OPTIONS = (
+        'background', 'borderwidth', 'cursor',
+        'handlepad', 'handlesize', 'height',
+        'opaqueresize', 'orient', 'relief',
+        'sashcursor', 'sashpad', 'sashrelief', 'sashwidth',
+        'showhandle', 'width',
+    )
+    default_orient = 'horizontal'
+
+    def _create(self, **kwargs):
+        return Tkinter.PanedWindow(self.root, **kwargs)
+
+    def test_handlepad(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'handlepad', 5, 6.4, 7.6, -3, '1m')
+
+    def test_handlesize(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'handlesize', 8, 9.4, 10.6, -3, '2m',
+                              conv=noconv)
+
+    def test_height(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'height', 100, 101.2, 102.6, -100, 0, '1i',
+                              conv=noconv)
+
+    def test_opaqueresize(self):
+        widget = self.create()
+        self.checkBooleanParam(widget, 'opaqueresize')
+
+    def test_sashcursor(self):
+        widget = self.create()
+        self.checkCursorParam(widget, 'sashcursor')
+
+    def test_sashpad(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'sashpad', 8, 1.3, 2.6, -2, '2m')
+
+    def test_sashrelief(self):
+        widget = self.create()
+        self.checkReliefParam(widget, 'sashrelief')
+
+    def test_sashwidth(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'sashwidth', 10, 11.1, 15.6, -3, '1m',
+                              conv=noconv)
+
+    def test_showhandle(self):
+        widget = self.create()
+        self.checkBooleanParam(widget, 'showhandle')
+
+    def test_width(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'width', 402, 403.4, 404.6, -402, 0, '5i',
+                              conv=noconv)
+
+
+@add_standard_options(StandardOptionsTests)
+class MenuTest(AbstractWidgetTest, unittest.TestCase):
+    OPTIONS = (
+        'activebackground', 'activeborderwidth', 'activeforeground',
+        'background', 'borderwidth', 'cursor',
+        'disabledforeground', 'font', 'foreground',
+        'postcommand', 'relief', 'selectcolor', 'takefocus',
+        'tearoff', 'tearoffcommand', 'title', 'type',
+    )
+    _conv_pixels = noconv_meth
+
+    def _create(self, **kwargs):
+        return Tkinter.Menu(self.root, **kwargs)
+
+    def test_postcommand(self):
+        widget = self.create()
+        self.checkCommandParam(widget, 'postcommand')
+
+    def test_tearoff(self):
+        widget = self.create()
+        self.checkBooleanParam(widget, 'tearoff')
+
+    def test_tearoffcommand(self):
+        widget = self.create()
+        self.checkCommandParam(widget, 'tearoffcommand')
+
+    def test_title(self):
+        widget = self.create()
+        self.checkParam(widget, 'title', 'any string')
+
+    def test_type(self):
+        widget = self.create()
+        self.checkEnumParam(widget, 'type',
+                'normal', 'tearoff', 'menubar')
+
+
+@add_standard_options(PixelSizeTests, StandardOptionsTests)
+class MessageTest(AbstractWidgetTest, unittest.TestCase):
+    OPTIONS = (
+        'anchor', 'aspect', 'background', 'borderwidth',
+        'cursor', 'font', 'foreground',
+        'highlightbackground', 'highlightcolor', 'highlightthickness',
+        'justify', 'padx', 'pady', 'relief',
+        'takefocus', 'text', 'textvariable', 'width',
+    )
+    _conv_pad_pixels = noconv_meth
+
+    def _create(self, **kwargs):
+        return Tkinter.Message(self.root, **kwargs)
+
+    def test_aspect(self):
+        widget = self.create()
+        self.checkIntegerParam(widget, 'aspect', 250, 0, -300)
+
+
+tests_gui = [
+        ButtonTest, CanvasTest, CheckbuttonTest, EntryTest,
+        FrameTest, LabelFrameTest,LabelTest, ListboxTest,
+        MenubuttonTest, MenuTest, MessageTest, OptionMenuTest,
+        PanedWindowTest, RadiobuttonTest, ScaleTest, ScrollbarTest,
+        SpinboxTest, TextTest, ToplevelTest,
+]
+
+if __name__ == '__main__':
+    run_unittest(*tests_gui)
diff -r 3a1db0d2747e Lib/lib-tk/test/test_ttk/support.py
--- a/Lib/lib-tk/test/test_ttk/support.py
+++ b/Lib/lib-tk/test/test_ttk/support.py
@@ -1,3 +1,4 @@
+import unittest
 import Tkinter
 
 def get_tk_root():
@@ -31,3 +32,57 @@
     widget.event_generate('<Motion>', x=x, y=y)
     widget.event_generate('<ButtonPress-1>', x=x, y=y)
     widget.event_generate('<ButtonRelease-1>', x=x, y=y)
+
+
+import _tkinter
+tcl_version = tuple(map(int, _tkinter.TCL_VERSION.split('.')))
+
+def requires_tcl(*version):
+    return unittest.skipUnless(tcl_version >= version,
+            'requires Tcl version >= ' + '.'.join(map(str, version)))
+
+_tk_patchlevel = None
+def get_tk_patchlevel():
+    global _tk_patchlevel
+    if _tk_patchlevel is None:
+        tcl = Tkinter.Tcl()
+        patchlevel = []
+        for x in tcl.call('info', 'patchlevel').split('.'):
+            try:
+                x = int(x, 10)
+            except ValueError:
+                x = -1
+            patchlevel.append(x)
+        _tk_patchlevel = tuple(patchlevel)
+    return _tk_patchlevel
+
+units = {
+    'c': 72 / 2.54,     # centimeters
+    'i': 72,            # inches
+    'm': 72 / 25.4,     # millimeters
+    'p': 1,             # points
+}
+
+def pixels_conv(value):
+    return float(value[:-1]) * units[value[-1:]]
+
+def tcl_obj_eq(actual, expected):
+    if actual == expected:
+        return True
+    if isinstance(actual, _tkinter.Tcl_Obj):
+        if isinstance(expected, str):
+            return str(actual) == expected
+    if isinstance(actual, tuple):
+        if isinstance(expected, tuple):
+            return (len(actual) == len(expected) and
+                    all(tcl_obj_eq(act, exp)
+                        for act, exp in zip(actual, expected)))
+    return False
+
+def widget_eq(actual, expected):
+    if actual == expected:
+        return True
+    if isinstance(actual, (str, Tkinter.Widget)):
+        if isinstance(expected, (str, Tkinter.Widget)):
+            return str(actual) == str(expected)
+    return False
diff -r 3a1db0d2747e Lib/lib-tk/test/test_ttk/test_extensions.py
--- a/Lib/lib-tk/test/test_ttk/test_extensions.py
+++ b/Lib/lib-tk/test/test_ttk/test_extensions.py
@@ -29,7 +29,10 @@
         name = myvar._name
         x = ttk.LabeledScale(variable=myvar)
         x.destroy()
-        self.assertEqual(x.tk.globalgetvar(name), myvar.get())
+        if x.tk.wantobjects():
+            self.assertEqual(x.tk.globalgetvar(name), myvar.get())
+        else:
+            self.assertEqual(float(x.tk.globalgetvar(name)), myvar.get())
         del myvar
         self.assertRaises(Tkinter.TclError, x.tk.globalgetvar, name)
 
@@ -45,7 +48,7 @@
         # it tries calling instance attributes not yet defined.
         ttk.LabeledScale(variable=myvar)
         if hasattr(sys, 'last_type'):
-            self.assertFalse(sys.last_type == Tkinter.TclError)
+            self.assertNotEqual(sys.last_type, Tkinter.TclError)
 
 
     def test_initialization(self):
@@ -59,8 +62,10 @@
         x.destroy()
 
         # variable initialization/passing
-        passed_expected = ((2.5, 2), ('0', 0), (0, 0), (10, 10),
+        passed_expected = (('0', 0), (0, 0), (10, 10),
             (-1, -1), (sys.maxint + 1, sys.maxint + 1))
+        if x.tk.wantobjects():
+            passed_expected += ((2.5, 2),)
         for pair in passed_expected:
             x = ttk.LabeledScale(from_=pair[0])
             self.assertEqual(x.value, pair[1])
@@ -120,14 +125,14 @@
         # at the same time this shouldn't affect test outcome
         lscale.update()
         curr_xcoord = lscale.scale.coords()[0]
-        self.assertTrue(prev_xcoord != curr_xcoord)
+        self.assertNotEqual(prev_xcoord, curr_xcoord)
         # the label widget should have been repositioned too
         linfo_2 = lscale.label.place_info()
-        self.assertEqual(lscale.label['text'], 0)
+        self.assertEqual(lscale.label['text'], 0 if lscale.tk.wantobjects() else '0')
         self.assertEqual(curr_xcoord, int(linfo_2['x']))
         # change the range back
         lscale.scale.configure(from_=0, to=10)
-        self.assertTrue(prev_xcoord != curr_xcoord)
+        self.assertNotEqual(prev_xcoord, curr_xcoord)
         self.assertEqual(prev_xcoord, int(linfo_1['x']))
 
         lscale.destroy()
@@ -145,15 +150,20 @@
         # The following update is needed since the test doesn't use mainloop,
         # at the same time this shouldn't affect test outcome
         x.update()
-        self.assertEqual(x.label['text'], newval)
-        self.assertTrue(x.scale.coords()[0] > curr_xcoord)
+        self.assertEqual(x.label['text'],
+                         newval if x.tk.wantobjects() else str(newval))
+        self.assertGreater(x.scale.coords()[0], curr_xcoord)
         self.assertEqual(x.scale.coords()[0],
             int(x.label.place_info()['x']))
 
         # value outside range
-        x.value = x.scale['to'] + 1 # no changes shouldn't happen
+        if x.tk.wantobjects():
+            conv = lambda x: x
+        else:
+            conv = int
+        x.value = conv(x.scale['to']) + 1 # no changes shouldn't happen
         x.update()
-        self.assertEqual(x.label['text'], newval)
+        self.assertEqual(conv(x.label['text']), newval)
         self.assertEqual(x.scale.coords()[0],
             int(x.label.place_info()['x']))
 
@@ -238,7 +248,7 @@
             if last == curr:
                 # no more menu entries
                 break
-            self.assertFalse(curr == default)
+            self.assertNotEqual(curr, default)
             i += 1
         self.assertEqual(i, len(items))
 
diff -r 3a1db0d2747e Lib/lib-tk/test/test_ttk/test_functions.py
--- a/Lib/lib-tk/test/test_ttk/test_functions.py
+++ b/Lib/lib-tk/test/test_ttk/test_functions.py
@@ -394,8 +394,10 @@
             ('name', 'no_minus', 'value'))
         self.assertRaises(ValueError, ttk._list_from_layouttuple,
             ('something', '-children')) # no children
-        self.assertRaises(ValueError, ttk._list_from_layouttuple,
-            ('something', '-children', 'value')) # invalid children
+        import Tkinter
+        if not Tkinter._default_root or Tkinter._default_root.wantobjects():
+            self.assertRaises(ValueError, ttk._list_from_layouttuple,
+                ('something', '-children', 'value')) # invalid children
 
 
     def test_val_or_dict(self):
diff -r 3a1db0d2747e Lib/lib-tk/test/test_ttk/test_style.py
--- a/Lib/lib-tk/test/test_ttk/test_style.py
+++ b/Lib/lib-tk/test/test_ttk/test_style.py
@@ -18,15 +18,16 @@
         style.configure('TButton', background='yellow')
         self.assertEqual(style.configure('TButton', 'background'),
             'yellow')
-        self.assertTrue(isinstance(style.configure('TButton'), dict))
+        self.assertIsInstance(style.configure('TButton'), dict)
 
 
     def test_map(self):
         style = self.style
         style.map('TButton', background=[('active', 'background', 'blue')])
         self.assertEqual(style.map('TButton', 'background'),
-            [('active', 'background', 'blue')])
-        self.assertTrue(isinstance(style.map('TButton'), dict))
+            [('active', 'background', 'blue')] if style.tk.wantobjects() else
+            [('active background', 'blue')])
+        self.assertIsInstance(style.map('TButton'), dict)
 
 
     def test_lookup(self):
@@ -57,7 +58,7 @@
         self.assertEqual(style.layout('Treeview'), tv_style)
 
         # should return a list
-        self.assertTrue(isinstance(style.layout('TButton'), list))
+        self.assertIsInstance(style.layout('TButton'), list)
 
         # correct layout, but "option" doesn't exist as option
         self.assertRaises(Tkinter.TclError, style.layout, 'Treeview',
diff -r 3a1db0d2747e Lib/lib-tk/test/test_ttk/test_widgets.py
--- a/Lib/lib-tk/test/test_ttk/test_widgets.py
+++ b/Lib/lib-tk/test/test_ttk/test_widgets.py
@@ -6,9 +6,54 @@
 
 import support
 from test_functions import MockTclObj, MockStateSpec
+from support import tcl_version, get_tk_patchlevel
+from widget_tests import (add_standard_options, noconv, noconv_meth,
+    AbstractWidgetTest, StandardOptionsTests,
+    IntegerSizeTests, PixelSizeTests,
+    setUpModule)
 
 requires('gui')
 
+
+class StandardTtkOptionsTests(StandardOptionsTests):
+
+    def test_class(self):
+        widget = self.create()
+        self.assertEqual(widget['class'], '')
+        errmsg='attempt to change read-only option'
+        if get_tk_patchlevel() < (8, 6, 0): # actually this was changen in 8.6b3
+            errmsg='Attempt to change read-only option'
+        self.checkInvalidParam(widget, 'class', 'Foo', errmsg=errmsg)
+        widget2 = self.create(class_='Foo')
+        self.assertEqual(widget2['class'], 'Foo')
+
+    def test_padding(self):
+        widget = self.create()
+        self.checkParam(widget, 'padding', 0, expected=('0',))
+        self.checkParam(widget, 'padding', 5, expected=('5',))
+        self.checkParam(widget, 'padding', (5, 6), expected=('5', '6'))
+        self.checkParam(widget, 'padding', (5, 6, 7),
+                        expected=('5', '6', '7'))
+        self.checkParam(widget, 'padding', (5, 6, 7, 8),
+                        expected=('5', '6', '7', '8'))
+        self.checkParam(widget, 'padding', ('5p', '6p', '7p', '8p'))
+        self.checkParam(widget, 'padding', (), expected='')
+
+    def test_style(self):
+        widget = self.create()
+        self.assertEqual(widget['style'], '')
+        errmsg = 'Layout Foo not found'
+        if hasattr(self, 'default_orient'):
+            errmsg = ('Layout %s.Foo not found' %
+                      getattr(self, 'default_orient').title())
+        self.checkInvalidParam(widget, 'style', 'Foo',
+                errmsg=errmsg)
+        widget2 = self.create(class_='Foo')
+        self.assertEqual(widget2['class'], 'Foo')
+        # XXX
+        pass
+
+
 class WidgetTest(unittest.TestCase):
     """Tests methods available in every ttk widget."""
 
@@ -72,7 +117,112 @@
         self.assertEqual(self.widget.state(), ('active', ))
 
 
-class ButtonTest(unittest.TestCase):
+class AbstractToplevelTest(AbstractWidgetTest, PixelSizeTests):
+    _conv_pixels = noconv_meth
+
+
+@add_standard_options(StandardTtkOptionsTests)
+class FrameTest(AbstractToplevelTest, unittest.TestCase):
+    OPTIONS = (
+        'borderwidth', 'class', 'cursor', 'height',
+        'padding', 'relief', 'style', 'takefocus',
+        'width',
+    )
+
+    def _create(self, **kwargs):
+        return ttk.Frame(self.root, **kwargs)
+
+
+@add_standard_options(StandardTtkOptionsTests)
+class LabelFrameTest(AbstractToplevelTest, unittest.TestCase):
+    OPTIONS = (
+        'borderwidth', 'class', 'cursor', 'height',
+        'labelanchor', 'labelwidget',
+        'padding', 'relief', 'style', 'takefocus',
+        'text', 'underline', 'width',
+    )
+
+    def _create(self, **kwargs):
+        return ttk.LabelFrame(self.root, **kwargs)
+
+    def test_labelanchor(self):
+        widget = self.create()
+        self.checkEnumParam(widget, 'labelanchor',
+                'e', 'en', 'es', 'n', 'ne', 'nw', 's', 'se', 'sw', 'w', 'wn', 'ws',
+                errmsg='Bad label anchor specification {}')
+        self.checkInvalidParam(widget, 'labelanchor', 'center')
+
+    def test_labelwidget(self):
+        widget = self.create()
+        label = ttk.Label(self.root, text='Mupp', name='foo')
+        self.checkParam(widget, 'labelwidget', label, expected='.foo')
+        label.destroy()
+
+
+class AbstractLabelTest(AbstractWidgetTest):
+
+    def checkImageParam(self, widget, name):
+        image = Tkinter.PhotoImage('image1')
+        image2 = Tkinter.PhotoImage('image2')
+        self.checkParam(widget, name, image, expected=('image1',))
+        self.checkParam(widget, name, 'image1', expected=('image1',))
+        self.checkParam(widget, name, (image,), expected=('image1',))
+        self.checkParam(widget, name, (image, 'active', image2),
+                        expected=('image1', 'active', 'image2'))
+        self.checkParam(widget, name, 'image1 active image2',
+                        expected=('image1', 'active', 'image2'))
+        self.checkInvalidParam(widget, name, 'spam',
+                errmsg='image "spam" doesn\'t exist')
+
+    def test_compound(self):
+        widget = self.create()
+        self.checkEnumParam(widget, 'compound',
+                'none', 'text', 'image', 'center',
+                'top', 'bottom', 'left', 'right')
+
+    def test_state(self):
+        widget = self.create()
+        self.checkParams(widget, 'state', 'active', 'disabled', 'normal')
+
+    def test_width(self):
+        widget = self.create()
+        self.checkParams(widget, 'width', 402, -402, 0)
+
+
+@add_standard_options(StandardTtkOptionsTests)
+class LabelTest(AbstractLabelTest, unittest.TestCase):
+    OPTIONS = (
+        'anchor', 'background',
+        'class', 'compound', 'cursor', 'font', 'foreground',
+        'image', 'justify', 'padding', 'relief', 'state', 'style',
+        'takefocus', 'text', 'textvariable',
+        'underline', 'width', 'wraplength',
+    )
+    _conv_pixels = noconv_meth
+
+    def _create(self, **kwargs):
+        return ttk.Label(self.root, **kwargs)
+
+    def test_font(self):
+        widget = self.create()
+        self.checkParam(widget, 'font',
+                        '-Adobe-Helvetica-Medium-R-Normal--*-120-*-*-*-*-*-*')
+
+
+@add_standard_options(StandardTtkOptionsTests)
+class ButtonTest(AbstractLabelTest, unittest.TestCase):
+    OPTIONS = (
+        'class', 'command', 'compound', 'cursor', 'default',
+        'image', 'state', 'style', 'takefocus', 'text', 'textvariable',
+        'underline', 'width',
+    )
+
+    def _create(self, **kwargs):
+        return ttk.Button(self.root, **kwargs)
+
+    def test_default(self):
+        widget = self.create()
+        self.checkEnumParam(widget, 'default', 'normal', 'active', 'disabled')
 
     def test_invoke(self):
         success = []
@@ -81,7 +231,27 @@
         self.assertTrue(success)
 
 
-class CheckbuttonTest(unittest.TestCase):
+@add_standard_options(StandardTtkOptionsTests)
+class CheckbuttonTest(AbstractLabelTest, unittest.TestCase):
+    OPTIONS = (
+        'class', 'command', 'compound', 'cursor',
+        'image',
+        'offvalue', 'onvalue',
+        'state', 'style',
+        'takefocus', 'text', 'textvariable',
+        'underline', 'variable', 'width',
+    )
+
+    def _create(self, **kwargs):
+        return ttk.Checkbutton(self.root, **kwargs)
+
+    def test_offvalue(self):
+        widget = self.create()
+        self.checkParams(widget, 'offvalue', 1, 2.3, '', 'any string')
+
+    def test_onvalue(self):
+        widget = self.create()
+        self.checkParams(widget, 'onvalue', 1, 2.3, '', 'any string')
 
     def test_invoke(self):
         success = []
@@ -104,21 +274,40 @@
 
         cbtn['command'] = ''
         res = cbtn.invoke()
-        self.assertEqual(str(res), '')
-        self.assertFalse(len(success) > 1)
+        self.assertFalse(str(res))
+        self.assertLessEqual(len(success), 1)
         self.assertEqual(cbtn['offvalue'],
             cbtn.tk.globalgetvar(cbtn['variable']))
 
 
-class ComboboxTest(unittest.TestCase):
+@add_standard_options(IntegerSizeTests, StandardTtkOptionsTests)
+class ComboboxTest(AbstractWidgetTest, unittest.TestCase):
+    OPTIONS = (
+        'class', 'cursor', 'exportselection', 'height',
+        'justify', 'postcommand', 'state', 'style',
+        'takefocus', 'textvariable', 'values', 'width',
+    )
 
     def setUp(self):
+        super(ComboboxTest, self).setUp()
         support.root_deiconify()
-        self.combo = ttk.Combobox()
+        self.combo = self.create()
 
     def tearDown(self):
         self.combo.destroy()
         support.root_withdraw()
+        super(ComboboxTest, self).tearDown()
+
+    def _create(self, **kwargs):
+        return ttk.Combobox(self.root, **kwargs)
+
+    def test_height(self):
+        widget = self.create()
+        self.checkParams(widget, 'height', 100, 101.2, 102.6, -100, 0, '1i')
+
+    def test_state(self):
+        widget = self.create()
+        self.checkParams(widget, 'state', 'active', 'disabled', 'normal')
 
     def _show_drop_down_listbox(self):
         width = self.combo.winfo_width()
@@ -166,8 +355,16 @@
             self.assertEqual(self.combo.get(), getval)
             self.assertEqual(self.combo.current(), currval)
 
+        self.assertEqual(self.combo['values'],
+                         () if tcl_version < (8, 5) else '')
         check_get_current('', -1)
 
+        self.checkParam(self.combo, 'values', 'mon tue wed thur',
+                        expected=('mon', 'tue', 'wed', 'thur'))
+        self.checkParam(self.combo, 'values', ('mon', 'tue', 'wed', 'thur'))
+        self.checkParam(self.combo, 'values', (42, 3.14, '', 'any string'))
+        self.checkParam(self.combo, 'values', () if tcl_version < (8, 5) else '')
+
         self.combo['values'] = ['a', 1, 'c']
 
         self.combo.set('c')
@@ -186,15 +383,21 @@
 
         # testing values with empty string set through configure
         self.combo.configure(values=[1, '', 2])
-        self.assertEqual(self.combo['values'], ('1', '', '2'))
+        self.assertEqual(self.combo['values'],
+                         ('1', '', '2') if self.wantobjects else
+                         '1 {} 2')
 
         # testing values with spaces
         self.combo['values'] = ['a b', 'a\tb', 'a\nb']
-        self.assertEqual(self.combo['values'], ('a b', 'a\tb', 'a\nb'))
+        self.assertEqual(self.combo['values'],
+                         ('a b', 'a\tb', 'a\nb') if self.wantobjects else
+                         '{a b} {a\tb} {a\nb}')
 
         # testing values with special characters
         self.combo['values'] = [r'a\tb', '"a"', '} {']
-        self.assertEqual(self.combo['values'], (r'a\tb', '"a"', '} {'))
+        self.assertEqual(self.combo['values'],
+                         (r'a\tb', '"a"', '} {') if self.wantobjects else
+                         r'a\\tb {"a"} \}\ \{')
 
         # out of range
         self.assertRaises(Tkinter.TclError, self.combo.current,
@@ -204,25 +407,63 @@
 
         # testing creating combobox with empty string in values
         combo2 = ttk.Combobox(values=[1, 2, ''])
-        self.assertEqual(combo2['values'], ('1', '2', ''))
+        self.assertEqual(combo2['values'],
+                         ('1', '2', '') if self.wantobjects else '1 2 {}')
         combo2.destroy()
 
 
-class EntryTest(unittest.TestCase):
+@add_standard_options(IntegerSizeTests, StandardTtkOptionsTests)
+class EntryTest(AbstractWidgetTest, unittest.TestCase):
+    OPTIONS = (
+        'background', 'class', 'cursor',
+        'exportselection', 'font',
+        'invalidcommand', 'justify',
+        'show', 'state', 'style', 'takefocus', 'textvariable',
+        'validate', 'validatecommand', 'width', 'xscrollcommand',
+    )
 
     def setUp(self):
+        super(EntryTest, self).setUp()
         support.root_deiconify()
-        self.entry = ttk.Entry()
+        self.entry = self.create()
 
     def tearDown(self):
         self.entry.destroy()
         support.root_withdraw()
+        super(EntryTest, self).tearDown()
+
+    def _create(self, **kwargs):
+        return ttk.Entry(self.root, **kwargs)
+
+    def test_invalidcommand(self):
+        widget = self.create()
+        self.checkCommandParam(widget, 'invalidcommand')
+
+    def test_show(self):
+        widget = self.create()
+        self.checkParam(widget, 'show', '*')
+        self.checkParam(widget, 'show', '')
+        self.checkParam(widget, 'show', ' ')
+
+    def test_state(self):
+        widget = self.create()
+        self.checkParams(widget, 'state',
+                         'disabled', 'normal', 'readonly')
+
+    def test_validate(self):
+        widget = self.create()
+        self.checkEnumParam(widget, 'validate',
+                'all', 'key', 'focus', 'focusin', 'focusout', 'none')
+
+    def test_validatecommand(self):
+        widget = self.create()
+        self.checkCommandParam(widget, 'validatecommand')
 
 
     def test_bbox(self):
         self.assertEqual(len(self.entry.bbox(0)), 4)
         for item in self.entry.bbox(0):
-            self.assertTrue(isinstance(item, int))
+            self.assertIsInstance(item, int)
 
         self.assertRaises(Tkinter.TclError, self.entry.bbox, 'noindex')
         self.assertRaises(Tkinter.TclError, self.entry.bbox, None)
@@ -312,16 +553,36 @@
         self.assertEqual(self.entry.state(), ())
 
 
-class PanedwindowTest(unittest.TestCase):
+@add_standard_options(IntegerSizeTests, StandardTtkOptionsTests)
+class PanedWindowTest(AbstractWidgetTest, unittest.TestCase):
+    OPTIONS = (
+        'class', 'cursor', 'height',
+        'orient', 'style', 'takefocus', 'width',
+    )
 
     def setUp(self):
+        super(PanedWindowTest, self).setUp()
         support.root_deiconify()
-        self.paned = ttk.Panedwindow()
+        self.paned = self.create()
 
     def tearDown(self):
         self.paned.destroy()
         support.root_withdraw()
+        super(PanedWindowTest, self).tearDown()
 
+    def _create(self, **kwargs):
+        return ttk.PanedWindow(self.root, **kwargs)
+
+    def test_orient(self):
+        widget = self.create()
+        self.assertEqual(str(widget['orient']), 'vertical')
+        errmsg='attempt to change read-only option'
+        if get_tk_patchlevel() < (8, 6, 0): # actually this was changen in 8.6b3
+            errmsg='Attempt to change read-only option'
+        self.checkInvalidParam(widget, 'orient', 'horizontal',
+                errmsg=errmsg)
+        widget2 = self.create(orient='horizontal')
+        self.assertEqual(str(widget2['orient']), 'horizontal')
 
     def test_add(self):
         # attempt to add a child that is not a direct child of the paned window
@@ -400,10 +661,12 @@
 
         child = ttk.Label()
         self.paned.add(child)
-        self.assertTrue(isinstance(self.paned.pane(0), dict))
-        self.assertEqual(self.paned.pane(0, weight=None), 0)
+        self.assertIsInstance(self.paned.pane(0), dict)
+        self.assertEqual(self.paned.pane(0, weight=None),
+                         0 if self.wantobjects else '0')
         # newer form for querying a single option
-        self.assertEqual(self.paned.pane(0, 'weight'), 0)
+        self.assertEqual(self.paned.pane(0, 'weight'),
+                         0 if self.wantobjects else '0')
         self.assertEqual(self.paned.pane(0), self.paned.pane(str(child)))
 
         self.assertRaises(Tkinter.TclError, self.paned.pane, 0,
@@ -427,11 +690,26 @@
 
         curr_pos = self.paned.sashpos(0)
         self.paned.sashpos(0, 1000)
-        self.assertTrue(curr_pos != self.paned.sashpos(0))
-        self.assertTrue(isinstance(self.paned.sashpos(0), int))
+        self.assertNotEqual(curr_pos, self.paned.sashpos(0))
+        self.assertIsInstance(self.paned.sashpos(0), int)
 
 
-class RadiobuttonTest(unittest.TestCase):
+@add_standard_options(StandardTtkOptionsTests)
+class RadiobuttonTest(AbstractLabelTest, unittest.TestCase):
+    OPTIONS = (
+        'class', 'command', 'compound', 'cursor',
+        'image',
+        'state', 'style',
+        'takefocus', 'text', 'textvariable',
+        'underline', 'value', 'variable', 'width',
+    )
+
+    def _create(self, **kwargs):
+        return ttk.Radiobutton(self.root, **kwargs)
+
+    def test_value(self):
+        widget = self.create()
+        self.checkParams(widget, 'value', 1, 2.3, '', 'any string')
 
     def test_invoke(self):
         success = []
@@ -443,37 +721,91 @@
         cbtn = ttk.Radiobutton(command=cb_test, variable=myvar, value=0)
         cbtn2 = ttk.Radiobutton(command=cb_test, variable=myvar, value=1)
 
+        if self.wantobjects:
+            conv = lambda x: x
+        else:
+            conv = int
+
         res = cbtn.invoke()
         self.assertEqual(res, "cb test called")
-        self.assertEqual(cbtn['value'], myvar.get())
+        self.assertEqual(conv(cbtn['value']), myvar.get())
         self.assertEqual(myvar.get(),
-            cbtn.tk.globalgetvar(cbtn['variable']))
+            conv(cbtn.tk.globalgetvar(cbtn['variable'])))
         self.assertTrue(success)
 
         cbtn2['command'] = ''
         res = cbtn2.invoke()
         self.assertEqual(str(res), '')
-        self.assertFalse(len(success) > 1)
-        self.assertEqual(cbtn2['value'], myvar.get())
+        self.assertLessEqual(len(success), 1)
+        self.assertEqual(conv(cbtn2['value']), myvar.get())
         self.assertEqual(myvar.get(),
-            cbtn.tk.globalgetvar(cbtn['variable']))
+            conv(cbtn.tk.globalgetvar(cbtn['variable'])))
 
         self.assertEqual(str(cbtn['variable']), str(cbtn2['variable']))
 
 
+class MenubuttonTest(AbstractLabelTest, unittest.TestCase):
+    OPTIONS = (
+        'class', 'compound', 'cursor', 'direction',
+        'image', 'menu', 'state', 'style',
+        'takefocus', 'text', 'textvariable',
+        'underline', 'width',
+    )
 
-class ScaleTest(unittest.TestCase):
+    def _create(self, **kwargs):
+        return ttk.Menubutton(self.root, **kwargs)
+
+    def test_direction(self):
+        widget = self.create()
+        self.checkEnumParam(widget, 'direction',
+                'above', 'below', 'left', 'right', 'flush')
+
+    def test_menu(self):
+        widget = self.create()
+        menu = Tkinter.Menu(widget, name='menu')
+        self.checkParam(widget, 'menu', menu, conv=str)
+        menu.destroy()
+
+
+@add_standard_options(StandardTtkOptionsTests)
+class ScaleTest(AbstractWidgetTest, unittest.TestCase):
+    OPTIONS = (
+        'class', 'command', 'cursor', 'from', 'length',
+        'orient', 'style', 'takefocus', 'to', 'value', 'variable',
+    )
+    _conv_pixels = noconv_meth
+    default_orient = 'horizontal'
 
     def setUp(self):
+        super(ScaleTest, self).setUp()
         support.root_deiconify()
-        self.scale = ttk.Scale()
+        self.scale = self.create()
         self.scale.pack()
         self.scale.update()
 
     def tearDown(self):
         self.scale.destroy()
         support.root_withdraw()
+        super(ScaleTest, self).tearDown()
 
+    def _create(self, **kwargs):
+        return ttk.Scale(self.root, **kwargs)
+
+    def test_from(self):
+        widget = self.create()
+        self.checkFloatParam(widget, 'from', 100, 14.9, 15.1, conv=False)
+
+    def test_length(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'length', 130, 131.2, 135.6, '5i')
+
+    def test_to(self):
+        widget = self.create()
+        self.checkFloatParam(widget, 'to', 300, 14.9, 15.1, -10, conv=False)
+
+    def test_value(self):
+        widget = self.create()
+        self.checkFloatParam(widget, 'value', 300, 14.9, 15.1, -10, conv=False)
 
     def test_custom_event(self):
         failure = [1, 1, 1] # will need to be empty
@@ -495,10 +827,15 @@
 
 
     def test_get(self):
+        if self.wantobjects:
+            conv = lambda x: x
+        else:
+            conv = float
+
         scale_width = self.scale.winfo_width()
         self.assertEqual(self.scale.get(scale_width, 0), self.scale['to'])
 
-        self.assertEqual(self.scale.get(0, 0), self.scale['from'])
+        self.assertEqual(conv(self.scale.get(0, 0)), conv(self.scale['from']))
         self.assertEqual(self.scale.get(), self.scale['value'])
         self.scale['value'] = 30
         self.assertEqual(self.scale.get(), self.scale['value'])
@@ -508,41 +845,99 @@
 
 
     def test_set(self):
+        if self.wantobjects:
+            conv = lambda x: x
+        else:
+            conv = float
+
         # set restricts the max/min values according to the current range
-        max = self.scale['to']
+        max = conv(self.scale['to'])
         new_max = max + 10
         self.scale.set(new_max)
-        self.assertEqual(self.scale.get(), max)
-        min = self.scale['from']
+        self.assertEqual(conv(self.scale.get()), max)
+        min = conv(self.scale['from'])
         self.scale.set(min - 1)
-        self.assertEqual(self.scale.get(), min)
+        self.assertEqual(conv(self.scale.get()), min)
 
         # changing directly the variable doesn't impose this limitation tho
         var = Tkinter.DoubleVar()
         self.scale['variable'] = var
         var.set(max + 5)
-        self.assertEqual(self.scale.get(), var.get())
-        self.assertEqual(self.scale.get(), max + 5)
+        self.assertEqual(conv(self.scale.get()), var.get())
+        self.assertEqual(conv(self.scale.get()), max + 5)
         del var
 
         # the same happens with the value option
         self.scale['value'] = max + 10
-        self.assertEqual(self.scale.get(), max + 10)
-        self.assertEqual(self.scale.get(), self.scale['value'])
+        self.assertEqual(conv(self.scale.get()), max + 10)
+        self.assertEqual(conv(self.scale.get()), conv(self.scale['value']))
 
         # nevertheless, note that the max/min values we can get specifying
         # x, y coords are the ones according to the current range
-        self.assertEqual(self.scale.get(0, 0), min)
-        self.assertEqual(self.scale.get(self.scale.winfo_width(), 0), max)
+        self.assertEqual(conv(self.scale.get(0, 0)), min)
+        self.assertEqual(conv(self.scale.get(self.scale.winfo_width(), 0)), max)
 
         self.assertRaises(Tkinter.TclError, self.scale.set, None)
 
 
-class NotebookTest(unittest.TestCase):
+@add_standard_options(StandardTtkOptionsTests)
+class ProgressbarTest(AbstractWidgetTest, unittest.TestCase):
+    OPTIONS = (
+        'class', 'cursor', 'orient', 'length',
+        'mode', 'maximum', 'phase',
+        'style', 'takefocus', 'value', 'variable',
+    )
+    _conv_pixels = noconv_meth
+    default_orient = 'horizontal'
+
+    def _create(self, **kwargs):
+        return ttk.Progressbar(self.root, **kwargs)
+
+    def test_length(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'length', 100.1, 56.7, '2i')
+
+    def test_maximum(self):
+        widget = self.create()
+        self.checkFloatParam(widget, 'maximum', 150.2, 77.7, 0, -10, conv=False)
+
+    def test_mode(self):
+        widget = self.create()
+        self.checkEnumParam(widget, 'mode', 'determinate', 'indeterminate')
+
+    def test_phase(self):
+        # XXX
+        pass
+
+    def test_value(self):
+        widget = self.create()
+        self.checkFloatParam(widget, 'value', 150.2, 77.7, 0, -10,
+                             conv=False)
+
+
+@unittest.skipIf(sys.platform == 'darwin',
+                 'ttk.Scrollbar is special on MacOSX')
+@add_standard_options(StandardTtkOptionsTests)
+class ScrollbarTest(AbstractWidgetTest, unittest.TestCase):
+    OPTIONS = (
+        'class', 'command', 'cursor', 'orient', 'style', 'takefocus',
+    )
+    default_orient = 'vertical'
+
+    def _create(self, **kwargs):
+        return ttk.Scrollbar(self.root, **kwargs)
+
+
+@add_standard_options(IntegerSizeTests, StandardTtkOptionsTests)
+class NotebookTest(AbstractWidgetTest, unittest.TestCase):
+    OPTIONS = (
+        'class', 'cursor', 'height', 'padding', 'style', 'takefocus',
+    )
 
     def setUp(self):
+        super(NotebookTest, self).setUp()
         support.root_deiconify()
-        self.nb = ttk.Notebook(padding=0)
+        self.nb = self.create(padding=0)
         self.child1 = ttk.Label()
         self.child2 = ttk.Label()
         self.nb.add(self.child1, text='a')
@@ -553,7 +948,10 @@
         self.child2.destroy()
         self.nb.destroy()
         support.root_withdraw()
+        super(NotebookTest, self).tearDown()
 
+    def _create(self, **kwargs):
+        return ttk.Notebook(self.root, **kwargs)
 
     def test_tab_identifiers(self):
         self.nb.forget(0)
@@ -610,7 +1008,7 @@
         self.nb.add(self.child2)
         self.assertEqual(self.nb.tabs(), tabs)
         self.assertEqual(self.nb.index(self.child2), child2_index)
-        self.assertTrue(str(self.child2) == self.nb.tabs()[child2_index])
+        self.assertEqual(str(self.child2), self.nb.tabs()[child2_index])
         # but the tab next to it (not hidden) is the one selected now
         self.assertEqual(self.nb.index('current'), curr + 1)
 
@@ -623,19 +1021,19 @@
         tabs = self.nb.tabs()
         child1_index = self.nb.index(self.child1)
         self.nb.forget(self.child1)
-        self.assertFalse(str(self.child1) in self.nb.tabs())
+        self.assertNotIn(str(self.child1), self.nb.tabs())
         self.assertEqual(len(tabs) - 1, len(self.nb.tabs()))
 
         self.nb.add(self.child1)
         self.assertEqual(self.nb.index(self.child1), 1)
-        self.assertFalse(child1_index == self.nb.index(self.child1))
+        self.assertNotEqual(child1_index, self.nb.index(self.child1))
 
 
     def test_index(self):
         self.assertRaises(Tkinter.TclError, self.nb.index, -1)
         self.assertRaises(Tkinter.TclError, self.nb.index, None)
 
-        self.assertTrue(isinstance(self.nb.index('end'), int))
+        self.assertIsInstance(self.nb.index('end'), int)
         self.assertEqual(self.nb.index(self.child1), 0)
         self.assertEqual(self.nb.index(self.child2), 1)
         self.assertEqual(self.nb.index('end'), 2)
@@ -699,7 +1097,7 @@
         self.assertRaises(Tkinter.TclError, self.nb.tab, 'notab')
         self.assertRaises(Tkinter.TclError, self.nb.tab, None)
 
-        self.assertTrue(isinstance(self.nb.tab(self.child1), dict))
+        self.assertIsInstance(self.nb.tab(self.child1), dict)
         self.assertEqual(self.nb.tab(self.child1, text=None), 'a')
         # newer form for querying a single option
         self.assertEqual(self.nb.tab(self.child1, 'text'), 'a')
@@ -745,16 +1143,68 @@
         self.assertEqual(self.nb.select(), str(self.child1))
 
 
-class TreeviewTest(unittest.TestCase):
+@add_standard_options(StandardTtkOptionsTests)
+class TreeviewTest(AbstractWidgetTest, unittest.TestCase):
+    OPTIONS = (
+        'class', 'columns', 'cursor', 'displaycolumns',
+        'height', 'padding', 'selectmode', 'show',
+        'style', 'takefocus', 'xscrollcommand', 'yscrollcommand',
+    )
 
     def setUp(self):
+        super(TreeviewTest, self).setUp()
         support.root_deiconify()
-        self.tv = ttk.Treeview(padding=0)
+        self.tv = self.create(padding=0)
 
     def tearDown(self):
         self.tv.destroy()
         support.root_withdraw()
+        super(TreeviewTest, self).tearDown()
 
+    def _create(self, **kwargs):
+        return ttk.Treeview(self.root, **kwargs)
+
+    def test_columns(self):
+        widget = self.create()
+        self.checkParam(widget, 'columns', 'a b c',
+                        expected=('a', 'b', 'c'))
+        self.checkParam(widget, 'columns', ('a', 'b', 'c'))
+        self.checkParam(widget, 'columns', () if tcl_version < (8, 5) else '')
+
+    def test_displaycolumns(self):
+        widget = self.create()
+        widget['columns'] = ('a', 'b', 'c')
+        self.checkParam(widget, 'displaycolumns', 'b a c',
+                        expected=('b', 'a', 'c'))
+        self.checkParam(widget, 'displaycolumns', ('b', 'a', 'c'))
+        self.checkParam(widget, 'displaycolumns', '#all',
+                        expected=('#all',))
+        self.checkParam(widget, 'displaycolumns', (2, 1, 0))
+        self.checkInvalidParam(widget, 'displaycolumns', ('a', 'b', 'd'),
+                               errmsg='Invalid column index d')
+        self.checkInvalidParam(widget, 'displaycolumns', (1, 2, 3),
+                               errmsg='Column index 3 out of bounds')
+        self.checkInvalidParam(widget, 'displaycolumns', (1, -2),
+                               errmsg='Column index -2 out of bounds')
+
+    def test_height(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'height', 100, -100, 0, '3c', conv=False)
+        self.checkPixelsParam(widget, 'height', 101.2, 102.6, conv=noconv)
+
+    def test_selectmode(self):
+        widget = self.create()
+        self.checkEnumParam(widget, 'selectmode',
+                            'none', 'browse', 'extended')
+
+    def test_show(self):
+        widget = self.create()
+        self.checkParam(widget, 'show', 'tree headings',
+                        expected=('tree', 'headings'))
+        self.checkParam(widget, 'show', ('tree', 'headings'))
+        self.checkParam(widget, 'show', ('headings', 'tree'))
+        self.checkParam(widget, 'show', 'tree', expected=('tree',))
+        self.checkParam(widget, 'show', 'headings', expected=('headings',))
 
     def test_bbox(self):
         self.tv.pack()
@@ -768,7 +1218,7 @@
 
         bbox = self.tv.bbox(children[0])
         self.assertEqual(len(bbox), 4)
-        self.assertTrue(isinstance(bbox, tuple))
+        self.assertIsInstance(bbox, tuple)
         for item in bbox:
             if not isinstance(item, int):
                 self.fail("Invalid bounding box: %s" % bbox)
@@ -779,6 +1229,8 @@
         self.tv.column('test', width=50)
         bbox_column0 = self.tv.bbox(children[0], 0)
         root_width = self.tv.column('#0', width=None)
+        if not self.wantobjects:
+            root_width = int(root_width)
         self.assertEqual(bbox_column0[0], bbox[0] + root_width)
 
         # verify that bbox of a closed item is the empty string
@@ -791,7 +1243,7 @@
         self.assertEqual(self.tv.get_children(), ())
 
         item_id = self.tv.insert('', 'end')
-        self.assertTrue(isinstance(self.tv.get_children(), tuple))
+        self.assertIsInstance(self.tv.get_children(), tuple)
         self.assertEqual(self.tv.get_children()[0], item_id)
 
         # add item_id and child3 as children of child2
@@ -816,14 +1268,17 @@
 
     def test_column(self):
         # return a dict with all options/values
-        self.assertTrue(isinstance(self.tv.column('#0'), dict))
+        self.assertIsInstance(self.tv.column('#0'), dict)
         # return a single value of the given option
-        self.assertTrue(isinstance(self.tv.column('#0', width=None), int))
+        if self.wantobjects:
+            self.assertIsInstance(self.tv.column('#0', width=None), int)
         # set a new value for an option
         self.tv.column('#0', width=10)
         # testing new way to get option value
-        self.assertEqual(self.tv.column('#0', 'width'), 10)
-        self.assertEqual(self.tv.column('#0', width=None), 10)
+        self.assertEqual(self.tv.column('#0', 'width'),
+                         10 if self.wantobjects else '10')
+        self.assertEqual(self.tv.column('#0', width=None),
+                         10 if self.wantobjects else '10')
         # check read-only option
         self.assertRaises(Tkinter.TclError, self.tv.column, '#0', id='X')
 
@@ -931,7 +1386,7 @@
 
     def test_heading(self):
         # check a dict is returned
-        self.assertTrue(isinstance(self.tv.heading('#0'), dict))
+        self.assertIsInstance(self.tv.heading('#0'), dict)
 
         # check a value is returned
         self.tv.heading('#0', text='hi')
@@ -945,12 +1400,10 @@
         self.assertRaises(Tkinter.TclError, self.tv.heading, '#0',
             anchor=1)
 
-    # XXX skipping for now; should be fixed to work with newer ttk
-    @unittest.skip("skipping pending resolution of Issue #10734")
     def test_heading_callback(self):
         def simulate_heading_click(x, y):
             support.simulate_mouse_click(self.tv, x, y)
-            self.tv.update_idletasks()
+            self.tv.update()
 
         success = [] # no success for now
 
@@ -1038,13 +1491,16 @@
         # unicode values
         value = u'\xe1ba'
         item = self.tv.insert('', 'end', values=(value, ))
-        self.assertEqual(self.tv.item(item, 'values'), (value, ))
-        self.assertEqual(self.tv.item(item, values=None), (value, ))
+        self.assertEqual(self.tv.item(item, 'values'),
+                         (value,) if self.wantobjects else value)
+        self.assertEqual(self.tv.item(item, values=None),
+                         (value,) if self.wantobjects else value)
 
-        self.tv.item(item, values=list(self.tv.item(item, values=None)))
-        self.assertEqual(self.tv.item(item, values=None), (value, ))
+        self.tv.item(item, values=self.root.splitlist(self.tv.item(item, values=None)))
+        self.assertEqual(self.tv.item(item, values=None),
+                         (value,) if self.wantobjects else value)
 
-        self.assertTrue(isinstance(self.tv.item(item), dict))
+        self.assertIsInstance(self.tv.item(item), dict)
 
         # erase item values
         self.tv.item(item, values='')
@@ -1052,17 +1508,21 @@
 
         # item tags
         item = self.tv.insert('', 'end', tags=[1, 2, value])
-        self.assertEqual(self.tv.item(item, tags=None), ('1', '2', value))
+        self.assertEqual(self.tv.item(item, tags=None),
+                         ('1', '2', value) if self.wantobjects else
+                         '1 2 %s' % value)
         self.tv.item(item, tags=[])
         self.assertFalse(self.tv.item(item, tags=None))
         self.tv.item(item, tags=(1, 2))
-        self.assertEqual(self.tv.item(item, tags=None), ('1', '2'))
+        self.assertEqual(self.tv.item(item, tags=None),
+                         ('1', '2') if self.wantobjects else '1 2')
 
         # values with spaces
         item = self.tv.insert('', 'end', values=('a b c',
             '%s %s' % (value, value)))
         self.assertEqual(self.tv.item(item, values=None),
-            ('a b c', '%s %s' % (value, value)))
+            ('a b c', '%s %s' % (value, value)) if self.wantobjects else
+            '{a b c} {%s %s}' % (value, value))
 
         # text
         self.assertEqual(self.tv.item(
@@ -1079,19 +1539,24 @@
         self.assertEqual(self.tv.set(item), {'A': 'a', 'B': 'b'})
 
         self.tv.set(item, 'B', 'a')
-        self.assertEqual(self.tv.item(item, values=None), ('a', 'a'))
+        self.assertEqual(self.tv.item(item, values=None),
+                         ('a', 'a') if self.wantobjects else 'a a')
 
         self.tv['columns'] = ['B']
         self.assertEqual(self.tv.set(item), {'B': 'a'})
 
         self.tv.set(item, 'B', 'b')
         self.assertEqual(self.tv.set(item, column='B'), 'b')
-        self.assertEqual(self.tv.item(item, values=None), ('b', 'a'))
+        self.assertEqual(self.tv.item(item, values=None),
+                         ('b', 'a') if self.wantobjects else 'b a')
 
         self.tv.set(item, 'B', 123)
-        self.assertEqual(self.tv.set(item, 'B'), 123)
-        self.assertEqual(self.tv.item(item, values=None), (123, 'a'))
-        self.assertEqual(self.tv.set(item), {'B': 123})
+        self.assertEqual(self.tv.set(item, 'B'),
+                         123 if self.wantobjects else '123')
+        self.assertEqual(self.tv.item(item, values=None),
+                         (123, 'a') if self.wantobjects else '123 a')
+        self.assertEqual(self.tv.set(item),
+                         {'B': 123} if self.wantobjects else {'B': '123'})
 
         # inexistent column
         self.assertRaises(Tkinter.TclError, self.tv.set, item, 'A')
@@ -1145,13 +1610,38 @@
             'blue')
         self.assertEqual(str(self.tv.tag_configure('test', foreground=None)),
             'blue')
-        self.assertTrue(isinstance(self.tv.tag_configure('test'), dict))
+        self.assertIsInstance(self.tv.tag_configure('test'), dict)
+
+
+@add_standard_options(StandardTtkOptionsTests)
+class SeparatorTest(AbstractWidgetTest, unittest.TestCase):
+    OPTIONS = (
+        'class', 'cursor', 'orient', 'style', 'takefocus',
+        # 'state'?
+    )
+    default_orient = 'horizontal'
+
+    def _create(self, **kwargs):
+        return ttk.Separator(self.root, **kwargs)
+
+
+@add_standard_options(StandardTtkOptionsTests)
+class SizegripTest(AbstractWidgetTest, unittest.TestCase):
+    OPTIONS = (
+        'class', 'cursor', 'style', 'takefocus',
+        # 'state'?
+    )
+
+    def _create(self, **kwargs):
+        return ttk.Sizegrip(self.root, **kwargs)
 
 
 tests_gui = (
-        WidgetTest, ButtonTest, CheckbuttonTest, RadiobuttonTest,
-        ComboboxTest, EntryTest, PanedwindowTest, ScaleTest, NotebookTest,
-        TreeviewTest
+        ButtonTest, CheckbuttonTest, ComboboxTest, EntryTest,
+        FrameTest, LabelFrameTest, LabelTest, MenubuttonTest,
+        NotebookTest, PanedWindowTest, ProgressbarTest,
+        RadiobuttonTest, ScaleTest, ScrollbarTest, SeparatorTest,
+        SizegripTest, TreeviewTest, WidgetTest,
         )
 
 if __name__ == "__main__":
diff -r 3a1db0d2747e Lib/lib-tk/test/widget_tests.py
--- /dev/null
+++ b/Lib/lib-tk/test/widget_tests.py
@@ -0,0 +1,520 @@
+# Common tests for test_tkinter/test_widgets.py and test_ttk/test_widgets.py
+
+import unittest
+import sys
+import Tkinter
+from ttk import setup_master, Scale
+from test_ttk.support import (tcl_version, requires_tcl, get_tk_patchlevel,
+                              pixels_conv, tcl_obj_eq)
+
+
+noconv = noconv_meth = False
+if get_tk_patchlevel() < (8, 5, 11):
+    noconv = str
+noconv_meth = noconv and staticmethod(noconv)
+
+def int_round(x):
+    return int(round(x))
+
+pixels_round = int_round
+if get_tk_patchlevel()[:3] == (8, 5, 11):
+    # Issue #19085: Workaround a bug in Tk
+    # http://core.tcl.tk/tk/info/3497848
+    pixels_round = int
+
+
+_sentinel = object()
+
+class AbstractWidgetTest(object):
+    _conv_pixels = staticmethod(pixels_round)
+    _conv_pad_pixels = None
+    wantobjects = True
+
+    def setUp(self):
+        self.root = setup_master()
+        self.scaling = float(self.root.call('tk', 'scaling'))
+        if not self.root.wantobjects():
+            self.wantobjects = False
+
+    def create(self, **kwargs):
+        widget = self._create(**kwargs)
+        self.addCleanup(widget.destroy)
+        return widget
+
+    def assertEqual2(self, actual, expected, msg=None, eq=object.__eq__):
+        if eq(actual, expected):
+            return
+        self.assertEqual(actual, expected, msg)
+
+    def checkParam(self, widget, name, value, expected=_sentinel,
+                   conv=False, eq=None):
+        widget[name] = value
+        if expected is _sentinel:
+            expected = value
+        if conv:
+            expected = conv(expected)
+        if not self.wantobjects:
+            if isinstance(expected, tuple):
+                expected = Tkinter._join(expected)
+            else:
+                expected = str(expected)
+        if eq is None:
+            eq = tcl_obj_eq
+        self.assertEqual2(widget[name], expected, eq=eq)
+        self.assertEqual2(widget.cget(name), expected, eq=eq)
+        # XXX
+        if not isinstance(widget, Scale):
+            t = widget.configure(name)
+            self.assertEqual(len(t), 5)
+            self.assertEqual2(t[4], expected, eq=eq)
+
+    def checkInvalidParam(self, widget, name, value, errmsg=None,
+                          keep_orig=True):
+        orig = widget[name]
+        if errmsg is not None:
+            errmsg = errmsg.format(value)
+        with self.assertRaises(Tkinter.TclError) as cm:
+            widget[name] = value
+        if errmsg is not None:
+            self.assertEqual(str(cm.exception), errmsg)
+        if keep_orig:
+            self.assertEqual(widget[name], orig)
+        else:
+            widget[name] = orig
+        with self.assertRaises(Tkinter.TclError) as cm:
+            widget.configure({name: value})
+        if errmsg is not None:
+            self.assertEqual(str(cm.exception), errmsg)
+        if keep_orig:
+            self.assertEqual(widget[name], orig)
+        else:
+            widget[name] = orig
+
+    def checkParams(self, widget, name, *values, **kwargs):
+        for value in values:
+            self.checkParam(widget, name, value, **kwargs)
+
+    def checkIntegerParam(self, widget, name, *values, **kwargs):
+        self.checkParams(widget, name, *values, **kwargs)
+        self.checkInvalidParam(widget, name, '',
+                errmsg='expected integer but got ""')
+        self.checkInvalidParam(widget, name, '10p',
+                errmsg='expected integer but got "10p"')
+        self.checkInvalidParam(widget, name, 3.2,
+                errmsg='expected integer but got "3.2"')
+
+    def checkFloatParam(self, widget, name, *values, **kwargs):
+        if 'conv' in kwargs:
+            conv = kwargs.pop('conv')
+        else:
+            conv = float
+        for value in values:
+            self.checkParam(widget, name, value, conv=conv, **kwargs)
+        self.checkInvalidParam(widget, name, '',
+                errmsg='expected floating-point number but got ""')
+        self.checkInvalidParam(widget, name, 'spam',
+                errmsg='expected floating-point number but got "spam"')
+
+    def checkBooleanParam(self, widget, name):
+        for value in (False, 0, 'false', 'no', 'off'):
+            self.checkParam(widget, name, value, expected=0)
+        for value in (True, 1, 'true', 'yes', 'on'):
+            self.checkParam(widget, name, value, expected=1)
+        self.checkInvalidParam(widget, name, '',
+                errmsg='expected boolean value but got ""')
+        self.checkInvalidParam(widget, name, 'spam',
+                errmsg='expected boolean value but got "spam"')
+
+    def checkColorParam(self, widget, name, allow_empty=None, **kwargs):
+        self.checkParams(widget, name,
+                         '#ff0000', '#00ff00', '#0000ff', '#123456',
+                         'red', 'green', 'blue', 'white', 'black', 'grey',
+                         **kwargs)
+        self.checkInvalidParam(widget, name, 'spam',
+                errmsg='unknown color name "spam"')
+
+    def checkCursorParam(self, widget, name, **kwargs):
+        self.checkParams(widget, name, 'arrow', 'watch', 'cross', '',**kwargs)
+        if tcl_version >= (8, 5):
+            self.checkParam(widget, name, 'none')
+        self.checkInvalidParam(widget, name, 'spam',
+                errmsg='bad cursor spec "spam"')
+
+    def checkCommandParam(self, widget, name):
+        def command(*args):
+            pass
+        widget[name] = command
+        self.assertTrue(widget[name])
+        self.checkParams(widget, name, '')
+
+    def checkEnumParam(self, widget, name, *values, **kwargs):
+        if 'errmsg' in kwargs:
+            errmsg = kwargs.pop('errmsg')
+        else:
+            errmsg = None
+        self.checkParams(widget, name, *values, **kwargs)
+        if errmsg is None:
+            errmsg2 = ' %s "{}": must be %s%s or %s' % (
+                    name,
+                    ', '.join(values[:-1]),
+                    ',' if len(values) > 2 else '',
+                    values[-1])
+            self.checkInvalidParam(widget, name, '',
+                                   errmsg='ambiguous' + errmsg2)
+            errmsg = 'bad' + errmsg2
+        self.checkInvalidParam(widget, name, 'spam', errmsg=errmsg)
+
+    def checkPixelsParam(self, widget, name, *values, **kwargs):
+        if 'conv' in kwargs:
+            conv = kwargs.pop('conv')
+        else:
+            conv = None
+        if conv is None:
+            conv = self._conv_pixels
+        if 'keep_orig' in kwargs:
+            keep_orig = kwargs.pop('keep_orig')
+        else:
+            keep_orig = True
+        for value in values:
+            expected = _sentinel
+            conv1 = conv
+            if isinstance(value, str):
+                if conv1 and conv1 is not str:
+                    expected = pixels_conv(value) * self.scaling
+                    conv1 = int_round
+            self.checkParam(widget, name, value, expected=expected,
+                            conv=conv1, **kwargs)
+        self.checkInvalidParam(widget, name, '6x',
+                errmsg='bad screen distance "6x"', keep_orig=keep_orig)
+        self.checkInvalidParam(widget, name, 'spam',
+                errmsg='bad screen distance "spam"', keep_orig=keep_orig)
+
+    def checkReliefParam(self, widget, name):
+        self.checkParams(widget, name,
+                         'flat', 'groove', 'raised', 'ridge', 'solid', 'sunken')
+        errmsg='bad relief "spam": must be '\
+               'flat, groove, raised, ridge, solid, or sunken'
+        if tcl_version < (8, 6):
+            errmsg = None
+        self.checkInvalidParam(widget, name, 'spam',
+                errmsg=errmsg)
+
+    def checkImageParam(self, widget, name):
+        image = Tkinter.PhotoImage('image1')
+        self.checkParam(widget, name, image, conv=str)
+        self.checkInvalidParam(widget, name, 'spam',
+                errmsg='image "spam" doesn\'t exist')
+        widget[name] = ''
+
+    def checkVariableParam(self, widget, name, var):
+        self.checkParam(widget, name, var, conv=str)
+
+
+class StandardOptionsTests(object):
+    STANDARD_OPTIONS = (
+        'activebackground', 'activeborderwidth', 'activeforeground', 'anchor',
+        'background', 'bitmap', 'borderwidth', 'compound', 'cursor',
+        'disabledforeground', 'exportselection', 'font', 'foreground',
+        'highlightbackground', 'highlightcolor', 'highlightthickness',
+        'image', 'insertbackground', 'insertborderwidth',
+        'insertofftime', 'insertontime', 'insertwidth',
+        'jump', 'justify', 'orient', 'padx', 'pady', 'relief',
+        'repeatdelay', 'repeatinterval',
+        'selectbackground', 'selectborderwidth', 'selectforeground',
+        'setgrid', 'takefocus', 'text', 'textvariable', 'troughcolor',
+        'underline', 'wraplength', 'xscrollcommand', 'yscrollcommand',
+    )
+
+    def test_activebackground(self):
+        widget = self.create()
+        self.checkColorParam(widget, 'activebackground')
+
+    def test_activeborderwidth(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'activeborderwidth',
+                              0, 1.3, 2.9, 6, -2, '10p')
+
+    def test_activeforeground(self):
+        widget = self.create()
+        self.checkColorParam(widget, 'activeforeground')
+
+    def test_anchor(self):
+        widget = self.create()
+        self.checkEnumParam(widget, 'anchor',
+                'n', 'ne', 'e', 'se', 's', 'sw', 'w', 'nw', 'center')
+
+    def test_background(self):
+        widget = self.create()
+        self.checkColorParam(widget, 'background')
+        if 'bg' in self.OPTIONS:
+            self.checkColorParam(widget, 'bg')
+
+    def test_bitmap(self):
+        widget = self.create()
+        self.checkParam(widget, 'bitmap', 'questhead')
+        self.checkParam(widget, 'bitmap', 'gray50')
+        self.checkInvalidParam(widget, 'bitmap', 'spam',
+                errmsg='bitmap "spam" not defined')
+
+    def test_borderwidth(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'borderwidth',
+                              0, 1.3, 2.6, 6, -2, '10p')
+        if 'bd' in self.OPTIONS:
+            self.checkPixelsParam(widget, 'bd', 0, 1.3, 2.6, 6, -2, '10p')
+
+    def test_compound(self):
+        widget = self.create()
+        self.checkEnumParam(widget, 'compound',
+                'bottom', 'center', 'left', 'none', 'right', 'top')
+
+    def test_cursor(self):
+        widget = self.create()
+        self.checkCursorParam(widget, 'cursor')
+
+    def test_disabledforeground(self):
+        widget = self.create()
+        self.checkColorParam(widget, 'disabledforeground')
+
+    def test_exportselection(self):
+        widget = self.create()
+        self.checkBooleanParam(widget, 'exportselection')
+
+    def test_font(self):
+        widget = self.create()
+        self.checkParam(widget, 'font',
+                        '-Adobe-Helvetica-Medium-R-Normal--*-120-*-*-*-*-*-*')
+        self.checkInvalidParam(widget, 'font', '',
+                               errmsg='font "" doesn\'t exist')
+
+    def test_foreground(self):
+        widget = self.create()
+        self.checkColorParam(widget, 'foreground')
+        if 'fg' in self.OPTIONS:
+            self.checkColorParam(widget, 'fg')
+
+    def test_highlightbackground(self):
+        widget = self.create()
+        self.checkColorParam(widget, 'highlightbackground')
+
+    def test_highlightcolor(self):
+        widget = self.create()
+        self.checkColorParam(widget, 'highlightcolor')
+
+    def test_highlightthickness(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'highlightthickness',
+                              0, 1.3, 2.6, 6, '10p')
+        self.checkParam(widget, 'highlightthickness', -2, expected=0,
+                        conv=self._conv_pixels)
+
+    @unittest.skipIf(sys.platform == 'darwin',
+                     'crashes with Cocoa Tk (issue19733)')
+    def test_image(self):
+        widget = self.create()
+        self.checkImageParam(widget, 'image')
+
+    def test_insertbackground(self):
+        widget = self.create()
+        self.checkColorParam(widget, 'insertbackground')
+
+    def test_insertborderwidth(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'insertborderwidth',
+                              0, 1.3, 2.6, 6, -2, '10p')
+
+    def test_insertofftime(self):
+        widget = self.create()
+        self.checkIntegerParam(widget, 'insertofftime', 100)
+
+    def test_insertontime(self):
+        widget = self.create()
+        self.checkIntegerParam(widget, 'insertontime', 100)
+
+    def test_insertwidth(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'insertwidth', 1.3, 2.6, -2, '10p')
+
+    def test_jump(self):
+        widget = self.create()
+        self.checkBooleanParam(widget, 'jump')
+
+    def test_justify(self):
+        widget = self.create()
+        self.checkEnumParam(widget, 'justify', 'left', 'right', 'center',
+                errmsg='bad justification "{}": must be '
+                       'left, right, or center')
+        self.checkInvalidParam(widget, 'justify', '',
+                errmsg='ambiguous justification "": must be '
+                       'left, right, or center')
+
+    def test_orient(self):
+        widget = self.create()
+        self.assertEqual(str(widget['orient']), self.default_orient)
+        self.checkEnumParam(widget, 'orient', 'horizontal', 'vertical')
+
+    def test_padx(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'padx', 3, 4.4, 5.6, -2, '12m',
+                              conv=self._conv_pad_pixels)
+
+    def test_pady(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'pady', 3, 4.4, 5.6, -2, '12m',
+                              conv=self._conv_pad_pixels)
+
+    def test_relief(self):
+        widget = self.create()
+        self.checkReliefParam(widget, 'relief')
+
+    def test_repeatdelay(self):
+        widget = self.create()
+        self.checkIntegerParam(widget, 'repeatdelay', -500, 500)
+
+    def test_repeatinterval(self):
+        widget = self.create()
+        self.checkIntegerParam(widget, 'repeatinterval', -500, 500)
+
+    def test_selectbackground(self):
+        widget = self.create()
+        self.checkColorParam(widget, 'selectbackground')
+
+    def test_selectborderwidth(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'selectborderwidth', 1.3, 2.6, -2, '10p')
+
+    def test_selectforeground(self):
+        widget = self.create()
+        self.checkColorParam(widget, 'selectforeground')
+
+    def test_setgrid(self):
+        widget = self.create()
+        self.checkBooleanParam(widget, 'setgrid')
+
+    def test_state(self):
+        widget = self.create()
+        self.checkEnumParam(widget, 'state', 'active', 'disabled', 'normal')
+
+    def test_takefocus(self):
+        widget = self.create()
+        self.checkParams(widget, 'takefocus', '0', '1', '')
+
+    def test_text(self):
+        widget = self.create()
+        self.checkParams(widget, 'text', '', 'any string')
+
+    def test_textvariable(self):
+        widget = self.create()
+        var = Tkinter.StringVar()
+        self.checkVariableParam(widget, 'textvariable', var)
+
+    def test_troughcolor(self):
+        widget = self.create()
+        self.checkColorParam(widget, 'troughcolor')
+
+    def test_underline(self):
+        widget = self.create()
+        self.checkIntegerParam(widget, 'underline', 0, 1, 10)
+
+    def test_wraplength(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'wraplength', 100)
+
+    def test_xscrollcommand(self):
+        widget = self.create()
+        self.checkCommandParam(widget, 'xscrollcommand')
+
+    def test_yscrollcommand(self):
+        widget = self.create()
+        self.checkCommandParam(widget, 'yscrollcommand')
+
+    # non-standard but common options
+
+    def test_command(self):
+        widget = self.create()
+        self.checkCommandParam(widget, 'command')
+
+    def test_indicatoron(self):
+        widget = self.create()
+        self.checkBooleanParam(widget, 'indicatoron')
+
+    def test_offrelief(self):
+        widget = self.create()
+        self.checkReliefParam(widget, 'offrelief')
+
+    def test_overrelief(self):
+        widget = self.create()
+        self.checkReliefParam(widget, 'overrelief')
+
+    def test_selectcolor(self):
+        widget = self.create()
+        self.checkColorParam(widget, 'selectcolor')
+
+    def test_selectimage(self):
+        widget = self.create()
+        self.checkImageParam(widget, 'selectimage')
+
+    @requires_tcl(8, 5)
+    def test_tristateimage(self):
+        widget = self.create()
+        self.checkImageParam(widget, 'tristateimage')
+
+    @requires_tcl(8, 5)
+    def test_tristatevalue(self):
+        widget = self.create()
+        self.checkParam(widget, 'tristatevalue', 'unknowable')
+
+    def test_variable(self):
+        widget = self.create()
+        var = Tkinter.DoubleVar()
+        self.checkVariableParam(widget, 'variable', var)
+
+
+class IntegerSizeTests(object):
+    def test_height(self):
+        widget = self.create()
+        self.checkIntegerParam(widget, 'height', 100, -100, 0)
+
+    def test_width(self):
+        widget = self.create()
+        self.checkIntegerParam(widget, 'width', 402, -402, 0)
+
+
+class PixelSizeTests(object):
+    def test_height(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'height', 100, 101.2, 102.6, -100, 0, '3c')
+
+    def test_width(self):
+        widget = self.create()
+        self.checkPixelsParam(widget, 'width', 402, 403.4, 404.6, -402, 0, '5i')
+
+
+def add_standard_options(*source_classes):
+    # This decorator adds test_xxx methods from source classes for every xxx
+    # option in the OPTIONS class attribute if they are not defined explicitly.
+    def decorator(cls):
+        for option in cls.OPTIONS:
+            methodname = 'test_' + option
+            if not hasattr(cls, methodname):
+                for source_class in source_classes:
+                    if hasattr(source_class, methodname):
+                        setattr(cls, methodname,
+                                getattr(source_class, methodname).im_func)
+                        break
+                else:
+                    def test(self, option=option):
+                        widget = self.create()
+                        widget[option]
+                        raise AssertionError('Option "%s" is not tested in %s' %
+                                             (option, cls.__name__))
+                    test.__name__ = methodname
+                    setattr(cls, methodname, test)
+        return cls
+    return decorator
+
+def setUpModule():
+    import test.test_support
+    if test.test_support.verbose:
+        tcl = Tkinter.Tcl()
+        print 'patchlevel =', tcl.call('info', 'patchlevel')
diff -r 3a1db0d2747e Lib/lib-tk/ttk.py
--- a/Lib/lib-tk/ttk.py
+++ b/Lib/lib-tk/ttk.py
@@ -295,6 +295,9 @@
             indx += 2
 
             if opt == 'children':
+                if (Tkinter._default_root and
+                    not Tkinter._default_root.wantobjects()):
+                    val = Tkinter._default_root.splitlist(val)
                 val = _list_from_layouttuple(val)
 
             opts[opt] = val
@@ -315,6 +318,8 @@
     if len(options) % 2: # option specified without a value, return its value
         return res
 
+    if Tkinter._default_root:
+        res = Tkinter._default_root.splitlist(res)
     return _dict_from_tcltuple(res)
 
 def _convert_stringval(value):
@@ -327,6 +332,14 @@
 
     return value
 
+def _to_number(x):
+    if isinstance(x, str):
+        if '.' in x:
+            x = float(x)
+        else:
+            x = int(x)
+    return x
+
 def tclobjs_to_py(adict):
     """Returns adict with its values converted from Tcl objects to Python
     objects."""
@@ -397,8 +410,8 @@
         or something else of your preference. A statespec is compound of
         one or more states and then a value."""
         if query_opt is not None:
-            return _list_from_statespec(
-                self.tk.call(self._name, "map", style, '-%s' % query_opt))
+            return _list_from_statespec(self.tk.splitlist(
+                self.tk.call(self._name, "map", style, '-%s' % query_opt)))
 
         return _dict_from_tcltuple(
             self.tk.call(self._name, "map", style, *(_format_mapdict(kw))))
@@ -455,8 +468,8 @@
             lspec = "null" # could be any other word, but this may make sense
                            # when calling layout(style) later
 
-        return _list_from_layouttuple(
-            self.tk.call(self._name, "layout", style, lspec))
+        return _list_from_layouttuple(self.tk.splitlist(
+            self.tk.call(self._name, "layout", style, lspec)))
 
 
     def element_create(self, elementname, etype, *args, **kw):
@@ -468,12 +481,12 @@
 
     def element_names(self):
         """Returns the list of elements defined in the current theme."""
-        return self.tk.call(self._name, "element", "names")
+        return self.tk.splitlist(self.tk.call(self._name, "element", "names"))
 
 
     def element_options(self, elementname):
         """Return the list of elementname's options."""
-        return self.tk.call(self._name, "element", "options", elementname)
+        return self.tk.splitlist(self.tk.call(self._name, "element", "options", elementname))
 
 
     def theme_create(self, themename, parent=None, settings=None):
@@ -507,7 +520,7 @@
 
     def theme_names(self):
         """Returns a list of all known themes."""
-        return self.tk.call(self._name, "theme", "names")
+        return self.tk.splitlist(self.tk.call(self._name, "theme", "names"))
 
 
     def theme_use(self, themename=None):
@@ -570,7 +583,8 @@
         matches statespec and False otherwise. If callback is specified,
         then it will be invoked with *args, **kw if the widget state
         matches statespec. statespec is expected to be a sequence."""
-        ret = self.tk.call(self._w, "instate", ' '.join(statespec))
+        ret = self.tk.getboolean(
+                self.tk.call(self._w, "instate", ' '.join(statespec)))
         if ret and callback:
             return callback(*args, **kw)
 
@@ -669,7 +683,7 @@
     def bbox(self, index):
         """Return a tuple of (x, y, width, height) which describes the
         bounding box of the character given by index."""
-        return self.tk.call(self._w, "bbox", index)
+        return self._getints(self.tk.call(self._w, "bbox", index))
 
 
     def identify(self, x, y):
@@ -682,7 +696,7 @@
         """Force revalidation, independent of the conditions specified
         by the validate option. Returns False if validation fails, True
         if it succeeds. Sets or clears the invalid state accordingly."""
-        return bool(self.tk.call(self._w, "validate"))
+        return bool(self.tk.getboolean(self.tk.call(self._w, "validate")))
 
 
 class Combobox(Entry):
@@ -709,6 +723,8 @@
         element at position newindex in the list of values. Otherwise,
         returns the index of the current value in the list of values
         or -1 if the current value does not appear in the list."""
+        if newindex is None:
+            return self.tk.getint(self.tk.call(self._w, "current"))
         return self.tk.call(self._w, "current", newindex)
 
 
@@ -863,7 +879,7 @@
     def index(self, tab_id):
         """Returns the numeric index of the tab specified by tab_id, or
         the total number of tabs if tab_id is the string "end"."""
-        return self.tk.call(self._w, "index", tab_id)
+        return self.tk.getint(self.tk.call(self._w, "index", tab_id))
 
 
     def insert(self, pos, child, **kw):
@@ -898,7 +914,7 @@
 
     def tabs(self):
         """Returns a list of windows managed by the notebook."""
-        return self.tk.call(self._w, "tabs") or ()
+        return self.tk.splitlist(self.tk.call(self._w, "tabs") or ())
 
 
     def enable_traversal(self):
@@ -981,7 +997,7 @@
         constrained to be between 0 and the total size of the widget.
 
         Returns the new position of sash number index."""
-        return self.tk.call(self._w, "sashpos", index, newpos)
+        return self.tk.getint(self.tk.call(self._w, "sashpos", index, newpos))
 
 PanedWindow = Panedwindow # Tkinter name compatibility
 
@@ -1181,14 +1197,15 @@
         If column is specified, returns the bounding box of that cell.
         If the item is not visible (i.e., if it is a descendant of a
         closed item or is scrolled offscreen), returns an empty string."""
-        return self.tk.call(self._w, "bbox", item, column)
+        return self._getints(self.tk.call(self._w, "bbox", item, column)) or ''
 
 
     def get_children(self, item=None):
         """Returns a tuple of children belonging to item.
 
         If item is not specified, returns root children."""
-        return self.tk.call(self._w, "children", item or '') or ()
+        return self.tk.splitlist(
+                self.tk.call(self._w, "children", item or '') or ())
 
 
     def set_children(self, item, *newchildren):
@@ -1229,7 +1246,7 @@
     def exists(self, item):
         """Returns True if the specified item is present in the tree,
         False otherwise."""
-        return bool(self.tk.call(self._w, "exists", item))
+        return bool(self.tk.getboolean(self.tk.call(self._w, "exists", item)))
 
 
     def focus(self, item=None):
@@ -1311,7 +1328,7 @@
     def index(self, item):
         """Returns the integer index of item within its parent's list
         of children."""
-        return self.tk.call(self._w, "index", item)
+        return self.tk.getint(self.tk.call(self._w, "index", item))
 
 
     def insert(self, parent, index, iid=None, **kw):
@@ -1420,7 +1437,7 @@
         value of given column in given item to the specified value."""
         res = self.tk.call(self._w, "set", item, column, value)
         if column is None and value is None:
-            return _dict_from_tcltuple(res, False)
+            return _dict_from_tcltuple(self.tk.splitlist(res), False)
         else:
             return res
 
@@ -1451,7 +1468,8 @@
         all items which have the specified tag.
 
         * Availability: Tk 8.6"""
-        return self.tk.call(self._w, "tag", "has", tagname, item)
+        return self.tk.getboolean(
+                self.tk.call(self._w, "tag", "has", tagname, item))
 
 
 # Extensions
@@ -1523,7 +1541,8 @@
 
             self.label.place_configure(x=x, y=y)
 
-        from_, to = self.scale['from'], self.scale['to']
+        from_ = _to_number(self.scale['from'])
+        to = _to_number(self.scale['to'])
         if to < from_:
             from_, to = to, from_
         newval = self._variable.get()
diff -r 3a1db0d2747e Lib/lib2to3/fixes/fix_import.py
--- a/Lib/lib2to3/fixes/fix_import.py
+++ b/Lib/lib2to3/fixes/fix_import.py
@@ -32,7 +32,7 @@
         elif node.type == syms.dotted_as_names:
             pending.extend(node.children[::-2])
         else:
-            raise AssertionError("unkown node type")
+            raise AssertionError("unknown node type")
 
 
 class FixImport(fixer_base.BaseFix):
diff -r 3a1db0d2747e Lib/lib2to3/pgen2/tokenize.py
--- a/Lib/lib2to3/pgen2/tokenize.py
+++ b/Lib/lib2to3/pgen2/tokenize.py
@@ -252,7 +252,7 @@
 def detect_encoding(readline):
     """
     The detect_encoding() function is used to detect the encoding that should
-    be used to decode a Python source file. It requires one argment, readline,
+    be used to decode a Python source file. It requires one argument, readline,
     in the same way as the tokenize() generator.
 
     It will call readline a maximum of twice, and return the encoding used
@@ -343,7 +343,7 @@
 
 def generate_tokens(readline):
     """
-    The generate_tokens() generator requires one argment, readline, which
+    The generate_tokens() generator requires one argument, readline, which
     must be a callable object which provides the same interface as the
     readline() method of built-in file objects. Each call to the function
     should return one line of input as a string.  Alternately, readline
diff -r 3a1db0d2747e Lib/lib2to3/tests/test_fixers.py
--- a/Lib/lib2to3/tests/test_fixers.py
+++ b/Lib/lib2to3/tests/test_fixers.py
@@ -41,7 +41,7 @@
 
     def warns(self, before, after, message, unchanged=False):
         tree = self._check(before, after)
-        self.assertTrue(message in "".join(self.fixer_log))
+        self.assertIn(message, "".join(self.fixer_log))
         if not unchanged:
             self.assertTrue(tree.was_changed)
 
diff -r 3a1db0d2747e Lib/lib2to3/tests/test_main.py
--- a/Lib/lib2to3/tests/test_main.py
+++ b/Lib/lib2to3/tests/test_main.py
@@ -59,9 +59,9 @@
         ret = self.run_2to3_capture(["-"], input_stream, out_enc, err)
         self.assertEqual(ret, 0)
         output = out.getvalue()
-        self.assertTrue("-print 'nothing'" in output)
-        self.assertTrue("WARNING: couldn't encode <stdin>'s diff for "
-                        "your terminal" in err.getvalue())
+        self.assertIn("-print 'nothing'", output)
+        self.assertIn("WARNING: couldn't encode <stdin>'s diff for "
+                      "your terminal", err.getvalue())
 
     def setup_test_source_trees(self):
         """Setup a test source tree and output destination tree."""
diff -r 3a1db0d2747e Lib/lib2to3/tests/test_parser.py
--- a/Lib/lib2to3/tests/test_parser.py
+++ b/Lib/lib2to3/tests/test_parser.py
@@ -165,8 +165,8 @@
         for filepath in support.all_project_files():
             with open(filepath, "rb") as fp:
                 encoding = tokenize.detect_encoding(fp.readline)[0]
-            self.assertTrue(encoding is not None,
-                            "can't detect encoding for %s" % filepath)
+            self.assertIsNotNone(encoding,
+                                 "can't detect encoding for %s" % filepath)
             with open(filepath, "r") as fp:
                 source = fp.read()
                 source = source.decode(encoding)
diff -r 3a1db0d2747e Lib/lib2to3/tests/test_pytree.py
--- a/Lib/lib2to3/tests/test_pytree.py
+++ b/Lib/lib2to3/tests/test_pytree.py
@@ -160,12 +160,12 @@
         l3 = pytree.Leaf(100, "bar")
         n1 = pytree.Node(1000, [l1, l2, l3])
         self.assertEqual(n1.children, [l1, l2, l3])
-        self.assertTrue(isinstance(n1.children, list))
+        self.assertIsInstance(n1.children, list)
         self.assertFalse(n1.was_changed)
         l2new = pytree.Leaf(100, "-")
         l2.replace(l2new)
         self.assertEqual(n1.children, [l1, l2new, l3])
-        self.assertTrue(isinstance(n1.children, list))
+        self.assertIsInstance(n1.children, list)
         self.assertTrue(n1.was_changed)
 
     def test_replace_with_list(self):
@@ -176,7 +176,7 @@
 
         l2.replace([pytree.Leaf(100, "*"), pytree.Leaf(100, "*")])
         self.assertEqual(str(n1), "foo**bar")
-        self.assertTrue(isinstance(n1.children, list))
+        self.assertIsInstance(n1.children, list)
 
     def test_leaves(self):
         l1 = pytree.Leaf(100, "foo")
@@ -347,7 +347,7 @@
         n2 = pytree.Node(1000, [])
         p1 = pytree.Node(1000, [n1, n2])
 
-        self.assertTrue(n1.next_sibling is n2)
+        self.assertIs(n1.next_sibling, n2)
         self.assertEqual(n2.next_sibling, None)
         self.assertEqual(p1.next_sibling, None)
 
@@ -356,7 +356,7 @@
         l2 = pytree.Leaf(100, "b")
         p1 = pytree.Node(1000, [l1, l2])
 
-        self.assertTrue(l1.next_sibling is l2)
+        self.assertIs(l1.next_sibling, l2)
         self.assertEqual(l2.next_sibling, None)
         self.assertEqual(p1.next_sibling, None)
 
@@ -365,7 +365,7 @@
         n2 = pytree.Node(1000, [])
         p1 = pytree.Node(1000, [n1, n2])
 
-        self.assertTrue(n2.prev_sibling is n1)
+        self.assertIs(n2.prev_sibling, n1)
         self.assertEqual(n1.prev_sibling, None)
         self.assertEqual(p1.prev_sibling, None)
 
@@ -374,7 +374,7 @@
         l2 = pytree.Leaf(100, "b")
         p1 = pytree.Node(1000, [l1, l2])
 
-        self.assertTrue(l2.prev_sibling is l1)
+        self.assertIs(l2.prev_sibling, l1)
         self.assertEqual(l1.prev_sibling, None)
         self.assertEqual(p1.prev_sibling, None)
 
@@ -447,7 +447,7 @@
         r = {}
         self.assertTrue(pw.match_seq([l1, l3], r))
         self.assertEqual(r, {"pl": l3, "pw": [l1, l3]})
-        self.assertTrue(r["pl"] is l3)
+        self.assertIs(r["pl"], l3)
         r = {}
 
     def test_generate_matches(self):
diff -r 3a1db0d2747e Lib/lib2to3/tests/test_refactor.py
--- a/Lib/lib2to3/tests/test_refactor.py
+++ b/Lib/lib2to3/tests/test_refactor.py
@@ -49,9 +49,9 @@
 
     def test_print_function_option(self):
         rt = self.rt({"print_function" : True})
-        self.assertTrue(rt.grammar is pygram.python_grammar_no_print_statement)
-        self.assertTrue(rt.driver.grammar is
-                        pygram.python_grammar_no_print_statement)
+        self.assertIs(rt.grammar, pygram.python_grammar_no_print_statement)
+        self.assertIs(rt.driver.grammar,
+                      pygram.python_grammar_no_print_statement)
 
     def test_write_unchanged_files_option(self):
         rt = self.rt()
diff -r 3a1db0d2747e Lib/locale.py
--- a/Lib/locale.py
+++ b/Lib/locale.py
@@ -344,6 +344,22 @@
     for x in range(256)
 )
 
+def _replace_encoding(code, encoding):
+    if '.' in code:
+        langname = code[:code.index('.')]
+    else:
+        langname = code
+    # Convert the encoding to a C lib compatible encoding string
+    norm_encoding = encodings.normalize_encoding(encoding)
+    #print('norm encoding: %r' % norm_encoding)
+    norm_encoding = encodings.aliases.aliases.get(norm_encoding,
+                                                  norm_encoding)
+    #print('aliased encoding: %r' % norm_encoding)
+    encoding = locale_encoding_alias.get(norm_encoding,
+                                         norm_encoding)
+    #print('found encoding %r' % encoding)
+    return langname + '.' + encoding
+
 def normalize(localename):
 
     """ Returns a normalized locale code for the given locale
@@ -360,57 +376,73 @@
         does.
 
     """
-    # Normalize the locale name and extract the encoding
+    # Normalize the locale name and extract the encoding and modifier
     if isinstance(localename, _unicode):
         localename = localename.encode('ascii')
-    fullname = localename.translate(_ascii_lower_map)
-    if ':' in fullname:
+    code = localename.lower()
+    if ':' in code:
         # ':' is sometimes used as encoding delimiter.
-        fullname = fullname.replace(':', '.')
-    if '.' in fullname:
-        langname, encoding = fullname.split('.')[:2]
-        fullname = langname + '.' + encoding
+        code = code.replace(':', '.')
+    if '@' in code:
+        code, modifier = code.split('@', 1)
     else:
-        langname = fullname
+        modifier = ''
+    if '.' in code:
+        langname, encoding = code.split('.')[:2]
+    else:
+        langname = code
         encoding = ''
 
-    # First lookup: fullname (possibly with encoding)
-    norm_encoding = encoding.replace('-', '')
-    norm_encoding = norm_encoding.replace('_', '')
-    lookup_name = langname + '.' + encoding
+    # First lookup: fullname (possibly with encoding and modifier)
+    lang_enc = langname
+    if encoding:
+        norm_encoding = encoding.replace('-', '')
+        norm_encoding = norm_encoding.replace('_', '')
+        lang_enc += '.' + norm_encoding
+    lookup_name = lang_enc
+    if modifier:
+        lookup_name += '@' + modifier
     code = locale_alias.get(lookup_name, None)
     if code is not None:
         return code
-    #print 'first lookup failed'
+    #print('first lookup failed')
 
-    # Second try: langname (without encoding)
-    code = locale_alias.get(langname, None)
-    if code is not None:
-        #print 'langname lookup succeeded'
-        if '.' in code:
-            langname, defenc = code.split('.')
-        else:
-            langname = code
-            defenc = ''
-        if encoding:
-            # Convert the encoding to a C lib compatible encoding string
-            norm_encoding = encodings.normalize_encoding(encoding)
-            #print 'norm encoding: %r' % norm_encoding
-            norm_encoding = encodings.aliases.aliases.get(norm_encoding,
-                                                          norm_encoding)
-            #print 'aliased encoding: %r' % norm_encoding
-            encoding = locale_encoding_alias.get(norm_encoding,
-                                                 norm_encoding)
-        else:
-            encoding = defenc
-        #print 'found encoding %r' % encoding
-        if encoding:
-            return langname + '.' + encoding
-        else:
-            return langname
+    if modifier:
+        # Second try: fullname without modifier (possibly with encoding)
+        code = locale_alias.get(lang_enc, None)
+        if code is not None:
+            #print('lookup without modifier succeeded')
+            if '@' not in code:
+                return code + '@' + modifier
+            if code.split('@', 1)[1].lower() == modifier:
+                return code
+        #print('second lookup failed')
 
-    else:
-        return localename
+    if encoding:
+        # Third try: langname (without encoding, possibly with modifier)
+        lookup_name = langname
+        if modifier:
+            lookup_name += '@' + modifier
+        code = locale_alias.get(lookup_name, None)
+        if code is not None:
+            #print('lookup without encoding succeeded')
+            if '@' not in code:
+                return _replace_encoding(code, encoding)
+            code, modifier = code.split('@', 1)
+            return _replace_encoding(code, encoding) + '@' + modifier
+
+        if modifier:
+            # Fourth try: langname (without encoding and modifier)
+            code = locale_alias.get(langname, None)
+            if code is not None:
+                #print('lookup without modifier and encoding succeeded')
+                if '@' not in code:
+                    return _replace_encoding(code, encoding) + '@' + modifier
+                code, defmod = code.split('@', 1)
+                if defmod.lower() == modifier:
+                    return _replace_encoding(code, encoding) + '@' + defmod
+
+    return localename
 
 def _parse_localename(localename):
 
@@ -429,7 +461,7 @@
     code = normalize(localename)
     if '@' in code:
         # Deal with locale modifiers
-        code, modifier = code.split('@')
+        code, modifier = code.split('@', 1)
         if modifier == 'euro' and '.' not in code:
             # Assume Latin-9 for @euro locales. This is bogus,
             # since some systems may use other encodings for these
@@ -734,11 +766,30 @@
 #    updated 'sr_yu.utf8@cyrillic' -> 'sr_CS.UTF-8' to 'sr_RS.UTF-8'
 #    updated 'sr_yu@cyrillic' -> 'sr_CS.ISO8859-5' to 'sr_RS.UTF-8'
 #
+# SS 2013-12-20:
+# Updated alias mapping to most recent locale.alias file
+# from X.org distribution using makelocalealias.py.
+#
+# These are the differences compared to the old mapping (Python 2.7.6
+# and older):
+#
+#    updated 'a3' -> 'a3_AZ.KOI8-C' to 'az_AZ.KOI8-C'
+#    updated 'a3_az' -> 'a3_AZ.KOI8-C' to 'az_AZ.KOI8-C'
+#    updated 'a3_az.koi8c' -> 'a3_AZ.KOI8-C' to 'az_AZ.KOI8-C'
+#    updated 'cs_cs.iso88592' -> 'cs_CS.ISO8859-2' to 'cs_CZ.ISO8859-2'
+#    updated 'hebrew' -> 'iw_IL.ISO8859-8' to 'he_IL.ISO8859-8'
+#    updated 'hebrew.iso88598' -> 'iw_IL.ISO8859-8' to 'he_IL.ISO8859-8'
+#    updated 'sd' -> 'sd_IN@devanagari.UTF-8' to 'sd_IN.UTF-8'
+#    updated 'sr@latn' -> 'sr_RS.UTF-8@latin' to 'sr_CS.UTF-8@latin'
+#    updated 'sr_cs' -> 'sr_RS.UTF-8' to 'sr_CS.UTF-8'
+#    updated 'sr_cs.utf8@latn' -> 'sr_RS.UTF-8@latin' to 'sr_CS.UTF-8@latin'
+#    updated 'sr_cs@latn' -> 'sr_RS.UTF-8@latin' to 'sr_CS.UTF-8@latin'
 
 locale_alias = {
-    'a3':                                   'a3_AZ.KOI8-C',
-    'a3_az':                                'a3_AZ.KOI8-C',
-    'a3_az.koi8c':                          'a3_AZ.KOI8-C',
+    'a3':                                   'az_AZ.KOI8-C',
+    'a3_az':                                'az_AZ.KOI8-C',
+    'a3_az.koi8c':                          'az_AZ.KOI8-C',
+    'a3_az.koic':                           'az_AZ.KOI8-C',
     'af':                                   'af_ZA.ISO8859-1',
     'af_za':                                'af_ZA.ISO8859-1',
     'af_za.iso88591':                       'af_ZA.ISO8859-1',
@@ -757,6 +808,7 @@
     'ar_dz.iso88596':                       'ar_DZ.ISO8859-6',
     'ar_eg':                                'ar_EG.ISO8859-6',
     'ar_eg.iso88596':                       'ar_EG.ISO8859-6',
+    'ar_in':                                'ar_IN.UTF-8',
     'ar_iq':                                'ar_IQ.ISO8859-6',
     'ar_iq.iso88596':                       'ar_IQ.ISO8859-6',
     'ar_jo':                                'ar_JO.ISO8859-6',
@@ -786,6 +838,7 @@
     'arabic':                               'ar_AA.ISO8859-6',
     'arabic.iso88596':                      'ar_AA.ISO8859-6',
     'as':                                   'as_IN.UTF-8',
+    'as_in':                                'as_IN.UTF-8',
     'az':                                   'az_AZ.ISO8859-9E',
     'az_az':                                'az_AZ.ISO8859-9E',
     'az_az.iso88599e':                      'az_AZ.ISO8859-9E',
@@ -803,6 +856,7 @@
     'bg_bg.koi8r':                          'bg_BG.KOI8-R',
     'bg_bg.microsoftcp1251':                'bg_BG.CP1251',
     'bn_in':                                'bn_IN.UTF-8',
+    'bo_in':                                'bo_IN.UTF-8',
     'bokmal':                               'nb_NO.ISO8859-1',
     'bokm\xe5l':                            'nb_NO.ISO8859-1',
     'br':                                   'br_FR.ISO8859-1',
@@ -820,6 +874,7 @@
     'c':                                    'C',
     'c-french':                             'fr_CA.ISO8859-1',
     'c-french.iso88591':                    'fr_CA.ISO8859-1',
+    'c.ascii':                              'C',
     'c.en':                                 'C',
     'c.iso88591':                           'en_US.ISO8859-1',
     'c_c':                                  'C',
@@ -857,7 +912,7 @@
     'croatian':                             'hr_HR.ISO8859-2',
     'cs':                                   'cs_CZ.ISO8859-2',
     'cs_cs':                                'cs_CZ.ISO8859-2',
-    'cs_cs.iso88592':                       'cs_CS.ISO8859-2',
+    'cs_cs.iso88592':                       'cs_CZ.ISO8859-2',
     'cs_cz':                                'cs_CZ.ISO8859-2',
     'cs_cz.iso88592':                       'cs_CZ.ISO8859-2',
     'cy':                                   'cy_GB.ISO8859-1',
@@ -1161,12 +1216,13 @@
     'he_il.cp1255':                         'he_IL.CP1255',
     'he_il.iso88598':                       'he_IL.ISO8859-8',
     'he_il.microsoftcp1255':                'he_IL.CP1255',
-    'hebrew':                               'iw_IL.ISO8859-8',
-    'hebrew.iso88598':                      'iw_IL.ISO8859-8',
+    'hebrew':                               'he_IL.ISO8859-8',
+    'hebrew.iso88598':                      'he_IL.ISO8859-8',
     'hi':                                   'hi_IN.ISCII-DEV',
     'hi_in':                                'hi_IN.ISCII-DEV',
     'hi_in.isciidev':                       'hi_IN.ISCII-DEV',
     'hne':                                  'hne_IN.UTF-8',
+    'hne_in':                               'hne_IN.UTF-8',
     'hr':                                   'hr_HR.ISO8859-2',
     'hr_hr':                                'hr_HR.ISO8859-2',
     'hr_hr.iso88592':                       'hr_HR.ISO8859-2',
@@ -1254,7 +1310,8 @@
     'korean':                               'ko_KR.eucKR',
     'korean.euc':                           'ko_KR.eucKR',
     'ks':                                   'ks_IN.UTF-8',
-    'ks_in@devanagari':                     'ks_IN@devanagari.UTF-8',
+    'ks_in':                                'ks_IN.UTF-8',
+    'ks_in@devanagari':                     'ks_IN.UTF-8@devanagari',
     'kw':                                   'kw_GB.ISO8859-1',
     'kw_gb':                                'kw_GB.ISO8859-1',
     'kw_gb.iso88591':                       'kw_GB.ISO8859-1',
@@ -1278,6 +1335,7 @@
     'lv_lv.iso885913':                      'lv_LV.ISO8859-13',
     'lv_lv.iso88594':                       'lv_LV.ISO8859-4',
     'mai':                                  'mai_IN.UTF-8',
+    'mai_in':                               'mai_IN.UTF-8',
     'mi':                                   'mi_NZ.ISO8859-1',
     'mi_nz':                                'mi_NZ.ISO8859-1',
     'mi_nz.iso88591':                       'mi_NZ.ISO8859-1',
@@ -1287,6 +1345,7 @@
     'mk_mk.iso88595':                       'mk_MK.ISO8859-5',
     'mk_mk.microsoftcp1251':                'mk_MK.CP1251',
     'ml':                                   'ml_IN.UTF-8',
+    'ml_in':                                'ml_IN.UTF-8',
     'mr':                                   'mr_IN.UTF-8',
     'mr_in':                                'mr_IN.UTF-8',
     'ms':                                   'ms_MY.ISO8859-1',
@@ -1301,6 +1360,7 @@
     'nb_no.iso88591':                       'nb_NO.ISO8859-1',
     'nb_no.iso885915':                      'nb_NO.ISO8859-15',
     'nb_no@euro':                           'nb_NO.ISO8859-15',
+    'ne_np':                                'ne_NP.UTF-8',
     'nl':                                   'nl_NL.ISO8859-1',
     'nl.iso885915':                         'nl_NL.ISO8859-15',
     'nl_be':                                'nl_BE.ISO8859-1',
@@ -1353,6 +1413,7 @@
     'oc_fr.iso885915':                      'oc_FR.ISO8859-15',
     'oc_fr@euro':                           'oc_FR.ISO8859-15',
     'or':                                   'or_IN.UTF-8',
+    'or_in':                                'or_IN.UTF-8',
     'pa':                                   'pa_IN.UTF-8',
     'pa_in':                                'pa_IN.UTF-8',
     'pd':                                   'pd_US.ISO8859-1',
@@ -1414,7 +1475,10 @@
     'rw':                                   'rw_RW.ISO8859-1',
     'rw_rw':                                'rw_RW.ISO8859-1',
     'rw_rw.iso88591':                       'rw_RW.ISO8859-1',
-    'sd':                                   'sd_IN@devanagari.UTF-8',
+    'sd':                                   'sd_IN.UTF-8',
+    'sd@devanagari':                        'sd_IN.UTF-8@devanagari',
+    'sd_in':                                'sd_IN.UTF-8',
+    'sd_in@devanagari':                     'sd_IN.UTF-8@devanagari',
     'se_no':                                'se_NO.UTF-8',
     'serbocroatian':                        'sr_RS.UTF-8@latin',
     'sh':                                   'sr_RS.UTF-8@latin',
@@ -1448,13 +1512,13 @@
     'sr':                                   'sr_RS.UTF-8',
     'sr@cyrillic':                          'sr_RS.UTF-8',
     'sr@latin':                             'sr_RS.UTF-8@latin',
-    'sr@latn':                              'sr_RS.UTF-8@latin',
-    'sr_cs':                                'sr_RS.UTF-8',
+    'sr@latn':                              'sr_CS.UTF-8@latin',
+    'sr_cs':                                'sr_CS.UTF-8',
     'sr_cs.iso88592':                       'sr_CS.ISO8859-2',
     'sr_cs.iso88592@latn':                  'sr_CS.ISO8859-2',
     'sr_cs.iso88595':                       'sr_CS.ISO8859-5',
-    'sr_cs.utf8@latn':                      'sr_RS.UTF-8@latin',
-    'sr_cs@latn':                           'sr_RS.UTF-8@latin',
+    'sr_cs.utf8@latn':                      'sr_CS.UTF-8@latin',
+    'sr_cs@latn':                           'sr_CS.UTF-8@latin',
     'sr_me':                                'sr_ME.UTF-8',
     'sr_rs':                                'sr_RS.UTF-8',
     'sr_rs.utf8@latn':                      'sr_RS.UTF-8@latin',
@@ -1532,6 +1596,7 @@
     'universal':                            'en_US.utf',
     'universal.utf8@ucs4':                  'en_US.UTF-8',
     'ur':                                   'ur_PK.CP1256',
+    'ur_in':                                'ur_IN.UTF-8',
     'ur_pk':                                'ur_PK.CP1256',
     'ur_pk.cp1256':                         'ur_PK.CP1256',
     'ur_pk.microsoftcp1256':                'ur_PK.CP1256',
diff -r 3a1db0d2747e Lib/logging/__init__.py
--- a/Lib/logging/__init__.py
+++ b/Lib/logging/__init__.py
@@ -912,8 +912,10 @@
                 self.flush()
                 if hasattr(self.stream, "close"):
                     self.stream.close()
-                StreamHandler.close(self)
                 self.stream = None
+            # Issue #19523: call unconditionally to
+            # prevent a handler leak when delay is set
+            StreamHandler.close(self)
         finally:
             self.release()
 
diff -r 3a1db0d2747e Lib/multiprocessing/pool.py
--- a/Lib/multiprocessing/pool.py
+++ b/Lib/multiprocessing/pool.py
@@ -169,7 +169,8 @@
 
         self._task_handler = threading.Thread(
             target=Pool._handle_tasks,
-            args=(self._taskqueue, self._quick_put, self._outqueue, self._pool)
+            args=(self._taskqueue, self._quick_put, self._outqueue,
+                  self._pool, self._cache)
             )
         self._task_handler.daemon = True
         self._task_handler._state = RUN
@@ -329,7 +330,7 @@
         debug('worker handler exiting')
 
     @staticmethod
-    def _handle_tasks(taskqueue, put, outqueue, pool):
+    def _handle_tasks(taskqueue, put, outqueue, pool, cache):
         thread = threading.current_thread()
 
         for taskseq, set_length in iter(taskqueue.get, None):
@@ -340,9 +341,12 @@
                     break
                 try:
                     put(task)
-                except IOError:
-                    debug('could not put task on queue')
-                    break
+                except Exception as e:
+                    job, ind = task[:2]
+                    try:
+                        cache[job]._set(ind, (False, e))
+                    except KeyError:
+                        pass
             else:
                 if set_length:
                     debug('doing set_length()')
diff -r 3a1db0d2747e Lib/multiprocessing/process.py
--- a/Lib/multiprocessing/process.py
+++ b/Lib/multiprocessing/process.py
@@ -267,7 +267,7 @@
             else:
                 sys.stderr.write(str(e.args[0]) + '\n')
                 sys.stderr.flush()
-                exitcode = 0 if isinstance(e.args[0], str) else 1
+                exitcode = 1
         except:
             exitcode = 1
             import traceback
diff -r 3a1db0d2747e Lib/ntpath.py
--- a/Lib/ntpath.py
+++ b/Lib/ntpath.py
@@ -144,15 +144,18 @@
         # vvvvvvvvvvvvvvvvvvvv equivalent to drive letter
         # \\machine\mountpoint\directories...
         #           directory ^^^^^^^^^^^^^^^
-        normp = normcase(p)
-        index = normp.find('\\', 2)
-        if index == -1:
-            ##raise RuntimeError, 'illegal UNC path: "' + p + '"'
-            return ("", p)
-        index = normp.find('\\', index + 1)
-        if index == -1:
-            index = len(p)
-        return p[:index], p[index:]
+        normp = p.replace('\\', '/')
+        index = normp.find('/', 2)
+        if index <= 2:
+            return '', p
+        index2 = normp.find('/', index + 1)
+        # a UNC path can't have two slashes in a row
+        # (after the initial two)
+        if index2 == index + 1:
+            return '', p
+        if index2 == -1:
+            index2 = len(p)
+        return p[:index2], p[index2:]
     return '', p
 
 
diff -r 3a1db0d2747e Lib/optparse.py
--- a/Lib/optparse.py
+++ b/Lib/optparse.py
@@ -204,7 +204,6 @@
                  short_first):
         self.parser = None
         self.indent_increment = indent_increment
-        self.help_position = self.max_help_position = max_help_position
         if width is None:
             try:
                 width = int(os.environ['COLUMNS'])
@@ -212,6 +211,8 @@
                 width = 80
             width -= 2
         self.width = width
+        self.help_position = self.max_help_position = \
+                min(max_help_position, max(width - 20, indent_increment * 2))
         self.current_indent = 0
         self.level = 0
         self.help_width = None          # computed later
@@ -256,7 +257,7 @@
         Format a paragraph of free-form text for inclusion in the
         help output at the current indentation level.
         """
-        text_width = self.width - self.current_indent
+        text_width = max(self.width - self.current_indent, 11)
         indent = " "*self.current_indent
         return textwrap.fill(text,
                              text_width,
@@ -337,7 +338,7 @@
         self.dedent()
         self.dedent()
         self.help_position = min(max_len + 2, self.max_help_position)
-        self.help_width = self.width - self.help_position
+        self.help_width = max(self.width - self.help_position, 11)
 
     def format_option_strings(self, option):
         """Return a comma-separated list of option strings & metavariables."""
diff -r 3a1db0d2747e Lib/pickle.py
--- a/Lib/pickle.py
+++ b/Lib/pickle.py
@@ -269,7 +269,7 @@
     def save(self, obj):
         # Check for persistent id (defined by a subclass)
         pid = self.persistent_id(obj)
-        if pid:
+        if pid is not None:
             self.save_pers(pid)
             return
 
diff -r 3a1db0d2747e Lib/pydoc.py
--- a/Lib/pydoc.py
+++ b/Lib/pydoc.py
@@ -81,6 +81,7 @@
 def getdoc(object):
     """Get the doc string or comments for an object."""
     result = inspect.getdoc(object) or inspect.getcomments(object)
+    result = _encode(result)
     return result and re.sub('^ *\n', '', rstrip(result)) or ''
 
 def splitdoc(doc):
@@ -182,6 +183,36 @@
         return name, kind, cls, value
     return map(fixup, inspect.classify_class_attrs(object))
 
+# ----------------------------------------------------- Unicode support helpers
+
+try:
+    _unicode = unicode
+except NameError:
+    # If Python is built without Unicode support, the unicode type
+    # will not exist. Fake one that nothing will match, and make
+    # the _encode function that do nothing.
+    class _unicode(object):
+        pass
+    _encoding = 'ascii'
+    def _encode(text, encoding='ascii'):
+        return text
+else:
+    import locale
+    _encoding = locale.getpreferredencoding()
+
+    def _encode(text, encoding=None):
+        if isinstance(text, unicode):
+            return text.encode(encoding or _encoding, 'xmlcharrefreplace')
+        else:
+            return text
+
+def _binstr(obj):
+    # Ensure that we have an encoded (binary) string representation of obj,
+    # even if it is a unicode string.
+    if isinstance(obj, _unicode):
+        return obj.encode(_encoding, 'xmlcharrefreplace')
+    return str(obj)
+
 # ----------------------------------------------------- module manipulation
 
 def ispackage(path):
@@ -424,12 +455,13 @@
 
     def page(self, title, contents):
         """Format an HTML page."""
-        return '''
+        return _encode('''
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
 <html><head><title>Python: %s</title>
+<meta charset="utf-8">
 </head><body bgcolor="#f0f0f8">
 %s
-</body></html>''' % (title, contents)
+</body></html>''' % (title, contents), 'ascii')
 
     def heading(self, title, fgcol, bgcol, extras=''):
         """Format a page heading."""
@@ -606,12 +638,12 @@
             filelink = '(built-in)'
         info = []
         if hasattr(object, '__version__'):
-            version = str(object.__version__)
+            version = _binstr(object.__version__)
             if version[:11] == '$' + 'Revision: ' and version[-1:] == '$':
                 version = strip(version[11:-1])
             info.append('version %s' % self.escape(version))
         if hasattr(object, '__date__'):
-            info.append(self.escape(str(object.__date__)))
+            info.append(self.escape(_binstr(object.__date__)))
         if info:
             head = head + ' (%s)' % join(info, ', ')
         docloc = self.getdocloc(object)
@@ -694,11 +726,11 @@
             result = result + self.bigsection(
                 'Data', '#ffffff', '#55aa55', join(contents, '<br>\n'))
         if hasattr(object, '__author__'):
-            contents = self.markup(str(object.__author__), self.preformat)
+            contents = self.markup(_binstr(object.__author__), self.preformat)
             result = result + self.bigsection(
                 'Author', '#ffffff', '#7799ee', contents)
         if hasattr(object, '__credits__'):
-            contents = self.markup(str(object.__credits__), self.preformat)
+            contents = self.markup(_binstr(object.__credits__), self.preformat)
             result = result + self.bigsection(
                 'Credits', '#ffffff', '#7799ee', contents)
 
@@ -1116,16 +1148,16 @@
             result = result + self.section('DATA', join(contents, '\n'))
 
         if hasattr(object, '__version__'):
-            version = str(object.__version__)
+            version = _binstr(object.__version__)
             if version[:11] == '$' + 'Revision: ' and version[-1:] == '$':
                 version = strip(version[11:-1])
             result = result + self.section('VERSION', version)
         if hasattr(object, '__date__'):
-            result = result + self.section('DATE', str(object.__date__))
+            result = result + self.section('DATE', _binstr(object.__date__))
         if hasattr(object, '__author__'):
-            result = result + self.section('AUTHOR', str(object.__author__))
+            result = result + self.section('AUTHOR', _binstr(object.__author__))
         if hasattr(object, '__credits__'):
-            result = result + self.section('CREDITS', str(object.__credits__))
+            result = result + self.section('CREDITS', _binstr(object.__credits__))
         return result
 
     def docclass(self, object, name=None, mod=None, *ignored):
@@ -1375,7 +1407,7 @@
     """Page through text by feeding it to another program."""
     pipe = os.popen(cmd, 'w')
     try:
-        pipe.write(text)
+        pipe.write(_encode(text))
         pipe.close()
     except IOError:
         pass # Ignore broken pipes caused by quitting the pager program.
@@ -1385,7 +1417,7 @@
     import tempfile
     filename = tempfile.mktemp()
     file = open(filename, 'w')
-    file.write(text)
+    file.write(_encode(text))
     file.close()
     try:
         os.system(cmd + ' "' + filename + '"')
@@ -1394,7 +1426,7 @@
 
 def ttypager(text):
     """Page through text on a text terminal."""
-    lines = split(plain(text), '\n')
+    lines = plain(_encode(plain(text), getattr(sys.stdout, 'encoding', _encoding))).split('\n')
     try:
         import tty
         fd = sys.stdin.fileno()
@@ -1432,7 +1464,7 @@
 
 def plainpager(text):
     """Simply print unformatted text.  This is the ultimate fallback."""
-    sys.stdout.write(plain(text))
+    sys.stdout.write(_encode(plain(text), getattr(sys.stdout, 'encoding', _encoding)))
 
 def describe(thing):
     """Produce a short description of the given thing."""
diff -r 3a1db0d2747e Lib/sqlite3/test/factory.py
--- a/Lib/sqlite3/test/factory.py
+++ b/Lib/sqlite3/test/factory.py
@@ -47,9 +47,7 @@
         self.con.close()
 
     def CheckIsInstance(self):
-        self.assertTrue(isinstance(self.con,
-                                   MyConnection),
-                        "connection is not instance of MyConnection")
+        self.assertIsInstance(self.con, MyConnection)
 
 class CursorFactoryTests(unittest.TestCase):
     def setUp(self):
@@ -60,9 +58,7 @@
 
     def CheckIsInstance(self):
         cur = self.con.cursor(factory=MyCursor)
-        self.assertTrue(isinstance(cur,
-                                   MyCursor),
-                        "cursor is not instance of MyCursor")
+        self.assertIsInstance(cur, MyCursor)
 
 class RowFactoryTestsBackwardsCompat(unittest.TestCase):
     def setUp(self):
@@ -72,9 +68,7 @@
         cur = self.con.cursor(factory=MyCursor)
         cur.execute("select 4+5 as foo")
         row = cur.fetchone()
-        self.assertTrue(isinstance(row,
-                                   dict),
-                        "row is not instance of dict")
+        self.assertIsInstance(row, dict)
         cur.close()
 
     def tearDown(self):
@@ -87,28 +81,24 @@
     def CheckCustomFactory(self):
         self.con.row_factory = lambda cur, row: list(row)
         row = self.con.execute("select 1, 2").fetchone()
-        self.assertTrue(isinstance(row,
-                                   list),
-                        "row is not instance of list")
+        self.assertIsInstance(row, list)
 
     def CheckSqliteRowIndex(self):
         self.con.row_factory = sqlite.Row
         row = self.con.execute("select 1 as a, 2 as b").fetchone()
-        self.assertTrue(isinstance(row,
-                                   sqlite.Row),
-                        "row is not instance of sqlite.Row")
+        self.assertIsInstance(row, sqlite.Row)
 
         col1, col2 = row["a"], row["b"]
-        self.assertTrue(col1 == 1, "by name: wrong result for column 'a'")
-        self.assertTrue(col2 == 2, "by name: wrong result for column 'a'")
+        self.assertEqual(col1, 1, "by name: wrong result for column 'a'")
+        self.assertEqual(col2, 2, "by name: wrong result for column 'a'")
 
         col1, col2 = row["A"], row["B"]
-        self.assertTrue(col1 == 1, "by name: wrong result for column 'A'")
-        self.assertTrue(col2 == 2, "by name: wrong result for column 'B'")
+        self.assertEqual(col1, 1, "by name: wrong result for column 'A'")
+        self.assertEqual(col2, 2, "by name: wrong result for column 'B'")
 
         col1, col2 = row[0], row[1]
-        self.assertTrue(col1 == 1, "by index: wrong result for column 0")
-        self.assertTrue(col2 == 2, "by index: wrong result for column 1")
+        self.assertEqual(col1, 1, "by index: wrong result for column 0")
+        self.assertEqual(col2, 2, "by index: wrong result for column 1")
 
     def CheckSqliteRowIter(self):
         """Checks if the row object is iterable"""
@@ -138,8 +128,8 @@
         row_2 = self.con.execute("select 1 as a, 2 as b").fetchone()
         row_3 = self.con.execute("select 1 as a, 3 as b").fetchone()
 
-        self.assertTrue(row_1 == row_1)
-        self.assertTrue(row_1 == row_2)
+        self.assertEqual(row_1, row_1)
+        self.assertEqual(row_1, row_2)
         self.assertTrue(row_2 != row_3)
 
         self.assertFalse(row_1 != row_1)
@@ -161,20 +151,20 @@
     def CheckUnicode(self):
         austria = unicode("sterreich", "latin1")
         row = self.con.execute("select ?", (austria,)).fetchone()
-        self.assertTrue(type(row[0]) == unicode, "type of row[0] must be unicode")
+        self.assertEqual(type(row[0]), unicode, "type of row[0] must be unicode")
 
     def CheckString(self):
         self.con.text_factory = str
         austria = unicode("sterreich", "latin1")
         row = self.con.execute("select ?", (austria,)).fetchone()
-        self.assertTrue(type(row[0]) == str, "type of row[0] must be str")
-        self.assertTrue(row[0] == austria.encode("utf-8"), "column must equal original data in UTF-8")
+        self.assertEqual(type(row[0]), str, "type of row[0] must be str")
+        self.assertEqual(row[0], austria.encode("utf-8"), "column must equal original data in UTF-8")
 
     def CheckCustom(self):
         self.con.text_factory = lambda x: unicode(x, "utf-8", "ignore")
         austria = unicode("sterreich", "latin1")
         row = self.con.execute("select ?", (austria.encode("latin1"),)).fetchone()
-        self.assertTrue(type(row[0]) == unicode, "type of row[0] must be unicode")
+        self.assertEqual(type(row[0]), unicode, "type of row[0] must be unicode")
         self.assertTrue(row[0].endswith(u"reich"), "column must contain original data")
 
     def CheckOptimizedUnicode(self):
@@ -183,8 +173,8 @@
         germany = unicode("Deutchland")
         a_row = self.con.execute("select ?", (austria,)).fetchone()
         d_row = self.con.execute("select ?", (germany,)).fetchone()
-        self.assertTrue(type(a_row[0]) == unicode, "type of non-ASCII row must be unicode")
-        self.assertTrue(type(d_row[0]) == str, "type of ASCII-only row must be str")
+        self.assertEqual(type(a_row[0]), unicode, "type of non-ASCII row must be unicode")
+        self.assertEqual(type(d_row[0]), str, "type of ASCII-only row must be str")
 
     def tearDown(self):
         self.con.close()
diff -r 3a1db0d2747e Lib/sqlite3/test/hooks.py
--- a/Lib/sqlite3/test/hooks.py
+++ b/Lib/sqlite3/test/hooks.py
@@ -162,7 +162,7 @@
             create table bar (a, b)
             """)
         second_count = len(progress_calls)
-        self.assertTrue(first_count > second_count)
+        self.assertGreater(first_count, second_count)
 
     def CheckCancelOperation(self):
         """
diff -r 3a1db0d2747e Lib/sqlite3/test/regression.py
--- a/Lib/sqlite3/test/regression.py
+++ b/Lib/sqlite3/test/regression.py
@@ -313,6 +313,11 @@
             datetime.datetime(2012, 4, 4, 15, 6, 0, 123456),
         ])
 
+    def CheckInvalidIsolationLevelType(self):
+        # isolation level is a string, not an integer
+        self.assertRaises(TypeError,
+                          sqlite.connect, ":memory:", isolation_level=123)
+
 
 def suite():
     regression_suite = unittest.makeSuite(RegressionTests, "Check")
diff -r 3a1db0d2747e Lib/sre_compile.py
--- a/Lib/sre_compile.py
+++ b/Lib/sre_compile.py
@@ -276,10 +276,10 @@
 # set is constructed. Then, this bitmap is sliced into chunks of 256
 # characters, duplicate chunks are eliminated, and each chunk is
 # given a number. In the compiled expression, the charset is
-# represented by a 16-bit word sequence, consisting of one word for
-# the number of different chunks, a sequence of 256 bytes (128 words)
+# represented by a 32-bit word sequence, consisting of one word for
+# the number of different chunks, a sequence of 256 bytes (64 words)
 # of chunk numbers indexed by their original chunk position, and a
-# sequence of chunks (16 words each).
+# sequence of 256-bit chunks (8 words each).
 
 # Compression is normally good: in a typical charset, large ranges of
 # Unicode will be either completely excluded (e.g. if only cyrillic
@@ -294,7 +294,7 @@
 
 # In UCS-4 mode, the BIGCHARSET opcode still supports only subsets
 # of the basic multilingual plane; an efficient representation
-# for all of UTF-16 has not yet been developed. This means,
+# for all of Unicode has not yet been developed. This means,
 # in particular, that negated charsets cannot be represented as
 # bigcharsets.
 
diff -r 3a1db0d2747e Lib/ssl.py
--- a/Lib/ssl.py
+++ b/Lib/ssl.py
@@ -89,6 +89,7 @@
 
 from socket import socket, _fileobject, _delegate_methods, error as socket_error
 from socket import getnameinfo as _getnameinfo
+from socket import SOL_SOCKET, SO_TYPE, SOCK_STREAM
 import base64        # for DER-to-PEM translation
 import errno
 
@@ -108,6 +109,10 @@
                  ssl_version=PROTOCOL_SSLv23, ca_certs=None,
                  do_handshake_on_connect=True,
                  suppress_ragged_eofs=True, ciphers=None):
+        # Can't use sock.type as other flags (such as SOCK_NONBLOCK) get
+        # mixed in.
+        if sock.getsockopt(SOL_SOCKET, SO_TYPE) != SOCK_STREAM:
+            raise NotImplementedError("only stream sockets are supported")
         socket.__init__(self, _sock=sock._sock)
         # The initializer for socket overrides the methods send(), recv(), etc.
         # in the instancce, which we don't need -- but we want to provide the
diff -r 3a1db0d2747e Lib/telnetlib.py
--- a/Lib/telnetlib.py
+++ b/Lib/telnetlib.py
@@ -312,7 +312,9 @@
             poller.register(self, poll_in_or_priority_flags)
             while i < 0 and not self.eof:
                 try:
-                    ready = poller.poll(call_timeout)
+                    # Poll takes its timeout in milliseconds.
+                    ready = poller.poll(None if timeout is None
+                                        else 1000 * call_timeout)
                 except select.error as e:
                     if e.errno == errno.EINTR:
                         if timeout is not None:
@@ -682,7 +684,8 @@
             poller.register(self, poll_in_or_priority_flags)
             while not m and not self.eof:
                 try:
-                    ready = poller.poll(call_timeout)
+                    ready = poller.poll(None if timeout is None
+                                        else 1000 * call_timeout)
                 except select.error as e:
                     if e.errno == errno.EINTR:
                         if timeout is not None:
diff -r 3a1db0d2747e Lib/test/audiotests.py
--- a/Lib/test/audiotests.py
+++ b/Lib/test/audiotests.py
@@ -6,11 +6,19 @@
 import sys
 import base64
 
+class UnseekableIO(file):
+    def tell(self):
+        raise io.UnsupportedOperation
+
+    def seek(self, *args, **kwargs):
+        raise io.UnsupportedOperation
+
 def fromhex(s):
     return base64.b16decode(s.replace(' ', ''))
 
 def byteswap2(data):
-    a = array.array('h', data)
+    a = array.array('h')
+    a.fromstring(data)
     a.byteswap()
     return a.tostring()
 
@@ -21,7 +29,8 @@
     return bytes(ba)
 
 def byteswap4(data):
-    a = array.array('i', data)
+    a = array.array('i')
+    a.fromstring(data)
     a.byteswap()
     return a.tostring()
 
@@ -131,6 +140,62 @@
             self.assertEqual(testfile.read(13), b'ababagalamaga')
             self.check_file(testfile, self.nframes, self.frames)
 
+    def test_unseekable_read(self):
+        f = self.create_file(TESTFN)
+        f.setnframes(self.nframes)
+        f.writeframes(self.frames)
+        f.close()
+
+        with UnseekableIO(TESTFN, 'rb') as testfile:
+            self.check_file(testfile, self.nframes, self.frames)
+
+    def test_unseekable_write(self):
+        with UnseekableIO(TESTFN, 'wb') as testfile:
+            f = self.create_file(testfile)
+            f.setnframes(self.nframes)
+            f.writeframes(self.frames)
+            f.close()
+            self.fout = None
+
+        self.check_file(TESTFN, self.nframes, self.frames)
+
+    def test_unseekable_incompleted_write(self):
+        with UnseekableIO(TESTFN, 'wb') as testfile:
+            testfile.write(b'ababagalamaga')
+            f = self.create_file(testfile)
+            f.setnframes(self.nframes + 1)
+            try:
+                f.writeframes(self.frames)
+            except IOError:
+                pass
+            try:
+                f.close()
+            except IOError:
+                pass
+
+        with open(TESTFN, 'rb') as testfile:
+            self.assertEqual(testfile.read(13), b'ababagalamaga')
+            self.check_file(testfile, self.nframes + 1, self.frames)
+
+    def test_unseekable_overflowed_write(self):
+        with UnseekableIO(TESTFN, 'wb') as testfile:
+            testfile.write(b'ababagalamaga')
+            f = self.create_file(testfile)
+            f.setnframes(self.nframes - 1)
+            try:
+                f.writeframes(self.frames)
+            except IOError:
+                pass
+            try:
+                f.close()
+            except IOError:
+                pass
+
+        with open(TESTFN, 'rb') as testfile:
+            self.assertEqual(testfile.read(13), b'ababagalamaga')
+            framesize = self.nchannels * self.sampwidth
+            self.check_file(testfile, self.nframes - 1, self.frames[:-framesize])
+
 
 class AudioTestsWithSourceFile(AudioTests):
 
diff -r 3a1db0d2747e Lib/test/bad_coding3.py
--- /dev/null
+++ b/Lib/test/bad_coding3.py
@@ -0,0 +1,2 @@
+# coding: string-escape
+\x70\x72\x69\x6e\x74\x20\x32\x2b\x32\x0a
diff -r 3a1db0d2747e Lib/test/pickletester.py
--- a/Lib/test/pickletester.py
+++ b/Lib/test/pickletester.py
@@ -1152,30 +1152,34 @@
         if isinstance(object, int) and object % 2 == 0:
             self.id_count += 1
             return str(object)
+        elif object == "test_false_value":
+            self.false_count += 1
+            return ""
         else:
             return None
 
     def persistent_load(self, oid):
-        self.load_count += 1
-        object = int(oid)
-        assert object % 2 == 0
-        return object
+        if not oid:
+            self.load_false_count += 1
+            return "test_false_value"
+        else:
+            self.load_count += 1
+            object = int(oid)
+            assert object % 2 == 0
+            return object
 
     def test_persistence(self):
-        self.id_count = 0
-        self.load_count = 0
-        L = range(10)
-        self.assertEqual(self.loads(self.dumps(L)), L)
-        self.assertEqual(self.id_count, 5)
-        self.assertEqual(self.load_count, 5)
-
-    def test_bin_persistence(self):
-        self.id_count = 0
-        self.load_count = 0
-        L = range(10)
-        self.assertEqual(self.loads(self.dumps(L, 1)), L)
-        self.assertEqual(self.id_count, 5)
-        self.assertEqual(self.load_count, 5)
+        L = range(10) + ["test_false_value"]
+        for proto in protocols:
+            self.id_count = 0
+            self.false_count = 0
+            self.load_false_count = 0
+            self.load_count = 0
+            self.assertEqual(self.loads(self.dumps(L, proto)), L)
+            self.assertEqual(self.id_count, 5)
+            self.assertEqual(self.false_count, 1)
+            self.assertEqual(self.load_count, 5)
+            self.assertEqual(self.load_false_count, 1)
 
 class AbstractPicklerUnpicklerObjectTests(unittest.TestCase):
 
diff -r 3a1db0d2747e Lib/test/regrtest.py
--- a/Lib/test/regrtest.py
+++ b/Lib/test/regrtest.py
@@ -1002,9 +1002,10 @@
     try:
         import zipimport
     except ImportError:
-        zdc = None # Run unmodified on platforms without zipimport support
+        zsc = zdc = None # Run unmodified on platforms without zipimport support
     else:
         zdc = zipimport._zip_directory_cache.copy()
+        zsc = zipimport._zip_stat_cache.copy()
     abcs = {}
     modules = _abcoll, _pyio
     for abc in [getattr(mod, a) for mod in modules for a in mod.__all__]:
@@ -1027,12 +1028,12 @@
     repcount = nwarmup + ntracked
     print >> sys.stderr, "beginning", repcount, "repetitions"
     print >> sys.stderr, ("1234567890"*(repcount//10 + 1))[:repcount]
-    dash_R_cleanup(fs, ps, pic, zdc, abcs)
+    dash_R_cleanup(fs, ps, pic, zdc, zsc, abcs)
     for i in range(repcount):
         rc_before = sys.gettotalrefcount()
         run_the_test()
         sys.stderr.write('.')
-        dash_R_cleanup(fs, ps, pic, zdc, abcs)
+        dash_R_cleanup(fs, ps, pic, zdc, zsc, abcs)
         rc_after = sys.gettotalrefcount()
         if i >= nwarmup:
             deltas.append(rc_after - rc_before)
@@ -1046,7 +1047,7 @@
         return True
     return False
 
-def dash_R_cleanup(fs, ps, pic, zdc, abcs):
+def dash_R_cleanup(fs, ps, pic, zdc, zsc, abcs):
     import gc, copy_reg
     import _strptime, linecache
     dircache = test_support.import_module('dircache', deprecated=True)
@@ -1072,6 +1073,8 @@
     else:
         zipimport._zip_directory_cache.clear()
         zipimport._zip_directory_cache.update(zdc)
+        zipimport._zip_stat_cache.clear()
+        zipimport._zip_stat_cache.update(zsc)
 
     # clear type cache
     sys._clear_type_cache()
diff -r 3a1db0d2747e Lib/test/string_tests.py
--- a/Lib/test/string_tests.py
+++ b/Lib/test/string_tests.py
@@ -750,10 +750,10 @@
         self.checkraises(TypeError, 'hello', 'replace', 42, 'h')
         self.checkraises(TypeError, 'hello', 'replace', 'h', 42)
 
+    @unittest.skipIf(sys.maxint > (1 << 32) or struct.calcsize('P') != 4,
+                     'only applies to 32-bit platforms')
     def test_replace_overflow(self):
         # Check for overflow checking on 32 bit machines
-        if sys.maxint != 2147483647 or struct.calcsize("P") > 4:
-            return
         A2_16 = "A" * (2**16)
         self.checkraises(OverflowError, A2_16, "replace", "", A2_16)
         self.checkraises(OverflowError, A2_16, "replace", "A", A2_16)
@@ -1286,27 +1286,27 @@
     # Additional tests that only work with
     # 8bit compatible object, i.e. str and UserString
 
-    if test_support.have_unicode:
-        def test_encoding_decoding(self):
-            codecs = [('rot13', 'uryyb jbeyq'),
-                      ('base64', 'aGVsbG8gd29ybGQ=\n'),
-                      ('hex', '68656c6c6f20776f726c64'),
-                      ('uu', 'begin 666 <data>\n+:&5L;&\\@=V]R;&0 \n \nend\n')]
-            for encoding, data in codecs:
-                self.checkequal(data, 'hello world', 'encode', encoding)
-                self.checkequal('hello world', data, 'decode', encoding)
-            # zlib is optional, so we make the test optional too...
-            try:
-                import zlib
-            except ImportError:
-                pass
-            else:
-                data = 'x\x9c\xcbH\xcd\xc9\xc9W(\xcf/\xcaI\x01\x00\x1a\x0b\x04]'
-                self.checkequal(data, 'hello world', 'encode', 'zlib')
-                self.checkequal('hello world', data, 'decode', 'zlib')
+    @unittest.skipUnless(test_support.have_unicode, 'no unicode support')
+    def test_encoding_decoding(self):
+        codecs = [('rot13', 'uryyb jbeyq'),
+                  ('base64', 'aGVsbG8gd29ybGQ=\n'),
+                  ('hex', '68656c6c6f20776f726c64'),
+                  ('uu', 'begin 666 <data>\n+:&5L;&\\@=V]R;&0 \n \nend\n')]
+        for encoding, data in codecs:
+            self.checkequal(data, 'hello world', 'encode', encoding)
+            self.checkequal('hello world', data, 'decode', encoding)
+        # zlib is optional, so we make the test optional too...
+        try:
+            import zlib
+        except ImportError:
+            pass
+        else:
+            data = 'x\x9c\xcbH\xcd\xc9\xc9W(\xcf/\xcaI\x01\x00\x1a\x0b\x04]'
+            self.checkequal(data, 'hello world', 'encode', 'zlib')
+            self.checkequal('hello world', data, 'decode', 'zlib')
 
-            self.checkraises(TypeError, 'xyz', 'decode', 42)
-            self.checkraises(TypeError, 'xyz', 'encode', 42)
+        self.checkraises(TypeError, 'xyz', 'decode', 42)
+        self.checkraises(TypeError, 'xyz', 'encode', 42)
 
 
 class MixinStrUnicodeTest:
diff -r 3a1db0d2747e Lib/test/test_aepack.py
--- a/Lib/test/test_aepack.py
+++ b/Lib/test/test_aepack.py
@@ -59,10 +59,10 @@
         try:
             import Carbon.File
         except:
-            return
+            self.skipTest('Carbon.File not available')
 
         if not hasattr(Carbon.File, "FSSpec"):
-            return
+            self.skipTest('Carbon.File.FSSpec not available')
         o = Carbon.File.FSSpec(os.curdir)
         packed = aepack.pack(o)
         unpacked = aepack.unpack(packed)
@@ -72,9 +72,9 @@
         try:
             import Carbon.File
         except:
-            return
+            self.skipTest('Carbon.File not available')
         if not hasattr(Carbon.File, "FSSpec"):
-            return
+            self.skipTest('Carbon.File.FSSpec not available')
         o = Carbon.File.FSSpec(os.curdir).NewAliasMinimal()
         packed = aepack.pack(o)
         unpacked = aepack.unpack(packed)
diff -r 3a1db0d2747e Lib/test/test_aifc.py
--- a/Lib/test/test_aifc.py
+++ b/Lib/test/test_aifc.py
@@ -9,10 +9,14 @@
 import aifc
 
 
-class AifcPCM8Test(audiotests.AudioWriteTests,
-        audiotests.AudioTestsWithSourceFile,
-        unittest.TestCase):
+class AifcTest(audiotests.AudioWriteTests,
+               audiotests.AudioTestsWithSourceFile):
     module = aifc
+    close_fd = True
+    test_unseekable_read = None
+
+
+class AifcPCM8Test(AifcTest, unittest.TestCase):
     sndfilename = 'pluck-pcm8.aiff'
     sndfilenframes = 3307
     nchannels = 2
@@ -27,13 +31,9 @@
       11FA 3EFB BCFC 66FF CF04 4309 C10E 5112 EE17 8216 7F14 8012 \
       490E 520D EF0F CE0F E40C 630A 080A 2B0B 510E 8B11 B60E 440A \
       """)
-    close_fd = True
 
 
-class AifcPCM16Test(audiotests.AudioWriteTests,
-        audiotests.AudioTestsWithSourceFile,
-        unittest.TestCase):
-    module = aifc
+class AifcPCM16Test(AifcTest, unittest.TestCase):
     sndfilename = 'pluck-pcm16.aiff'
     sndfilenframes = 3307
     nchannels = 2
@@ -50,13 +50,9 @@
       EEE21753 82071665 7FFF1443 8004128F 49A20EAF 52BB0DBA EFB40F60 CE3C0FBF \
       E4B30CEC 63430A5C 08C80A20 2BBB0B08 514A0E43 8BCF1139 B6F60EEB 44120A5E \
       """)
-    close_fd = True
 
 
-class AifcPCM24Test(audiotests.AudioWriteTests,
-        audiotests.AudioTestsWithSourceFile,
-        unittest.TestCase):
-    module = aifc
+class AifcPCM24Test(AifcTest, unittest.TestCase):
     sndfilename = 'pluck-pcm24.aiff'
     sndfilenframes = 3307
     nchannels = 2
@@ -79,13 +75,9 @@
       E4B49C0CEA2D 6344A80A5A7C 08C8FE0A1FFE 2BB9860B0A0E \
       51486F0E44E1 8BCC64113B05 B6F4EC0EEB36 4413170A5B48 \
       """)
-    close_fd = True
 
 
-class AifcPCM32Test(audiotests.AudioWriteTests,
-        audiotests.AudioTestsWithSourceFile,
-        unittest.TestCase):
-    module = aifc
+class AifcPCM32Test(AifcTest, unittest.TestCase):
     sndfilename = 'pluck-pcm32.aiff'
     sndfilenframes = 3307
     nchannels = 2
@@ -108,13 +100,9 @@
       E4B49CC00CEA2D90 6344A8800A5A7CA0 08C8FE800A1FFEE0 2BB986C00B0A0E00 \
       51486F800E44E190 8BCC6480113B0580 B6F4EC000EEB3630 441317800A5B48A0 \
       """)
-    close_fd = True
 
 
-class AifcULAWTest(audiotests.AudioWriteTests,
-        audiotests.AudioTestsWithSourceFile,
-        unittest.TestCase):
-    module = aifc
+class AifcULAWTest(AifcTest, unittest.TestCase):
     sndfilename = 'pluck-ulaw.aifc'
     sndfilenframes = 3307
     nchannels = 2
@@ -133,7 +121,6 @@
       """)
     if sys.byteorder != 'big':
         frames = audiotests.byteswap2(frames)
-    close_fd = True
 
 
 class AifcMiscTest(audiotests.AudioTests, unittest.TestCase):
diff -r 3a1db0d2747e Lib/test/test_argparse.py
--- a/Lib/test/test_argparse.py
+++ b/Lib/test/test_argparse.py
@@ -2936,6 +2936,60 @@
         0.1
         '''
 
+class TestShortColumns(HelpTestCase):
+    '''Test extremely small number of columns.
+
+    TestCase prevents "COLUMNS" from being too small in the tests themselves,
+    but we don't want any exceptions thrown in such case. Only ugly representation.
+    '''
+    def setUp(self):
+        env = test_support.EnvironmentVarGuard()
+        env.set("COLUMNS", '15')
+        self.addCleanup(env.__exit__)
+
+    parser_signature            = TestHelpBiggerOptionals.parser_signature
+    argument_signatures         = TestHelpBiggerOptionals.argument_signatures
+    argument_group_signatures   = TestHelpBiggerOptionals.argument_group_signatures
+    usage = '''\
+        usage: PROG
+               [-h]
+               [-v]
+               [-x]
+               [--y Y]
+               foo
+               bar
+        '''
+    help = usage + '''\
+
+        DESCRIPTION
+
+        positional arguments:
+          foo
+            FOO HELP
+          bar
+            BAR HELP
+
+        optional arguments:
+          -h, --help
+            show this
+            help
+            message and
+            exit
+          -v, --version
+            show
+            program's
+            version
+            number and
+            exit
+          -x
+            X HELP
+          --y Y
+            Y HELP
+
+        EPILOG
+    '''
+    version                     = TestHelpBiggerOptionals.version
+
 
 class TestHelpBiggerOptionalGroups(HelpTestCase):
     """Make sure that argument help aligns when options are longer"""
diff -r 3a1db0d2747e Lib/test/test_array.py
--- a/Lib/test/test_array.py
+++ b/Lib/test/test_array.py
@@ -9,6 +9,7 @@
 from weakref import proxy
 import array, cStringIO
 from cPickle import loads, dumps, HIGHEST_PROTOCOL
+import sys
 
 class ArraySubclass(array.array):
     pass
@@ -49,7 +50,7 @@
     def test_constructor(self):
         a = array.array(self.typecode)
         self.assertEqual(a.typecode, self.typecode)
-        self.assertTrue(a.itemsize>=self.minitemsize)
+        self.assertGreaterEqual(a.itemsize, self.minitemsize)
         self.assertRaises(TypeError, array.array, self.typecode, None)
 
     def test_len(self):
@@ -253,39 +254,39 @@
 
     def test_cmp(self):
         a = array.array(self.typecode, self.example)
-        self.assertTrue((a == 42) is False)
-        self.assertTrue((a != 42) is True)
+        self.assertIs(a == 42, False)
+        self.assertIs(a != 42, True)
 
-        self.assertTrue((a == a) is True)
-        self.assertTrue((a != a) is False)
-        self.assertTrue((a < a) is False)
-        self.assertTrue((a <= a) is True)
-        self.assertTrue((a > a) is False)
-        self.assertTrue((a >= a) is True)
+        self.assertIs(a == a, True)
+        self.assertIs(a != a, False)
+        self.assertIs(a < a, False)
+        self.assertIs(a <= a, True)
+        self.assertIs(a > a, False)
+        self.assertIs(a >= a, True)
 
         al = array.array(self.typecode, self.smallerexample)
         ab = array.array(self.typecode, self.biggerexample)
 
-        self.assertTrue((a == 2*a) is False)
-        self.assertTrue((a != 2*a) is True)
-        self.assertTrue((a < 2*a) is True)
-        self.assertTrue((a <= 2*a) is True)
-        self.assertTrue((a > 2*a) is False)
-        self.assertTrue((a >= 2*a) is False)
+        self.assertIs(a == 2*a, False)
+        self.assertIs(a != 2*a, True)
+        self.assertIs(a < 2*a, True)
+        self.assertIs(a <= 2*a, True)
+        self.assertIs(a > 2*a, False)
+        self.assertIs(a >= 2*a, False)
 
-        self.assertTrue((a == al) is False)
-        self.assertTrue((a != al) is True)
-        self.assertTrue((a < al) is False)
-        self.assertTrue((a <= al) is False)
-        self.assertTrue((a > al) is True)
-        self.assertTrue((a >= al) is True)
+        self.assertIs(a == al, False)
+        self.assertIs(a != al, True)
+        self.assertIs(a < al, False)
+        self.assertIs(a <= al, False)
+        self.assertIs(a > al, True)
+        self.assertIs(a >= al, True)
 
-        self.assertTrue((a == ab) is False)
-        self.assertTrue((a != ab) is True)
-        self.assertTrue((a < ab) is True)
-        self.assertTrue((a <= ab) is True)
-        self.assertTrue((a > ab) is False)
-        self.assertTrue((a >= ab) is False)
+        self.assertIs(a == ab, False)
+        self.assertIs(a != ab, True)
+        self.assertIs(a < ab, True)
+        self.assertIs(a <= ab, True)
+        self.assertIs(a > ab, False)
+        self.assertIs(a >= ab, False)
 
     def test_add(self):
         a = array.array(self.typecode, self.example) \
@@ -304,7 +305,7 @@
         a = array.array(self.typecode, self.example[::-1])
         b = a
         a += array.array(self.typecode, 2*self.example)
-        self.assertTrue(a is b)
+        self.assertIs(a, b)
         self.assertEqual(
             a,
             array.array(self.typecode, self.example[::-1]+2*self.example)
@@ -353,22 +354,22 @@
         b = a
 
         a *= 5
-        self.assertTrue(a is b)
+        self.assertIs(a, b)
         self.assertEqual(
             a,
             array.array(self.typecode, 5*self.example)
         )
 
         a *= 0
-        self.assertTrue(a is b)
+        self.assertIs(a, b)
         self.assertEqual(a, array.array(self.typecode))
 
         a *= 1000
-        self.assertTrue(a is b)
+        self.assertIs(a, b)
         self.assertEqual(a, array.array(self.typecode))
 
         a *= -1
-        self.assertTrue(a is b)
+        self.assertIs(a, b)
         self.assertEqual(a, array.array(self.typecode))
 
         a = array.array(self.typecode, self.example)
@@ -753,7 +754,7 @@
         try:
             import gc
         except ImportError:
-            return
+            self.skipTest('gc module not available')
         a = array.array(self.typecode)
         l = [iter(a)]
         l.append(l)
@@ -772,15 +773,15 @@
         s = None
         self.assertRaises(ReferenceError, len, p)
 
+    @unittest.skipUnless(hasattr(sys, 'getrefcount'),
+                         'test needs sys.getrefcount()')
     def test_bug_782369(self):
-        import sys
-        if hasattr(sys, "getrefcount"):
-            for i in range(10):
-                b = array.array('B', range(64))
-            rc = sys.getrefcount(10)
-            for i in range(10):
-                b = array.array('B', range(64))
-            self.assertEqual(rc, sys.getrefcount(10))
+        for i in range(10):
+            b = array.array('B', range(64))
+        rc = sys.getrefcount(10)
+        for i in range(10):
+            b = array.array('B', range(64))
+        self.assertEqual(rc, sys.getrefcount(10))
 
     def test_subclass_with_kwargs(self):
         # SF bug #1486663 -- this used to erroneously raise a TypeError
diff -r 3a1db0d2747e Lib/test/test_bsddb.py
--- a/Lib/test/test_bsddb.py
+++ b/Lib/test/test_bsddb.py
@@ -47,10 +47,7 @@
         self.assertIn('discovered', self.f.values())
 
     def test_close_and_reopen(self):
-        if self.fname is None:
-            # if we're using an in-memory only db, we can't reopen it
-            # so finish here.
-            return
+        self.assertIsNotNone(self.fname)
         self.f.close()
         self.f = self.openmethod[0](self.fname, 'w')
         for k, v in self.d.iteritems():
@@ -309,8 +306,7 @@
             self.assertEqual(self.f[k], v)
 
     def test_keyordering(self):
-        if self.openmethod[0] is not bsddb.btopen:
-            return
+        self.assertIs(self.openmethod[0], bsddb.btopen)
         keys = self.d.keys()
         keys.sort()
         self.assertEqual(self.f.first()[0], keys[0])
@@ -327,19 +323,34 @@
     fname = None
     openmethod = [bsddb.btopen]
 
+    # if we're using an in-memory only db, we can't reopen it
+    test_close_and_reopen = None
+
 class TestBTree_InMemory_Truncate(TestBSDDB):
     fname = None
     openflag = 'n'
     openmethod = [bsddb.btopen]
 
+    # if we're using an in-memory only db, we can't reopen it
+    test_close_and_reopen = None
+
 class TestHashTable(TestBSDDB):
     fname = test_support.TESTFN
     openmethod = [bsddb.hashopen]
 
+    # keyordering is specific to btopen method
+    test_keyordering = None
+
 class TestHashTable_InMemory(TestBSDDB):
     fname = None
     openmethod = [bsddb.hashopen]
 
+    # if we're using an in-memory only db, we can't reopen it
+    test_close_and_reopen = None
+
+    # keyordering is specific to btopen method
+    test_keyordering = None
+
 ##         # (bsddb.rnopen,'Record Numbers'), 'put' for RECNO for bsddb 1.85
 ##         #                                   appears broken... at least on
 ##         #                                   Solaris Intel - rmasse 1/97
diff -r 3a1db0d2747e Lib/test/test_builtin.py
--- a/Lib/test/test_builtin.py
+++ b/Lib/test/test_builtin.py
@@ -447,59 +447,6 @@
                 return 'a'
         self.assertRaises(TypeError, eval, 'dir()', globals(), C())
 
-    # Done outside of the method test_z to get the correct scope
-    z = 0
-    f = open(TESTFN, 'w')
-    f.write('z = z+1\n')
-    f.write('z = z*2\n')
-    f.close()
-    with check_py3k_warnings(("execfile.. not supported in 3.x",
-                              DeprecationWarning)):
-        execfile(TESTFN)
-
-    def test_execfile(self):
-        global numruns
-        if numruns:
-            return
-        numruns += 1
-
-        globals = {'a': 1, 'b': 2}
-        locals = {'b': 200, 'c': 300}
-
-        self.assertEqual(self.__class__.z, 2)
-        globals['z'] = 0
-        execfile(TESTFN, globals)
-        self.assertEqual(globals['z'], 2)
-        locals['z'] = 0
-        execfile(TESTFN, globals, locals)
-        self.assertEqual(locals['z'], 2)
-
-        class M:
-            "Test mapping interface versus possible calls from execfile()."
-            def __init__(self):
-                self.z = 10
-            def __getitem__(self, key):
-                if key == 'z':
-                    return self.z
-                raise KeyError
-            def __setitem__(self, key, value):
-                if key == 'z':
-                    self.z = value
-                    return
-                raise KeyError
-
-        locals = M()
-        locals['z'] = 0
-        execfile(TESTFN, globals, locals)
-        self.assertEqual(locals['z'], 2)
-
-        unlink(TESTFN)
-        self.assertRaises(TypeError, execfile)
-        self.assertRaises(TypeError, execfile, TESTFN, {}, ())
-        import os
-        self.assertRaises(IOError, execfile, os.curdir)
-        self.assertRaises(IOError, execfile, "I_dont_exist")
-
     def test_filter(self):
         self.assertEqual(filter(lambda c: 'a' <= c <= 'z', 'Hello World'), 'elloorld')
         self.assertEqual(filter(None, [1, 'hello', [], [3], '', None, 9, 0]), [1, 'hello', [3], 9])
@@ -1646,6 +1593,56 @@
         self.assertRaises(ValueError, x.translate, "1", 1)
         self.assertRaises(TypeError, x.translate, "1"*256, 1)
 
+class TestExecFile(unittest.TestCase):
+    # Done outside of the method test_z to get the correct scope
+    z = 0
+    f = open(TESTFN, 'w')
+    f.write('z = z+1\n')
+    f.write('z = z*2\n')
+    f.close()
+    with check_py3k_warnings(("execfile.. not supported in 3.x",
+                              DeprecationWarning)):
+        execfile(TESTFN)
+
+    def test_execfile(self):
+        globals = {'a': 1, 'b': 2}
+        locals = {'b': 200, 'c': 300}
+
+        self.assertEqual(self.__class__.z, 2)
+        globals['z'] = 0
+        execfile(TESTFN, globals)
+        self.assertEqual(globals['z'], 2)
+        locals['z'] = 0
+        execfile(TESTFN, globals, locals)
+        self.assertEqual(locals['z'], 2)
+
+        class M:
+            "Test mapping interface versus possible calls from execfile()."
+            def __init__(self):
+                self.z = 10
+            def __getitem__(self, key):
+                if key == 'z':
+                    return self.z
+                raise KeyError
+            def __setitem__(self, key, value):
+                if key == 'z':
+                    self.z = value
+                    return
+                raise KeyError
+
+        locals = M()
+        locals['z'] = 0
+        execfile(TESTFN, globals, locals)
+        self.assertEqual(locals['z'], 2)
+
+        unlink(TESTFN)
+        self.assertRaises(TypeError, execfile)
+        self.assertRaises(TypeError, execfile, TESTFN, {}, ())
+        import os
+        self.assertRaises(IOError, execfile, os.curdir)
+        self.assertRaises(IOError, execfile, "I_dont_exist")
+
+
 class TestSorted(unittest.TestCase):
 
     def test_basic(self):
@@ -1693,6 +1690,12 @@
         run_unittest(*args)
 
 def test_main(verbose=None):
+    global numruns
+    if not numruns:
+        with check_py3k_warnings(
+                (".+ not supported in 3.x", DeprecationWarning)):
+            run_unittest(TestExecFile)
+    numruns += 1
     test_classes = (BuiltinTest, TestSorted)
 
     _run_unittest(*test_classes)
diff -r 3a1db0d2747e Lib/test/test_bz2.py
--- a/Lib/test/test_bz2.py
+++ b/Lib/test/test_bz2.py
@@ -325,6 +325,21 @@
             self.assertRaises(ValueError, f.readline)
             self.assertRaises(ValueError, f.readlines)
 
+    @unittest.skipIf(sys.platform == 'win32',
+                     'test depends on being able to delete a still-open file,'
+                     ' which is not possible on Windows')
+    def testInitNonExistentFile(self):
+        # Issue #19878: Should not segfault when __init__ with non-existent
+        # file for the second time.
+        self.createTempFile()
+        # Test close():
+        with BZ2File(self.filename, "wb") as f:
+            self.assertRaises(IOError, f.__init__, "non-existent-file")
+        # Test object deallocation without call to close():
+        f = bz2.BZ2File(self.filename)
+        self.assertRaises(IOError, f.__init__, "non-existent-file")
+        del f
+
 class BZ2CompressorTest(BaseTest):
     def testCompress(self):
         # "Test BZ2Compressor.compress()/flush()"
diff -r 3a1db0d2747e Lib/test/test_cfgparser.py
--- a/Lib/test/test_cfgparser.py
+++ b/Lib/test/test_cfgparser.py
@@ -284,13 +284,17 @@
         cf.set("sect", "option1", mystr("splat"))
         cf.set("sect", "option2", "splat")
         cf.set("sect", "option2", mystr("splat"))
+
+    def test_set_unicode(self):
         try:
             unicode
         except NameError:
-            pass
-        else:
-            cf.set("sect", "option1", unicode("splat"))
-            cf.set("sect", "option2", unicode("splat"))
+            self.skipTest('no unicode support')
+
+        cf = self.fromstring("[sect]\n"
+                             "option1=foo\n")
+        cf.set("sect", "option1", unicode("splat"))
+        cf.set("sect", "option2", unicode("splat"))
 
     def test_read_returns_file_list(self):
         file1 = test_support.findfile("cfgparser.1")
diff -r 3a1db0d2747e Lib/test/test_cmath.py
--- a/Lib/test/test_cmath.py
+++ b/Lib/test/test_cmath.py
@@ -282,7 +282,7 @@
 
     def test_specific_values(self):
         if not float.__getformat__("double").startswith("IEEE"):
-            return
+            self.skipTest('needs IEEE double')
 
         def rect_complex(z):
             """Wrapped version of rect that accepts a complex number instead of
diff -r 3a1db0d2747e Lib/test/test_codecencodings_iso2022.py
--- a/Lib/test/test_codecencodings_iso2022.py
+++ b/Lib/test/test_codecencodings_iso2022.py
@@ -36,6 +36,7 @@
 
     # iso2022_kr.txt cannot be used to test "chunk coding": the escape
     # sequence is only written on the first line
+    @unittest.skip('iso2022_kr.txt cannot be used to test "chunk coding"')
     def test_chunkcoding(self):
         pass
 
diff -r 3a1db0d2747e Lib/test/test_collections.py
--- a/Lib/test/test_collections.py
+++ b/Lib/test/test_collections.py
@@ -594,6 +594,35 @@
         s |= s
         self.assertEqual(s, full)
 
+    def test_issue16373(self):
+        # Recursion error comparing comparable and noncomparable
+        # Set instances
+        class MyComparableSet(Set):
+            def __contains__(self, x):
+                return False
+            def __len__(self):
+                return 0
+            def __iter__(self):
+                return iter([])
+        class MyNonComparableSet(Set):
+            def __contains__(self, x):
+                return False
+            def __len__(self):
+                return 0
+            def __iter__(self):
+                return iter([])
+            def __le__(self, x):
+                return NotImplemented
+            def __lt__(self, x):
+                return NotImplemented
+
+        cs = MyComparableSet()
+        ncs = MyNonComparableSet()
+        self.assertFalse(ncs < cs)
+        self.assertFalse(ncs <= cs)
+        self.assertFalse(cs > ncs)
+        self.assertFalse(cs >= ncs)
+
     def test_Mapping(self):
         for sample in [dict]:
             self.assertIsInstance(sample(), Mapping)
diff -r 3a1db0d2747e Lib/test/test_compileall.py
--- a/Lib/test/test_compileall.py
+++ b/Lib/test/test_compileall.py
@@ -31,11 +31,10 @@
         compare = struct.pack('<4sl', imp.get_magic(), mtime)
         return data, compare
 
+    @unittest.skipUnless(hasattr(os, 'stat'), 'test needs os.stat()')
     def recreation_check(self, metadata):
         """Check that compileall recreates bytecode when the new metadata is
         used."""
-        if not hasattr(os, 'stat'):
-            return
         py_compile.compile(self.source_path)
         self.assertEqual(*self.data())
         with open(self.bc_path, 'rb') as file:
diff -r 3a1db0d2747e Lib/test/test_cookielib.py
--- a/Lib/test/test_cookielib.py
+++ b/Lib/test/test_cookielib.py
@@ -26,8 +26,9 @@
         az = time2isoz()
         bz = time2isoz(500000)
         for text in (az, bz):
-            self.assertTrue(re.search(r"^\d{4}-\d\d-\d\d \d\d:\d\d:\d\dZ$", text),
-                         "bad time2isoz format: %s %s" % (az, bz))
+            self.assertRegexpMatches(text,
+                                     r"^\d{4}-\d\d-\d\d \d\d:\d\d:\d\dZ$",
+                                     "bad time2isoz format: %s %s" % (az, bz))
 
     def test_http2time(self):
         from cookielib import http2time
@@ -75,12 +76,9 @@
                          "%s  =>  '%s' (%s)" % (test_t, result, expected))
 
         for s in tests:
-            t = http2time(s)
-            t2 = http2time(s.lower())
-            t3 = http2time(s.upper())
-
-            self.assertTrue(t == t2 == t3 == test_t,
-                         "'%s'  =>  %s, %s, %s (%s)" % (s, t, t2, t3, test_t))
+            self.assertEqual(http2time(s), test_t, s)
+            self.assertEqual(http2time(s.lower()), test_t, s.lower())
+            self.assertEqual(http2time(s.upper()), test_t, s.upper())
 
     def test_http2time_garbage(self):
         from cookielib import http2time
@@ -367,7 +365,7 @@
             request = urllib2.Request(url)
             r = pol.domain_return_ok(domain, request)
             if ok: self.assertTrue(r)
-            else: self.assertTrue(not r)
+            else: self.assertFalse(r)
 
     def test_missing_value(self):
         from cookielib import MozillaCookieJar, lwp_cookie_str
@@ -379,10 +377,10 @@
         interact_netscape(c, "http://www.acme.com/", 'eggs')
         interact_netscape(c, "http://www.acme.com/", '"spam"; path=/foo/')
         cookie = c._cookies["www.acme.com"]["/"]["eggs"]
-        self.assertTrue(cookie.value is None)
+        self.assertIsNone(cookie.value)
         self.assertEqual(cookie.name, "eggs")
         cookie = c._cookies["www.acme.com"]['/foo/']['"spam"']
-        self.assertTrue(cookie.value is None)
+        self.assertIsNone(cookie.value)
         self.assertEqual(cookie.name, '"spam"')
         self.assertEqual(lwp_cookie_str(cookie), (
             r'"spam"; path="/foo/"; domain="www.acme.com"; '
@@ -426,7 +424,7 @@
             try:
                 cookie = c._cookies["www.example.com"]["/"]["ni"]
             except KeyError:
-                self.assertTrue(version is None)  # didn't expect a stored cookie
+                self.assertIsNone(version)  # didn't expect a stored cookie
             else:
                 self.assertEqual(cookie.version, version)
                 # 2965 cookies are unaffected
@@ -452,26 +450,26 @@
         self.assertEqual(cookie.domain, ".acme.com")
         self.assertTrue(cookie.domain_specified)
         self.assertEqual(cookie.port, DEFAULT_HTTP_PORT)
-        self.assertTrue(not cookie.port_specified)
+        self.assertFalse(cookie.port_specified)
         # case is preserved
-        self.assertTrue(cookie.has_nonstandard_attr("blArgh") and
-                     not cookie.has_nonstandard_attr("blargh"))
+        self.assertTrue(cookie.has_nonstandard_attr("blArgh"))
+        self.assertFalse(cookie.has_nonstandard_attr("blargh"))
 
         cookie = c._cookies["www.acme.com"]["/"]["ni"]
         self.assertEqual(cookie.domain, "www.acme.com")
-        self.assertTrue(not cookie.domain_specified)
+        self.assertFalse(cookie.domain_specified)
         self.assertEqual(cookie.port, "80,8080")
         self.assertTrue(cookie.port_specified)
 
         cookie = c._cookies["www.acme.com"]["/"]["nini"]
-        self.assertTrue(cookie.port is None)
-        self.assertTrue(not cookie.port_specified)
+        self.assertIsNone(cookie.port)
+        self.assertFalse(cookie.port_specified)
 
         # invalid expires should not cause cookie to be dropped
         foo = c._cookies["www.acme.com"]["/"]["foo"]
         spam = c._cookies["www.acme.com"]["/"]["foo"]
-        self.assertTrue(foo.expires is None)
-        self.assertTrue(spam.expires is None)
+        self.assertIsNone(foo.expires)
+        self.assertIsNone(spam.expires)
 
     def test_ns_parser_special_names(self):
         # names such as 'expires' are not special in first name=value pair
@@ -655,12 +653,12 @@
         from cookielib import is_HDN
         self.assertTrue(is_HDN("foo.bar.com"))
         self.assertTrue(is_HDN("1foo2.3bar4.5com"))
-        self.assertTrue(not is_HDN("192.168.1.1"))
-        self.assertTrue(not is_HDN(""))
-        self.assertTrue(not is_HDN("."))
-        self.assertTrue(not is_HDN(".foo.bar.com"))
-        self.assertTrue(not is_HDN("..foo"))
-        self.assertTrue(not is_HDN("foo."))
+        self.assertFalse(is_HDN("192.168.1.1"))
+        self.assertFalse(is_HDN(""))
+        self.assertFalse(is_HDN("."))
+        self.assertFalse(is_HDN(".foo.bar.com"))
+        self.assertFalse(is_HDN("..foo"))
+        self.assertFalse(is_HDN("foo."))
 
     def test_reach(self):
         from cookielib import reach
@@ -676,39 +674,39 @@
     def test_domain_match(self):
         from cookielib import domain_match, user_domain_match
         self.assertTrue(domain_match("192.168.1.1", "192.168.1.1"))
-        self.assertTrue(not domain_match("192.168.1.1", ".168.1.1"))
+        self.assertFalse(domain_match("192.168.1.1", ".168.1.1"))
         self.assertTrue(domain_match("x.y.com", "x.Y.com"))
         self.assertTrue(domain_match("x.y.com", ".Y.com"))
-        self.assertTrue(not domain_match("x.y.com", "Y.com"))
+        self.assertFalse(domain_match("x.y.com", "Y.com"))
         self.assertTrue(domain_match("a.b.c.com", ".c.com"))
-        self.assertTrue(not domain_match(".c.com", "a.b.c.com"))
+        self.assertFalse(domain_match(".c.com", "a.b.c.com"))
         self.assertTrue(domain_match("example.local", ".local"))
-        self.assertTrue(not domain_match("blah.blah", ""))
-        self.assertTrue(not domain_match("", ".rhubarb.rhubarb"))
+        self.assertFalse(domain_match("blah.blah", ""))
+        self.assertFalse(domain_match("", ".rhubarb.rhubarb"))
         self.assertTrue(domain_match("", ""))
 
         self.assertTrue(user_domain_match("acme.com", "acme.com"))
-        self.assertTrue(not user_domain_match("acme.com", ".acme.com"))
+        self.assertFalse(user_domain_match("acme.com", ".acme.com"))
         self.assertTrue(user_domain_match("rhubarb.acme.com", ".acme.com"))
         self.assertTrue(user_domain_match("www.rhubarb.acme.com", ".acme.com"))
         self.assertTrue(user_domain_match("x.y.com", "x.Y.com"))
         self.assertTrue(user_domain_match("x.y.com", ".Y.com"))
-        self.assertTrue(not user_domain_match("x.y.com", "Y.com"))
+        self.assertFalse(user_domain_match("x.y.com", "Y.com"))
         self.assertTrue(user_domain_match("y.com", "Y.com"))
-        self.assertTrue(not user_domain_match(".y.com", "Y.com"))
+        self.assertFalse(user_domain_match(".y.com", "Y.com"))
         self.assertTrue(user_domain_match(".y.com", ".Y.com"))
         self.assertTrue(user_domain_match("x.y.com", ".com"))
-        self.assertTrue(not user_domain_match("x.y.com", "com"))
-        self.assertTrue(not user_domain_match("x.y.com", "m"))
-        self.assertTrue(not user_domain_match("x.y.com", ".m"))
-        self.assertTrue(not user_domain_match("x.y.com", ""))
-        self.assertTrue(not user_domain_match("x.y.com", "."))
+        self.assertFalse(user_domain_match("x.y.com", "com"))
+        self.assertFalse(user_domain_match("x.y.com", "m"))
+        self.assertFalse(user_domain_match("x.y.com", ".m"))
+        self.assertFalse(user_domain_match("x.y.com", ""))
+        self.assertFalse(user_domain_match("x.y.com", "."))
         self.assertTrue(user_domain_match("192.168.1.1", "192.168.1.1"))
         # not both HDNs, so must string-compare equal to match
-        self.assertTrue(not user_domain_match("192.168.1.1", ".168.1.1"))
-        self.assertTrue(not user_domain_match("192.168.1.1", "."))
+        self.assertFalse(user_domain_match("192.168.1.1", ".168.1.1"))
+        self.assertFalse(user_domain_match("192.168.1.1", "."))
         # empty string is a special case
-        self.assertTrue(not user_domain_match("192.168.1.1", ""))
+        self.assertFalse(user_domain_match("192.168.1.1", ""))
 
     def test_wrong_domain(self):
         # Cookies whose effective request-host name does not domain-match the
@@ -865,7 +863,7 @@
         self.assertEqual(len(c), 2)
         # ... and check is doesn't get returned
         c.add_cookie_header(req)
-        self.assertTrue(not req.has_header("Cookie"))
+        self.assertFalse(req.has_header("Cookie"))
 
     def test_domain_block(self):
         from cookielib import CookieJar, DefaultCookiePolicy
@@ -892,8 +890,8 @@
         self.assertEqual(len(c), 1)
         req = Request("http://www.roadrunner.net/")
         c.add_cookie_header(req)
-        self.assertTrue((req.has_header("Cookie") and
-                      req.has_header("Cookie2")))
+        self.assertTrue(req.has_header("Cookie"))
+        self.assertTrue(req.has_header("Cookie2"))
 
         c.clear()
         pol.set_blocked_domains([".acme.com"])
@@ -908,7 +906,7 @@
         self.assertEqual(len(c), 2)
         # ... and check is doesn't get returned
         c.add_cookie_header(req)
-        self.assertTrue(not req.has_header("Cookie"))
+        self.assertFalse(req.has_header("Cookie"))
 
     def test_secure(self):
         from cookielib import CookieJar, DefaultCookiePolicy
@@ -928,8 +926,8 @@
                 url = "http://www.acme.com/"
                 int(c, url, "foo1=bar%s%s" % (vs, whitespace))
                 int(c, url, "foo2=bar%s; secure%s" %  (vs, whitespace))
-                self.assertTrue(
-                    not c._cookies["www.acme.com"]["/"]["foo1"].secure,
+                self.assertFalse(
+                    c._cookies["www.acme.com"]["/"]["foo1"].secure,
                     "non-secure cookie registered secure")
                 self.assertTrue(
                     c._cookies["www.acme.com"]["/"]["foo2"].secure,
@@ -1011,8 +1009,8 @@
         url = "http://foo.bar.com/"
         interact_2965(c, url, "spam=eggs; Version=1; Port")
         h = interact_2965(c, url)
-        self.assertTrue(re.search("\$Port([^=]|$)", h),
-                     "port with no value not returned with no value")
+        self.assertRegexpMatches(h, "\$Port([^=]|$)",
+                    "port with no value not returned with no value")
 
         c = CookieJar(pol)
         url = "http://foo.bar.com/"
@@ -1038,8 +1036,7 @@
                       'Comment="does anybody read these?"; '
                       'CommentURL="http://foo.bar.net/comment.html"')
         h = interact_2965(c, url)
-        self.assertTrue(
-            "Comment" not in h,
+        self.assertNotIn("Comment", h,
             "Comment or CommentURL cookie-attributes returned to server")
 
     def test_Cookie_iterator(self):
@@ -1128,7 +1125,7 @@
         headers = ["Set-Cookie: c=foo; expires=Foo Bar 12 33:22:11 2000"]
         c = cookiejar_from_cookie_headers(headers)
         cookie = c._cookies["www.example.com"]["/"]["c"]
-        self.assertTrue(cookie.expires is None)
+        self.assertIsNone(cookie.expires)
 
 
 class LWPCookieTests(TestCase):
@@ -1278,9 +1275,9 @@
         req = Request("http://www.acme.com/ammo")
         c.add_cookie_header(req)
 
-        self.assertTrue(re.search(r"PART_NUMBER=RIDING_ROCKET_0023;\s*"
-                               "PART_NUMBER=ROCKET_LAUNCHER_0001",
-                               req.get_header("Cookie")))
+        self.assertRegexpMatches(req.get_header("Cookie"),
+                                 r"PART_NUMBER=RIDING_ROCKET_0023;\s*"
+                                  "PART_NUMBER=ROCKET_LAUNCHER_0001")
 
     def test_ietf_example_1(self):
         from cookielib import CookieJar, DefaultCookiePolicy
@@ -1314,7 +1311,7 @@
         cookie = interact_2965(
             c, 'http://www.acme.com/acme/login',
             'Customer="WILE_E_COYOTE"; Version="1"; Path="/acme"')
-        self.assertTrue(not cookie)
+        self.assertFalse(cookie)
 
         #
         #   3.  User Agent -> Server
@@ -1336,9 +1333,8 @@
         cookie = interact_2965(c, 'http://www.acme.com/acme/pickitem',
                                'Part_Number="Rocket_Launcher_0001"; '
                                'Version="1"; Path="/acme"');
-        self.assertTrue(re.search(
-            r'^\$Version="?1"?; Customer="?WILE_E_COYOTE"?; \$Path="/acme"$',
-            cookie))
+        self.assertRegexpMatches(cookie,
+            r'^\$Version="?1"?; Customer="?WILE_E_COYOTE"?; \$Path="/acme"$')
 
         #
         #   5.  User Agent -> Server
@@ -1361,11 +1357,11 @@
         cookie = interact_2965(c, "http://www.acme.com/acme/shipping",
                                'Shipping="FedEx"; Version="1"; Path="/acme"')
 
-        self.assertTrue(re.search(r'^\$Version="?1"?;', cookie))
-        self.assertTrue(re.search(r'Part_Number="?Rocket_Launcher_0001"?;'
-                               '\s*\$Path="\/acme"', cookie))
-        self.assertTrue(re.search(r'Customer="?WILE_E_COYOTE"?;\s*\$Path="\/acme"',
-                               cookie))
+        self.assertRegexpMatches(cookie, r'^\$Version="?1"?;')
+        self.assertRegexpMatches(cookie,
+                r'Part_Number="?Rocket_Launcher_0001"?;\s*\$Path="\/acme"')
+        self.assertRegexpMatches(cookie,
+                r'Customer="?WILE_E_COYOTE"?;\s*\$Path="\/acme"')
 
         #
         #   7.  User Agent -> Server
@@ -1386,9 +1382,9 @@
         #       Transaction is complete.
 
         cookie = interact_2965(c, "http://www.acme.com/acme/process")
-        self.assertTrue(
-            re.search(r'Shipping="?FedEx"?;\s*\$Path="\/acme"', cookie) and
-            "WILE_E_COYOTE" in cookie)
+        self.assertRegexpMatches(cookie,
+                                 r'Shipping="?FedEx"?;\s*\$Path="\/acme"')
+        self.assertIn("WILE_E_COYOTE", cookie)
 
         #
         # The user agent makes a series of requests on the origin server, after
@@ -1437,8 +1433,8 @@
         # than once.
 
         cookie = interact_2965(c, "http://www.acme.com/acme/ammo/...")
-        self.assertTrue(
-            re.search(r"Riding_Rocket_0023.*Rocket_Launcher_0001", cookie))
+        self.assertRegexpMatches(cookie,
+                                 r"Riding_Rocket_0023.*Rocket_Launcher_0001")
 
         # A subsequent request by the user agent to the (same) server for a URL of
         # the form /acme/parts/ would include the following request header:
@@ -1466,7 +1462,7 @@
         # illegal domain (no embedded dots)
         cookie = interact_2965(c, "http://www.acme.com",
                                'foo=bar; domain=".com"; version=1')
-        self.assertTrue(not c)
+        self.assertFalse(c)
 
         # legal domain
         cookie = interact_2965(c, "http://www.acme.com",
@@ -1559,11 +1555,12 @@
             c, "http://www.acme.com/foo%2f%25/<<%0anew/",
             'bar=baz; path="/foo/"; version=1');
         version_re = re.compile(r'^\$version=\"?1\"?', re.I)
-        self.assertTrue("foo=bar" in cookie and version_re.search(cookie))
+        self.assertIn("foo=bar", cookie)
+        self.assertRegexpMatches(cookie, version_re)
 
         cookie = interact_2965(
             c, "http://www.acme.com/foo/%25/<<%0anew/")
-        self.assertTrue(not cookie)
+        self.assertFalse(cookie)
 
         # unicode URL doesn't raise exception
         cookie = interact_2965(c, u"http://www.acme.com/\xfc")
@@ -1740,13 +1737,12 @@
             key = "%s_after" % cookie.value
             counter[key] = counter[key] + 1
 
-        self.assertTrue(not (
-            # a permanent cookie got lost accidentally
-            counter["perm_after"] != counter["perm_before"] or
+            # a permanent cookie got lost accidently
+        self.assertEqual(counter["perm_after"], counter["perm_before"])
             # a session cookie hasn't been cleared
-            counter["session_after"] != 0 or
+        self.assertEqual(counter["session_after"], 0)
             # we didn't have session cookies in the first place
-            counter["session_before"] == 0))
+        self.assertNotEqual(counter["session_before"], 0)
 
 
 def test_main(verbose=None):
diff -r 3a1db0d2747e Lib/test/test_csv.py
--- a/Lib/test/test_csv.py
+++ b/Lib/test/test_csv.py
@@ -630,6 +630,23 @@
         fileobj = StringIO()
         self.assertRaises(TypeError, csv.DictWriter, fileobj)
 
+    def test_write_fields_not_in_fieldnames(self):
+        fd, name = tempfile.mkstemp()
+        fileobj = os.fdopen(fd, "w+b")
+        try:
+            writer = csv.DictWriter(fileobj, fieldnames = ["f1", "f2", "f3"])
+            # Of special note is the non-string key (issue 19449)
+            with self.assertRaises(ValueError) as cx:
+                writer.writerow({"f4": 10, "f2": "spam", 1: "abc"})
+            exception = str(cx.exception)
+            self.assertIn("fieldnames", exception)
+            self.assertIn("'f4'", exception)
+            self.assertNotIn("'f2'", exception)
+            self.assertIn("1", exception)
+        finally:
+            fileobj.close()
+            os.unlink(name)
+
     def test_read_dict_fields(self):
         fd, name = tempfile.mkstemp()
         fileobj = os.fdopen(fd, "w+b")
@@ -853,6 +870,7 @@
             lineterminator = '\r\n'
             quoting = csv.QUOTE_NONE
         d = mydialect()
+        self.assertEqual(d.quoting, csv.QUOTE_NONE)
 
         mydialect.quoting = None
         self.assertRaises(csv.Error, mydialect)
@@ -861,12 +879,21 @@
         mydialect.quoting = csv.QUOTE_ALL
         mydialect.quotechar = '"'
         d = mydialect()
+        self.assertEqual(d.quoting, csv.QUOTE_ALL)
+        self.assertEqual(d.quotechar, '"')
+        self.assertTrue(d.doublequote)
 
         mydialect.quotechar = "''"
-        self.assertRaises(csv.Error, mydialect)
+        with self.assertRaises(csv.Error) as cm:
+            mydialect()
+        self.assertEqual(str(cm.exception),
+                         '"quotechar" must be an 1-character string')
 
         mydialect.quotechar = 4
-        self.assertRaises(csv.Error, mydialect)
+        with self.assertRaises(csv.Error) as cm:
+            mydialect()
+        self.assertEqual(str(cm.exception),
+                         '"quotechar" must be string, not int')
 
     def test_delimiter(self):
         class mydialect(csv.Dialect):
@@ -877,12 +904,31 @@
             lineterminator = '\r\n'
             quoting = csv.QUOTE_NONE
         d = mydialect()
+        self.assertEqual(d.delimiter, ";")
 
         mydialect.delimiter = ":::"
-        self.assertRaises(csv.Error, mydialect)
+        with self.assertRaises(csv.Error) as cm:
+            mydialect()
+        self.assertEqual(str(cm.exception),
+                         '"delimiter" must be an 1-character string')
+
+        mydialect.delimiter = ""
+        with self.assertRaises(csv.Error) as cm:
+            mydialect()
+        self.assertEqual(str(cm.exception),
+                         '"delimiter" must be an 1-character string')
+
+        mydialect.delimiter = u","
+        with self.assertRaises(csv.Error) as cm:
+            mydialect()
+        self.assertEqual(str(cm.exception),
+                         '"delimiter" must be string, not unicode')
 
         mydialect.delimiter = 4
-        self.assertRaises(csv.Error, mydialect)
+        with self.assertRaises(csv.Error) as cm:
+            mydialect()
+        self.assertEqual(str(cm.exception),
+                         '"delimiter" must be string, not int')
 
     def test_lineterminator(self):
         class mydialect(csv.Dialect):
@@ -893,12 +939,17 @@
             lineterminator = '\r\n'
             quoting = csv.QUOTE_NONE
         d = mydialect()
+        self.assertEqual(d.lineterminator, '\r\n')
 
         mydialect.lineterminator = ":::"
         d = mydialect()
+        self.assertEqual(d.lineterminator, ":::")
 
         mydialect.lineterminator = 4
-        self.assertRaises(csv.Error, mydialect)
+        with self.assertRaises(csv.Error) as cm:
+            mydialect()
+        self.assertEqual(str(cm.exception),
+                         '"lineterminator" must be a string')
 
 
 class TestSniffer(unittest.TestCase):
@@ -1014,78 +1065,77 @@
         dialect = sniffer.sniff(self.sample9)
         self.assertTrue(dialect.doublequote)
 
-if not hasattr(sys, "gettotalrefcount"):
-    if test_support.verbose: print "*** skipping leakage tests ***"
-else:
-    class NUL:
-        def write(s, *args):
-            pass
-        writelines = write
+class NUL:
+    def write(s, *args):
+        pass
+    writelines = write
 
-    class TestLeaks(unittest.TestCase):
-        def test_create_read(self):
-            delta = 0
-            lastrc = sys.gettotalrefcount()
-            for i in xrange(20):
-                gc.collect()
-                self.assertEqual(gc.garbage, [])
-                rc = sys.gettotalrefcount()
-                csv.reader(["a,b,c\r\n"])
-                csv.reader(["a,b,c\r\n"])
-                csv.reader(["a,b,c\r\n"])
-                delta = rc-lastrc
-                lastrc = rc
-            # if csv.reader() leaks, last delta should be 3 or more
-            self.assertEqual(delta < 3, True)
+@unittest.skipUnless(hasattr(sys, "gettotalrefcount"),
+                     'requires sys.gettotalrefcount()')
+class TestLeaks(unittest.TestCase):
+    def test_create_read(self):
+        delta = 0
+        lastrc = sys.gettotalrefcount()
+        for i in xrange(20):
+            gc.collect()
+            self.assertEqual(gc.garbage, [])
+            rc = sys.gettotalrefcount()
+            csv.reader(["a,b,c\r\n"])
+            csv.reader(["a,b,c\r\n"])
+            csv.reader(["a,b,c\r\n"])
+            delta = rc-lastrc
+            lastrc = rc
+        # if csv.reader() leaks, last delta should be 3 or more
+        self.assertEqual(delta < 3, True)
 
-        def test_create_write(self):
-            delta = 0
-            lastrc = sys.gettotalrefcount()
-            s = NUL()
-            for i in xrange(20):
-                gc.collect()
-                self.assertEqual(gc.garbage, [])
-                rc = sys.gettotalrefcount()
-                csv.writer(s)
-                csv.writer(s)
-                csv.writer(s)
-                delta = rc-lastrc
-                lastrc = rc
-            # if csv.writer() leaks, last delta should be 3 or more
-            self.assertEqual(delta < 3, True)
+    def test_create_write(self):
+        delta = 0
+        lastrc = sys.gettotalrefcount()
+        s = NUL()
+        for i in xrange(20):
+            gc.collect()
+            self.assertEqual(gc.garbage, [])
+            rc = sys.gettotalrefcount()
+            csv.writer(s)
+            csv.writer(s)
+            csv.writer(s)
+            delta = rc-lastrc
+            lastrc = rc
+        # if csv.writer() leaks, last delta should be 3 or more
+        self.assertEqual(delta < 3, True)
 
-        def test_read(self):
-            delta = 0
-            rows = ["a,b,c\r\n"]*5
-            lastrc = sys.gettotalrefcount()
-            for i in xrange(20):
-                gc.collect()
-                self.assertEqual(gc.garbage, [])
-                rc = sys.gettotalrefcount()
-                rdr = csv.reader(rows)
-                for row in rdr:
-                    pass
-                delta = rc-lastrc
-                lastrc = rc
-            # if reader leaks during read, delta should be 5 or more
-            self.assertEqual(delta < 5, True)
+    def test_read(self):
+        delta = 0
+        rows = ["a,b,c\r\n"]*5
+        lastrc = sys.gettotalrefcount()
+        for i in xrange(20):
+            gc.collect()
+            self.assertEqual(gc.garbage, [])
+            rc = sys.gettotalrefcount()
+            rdr = csv.reader(rows)
+            for row in rdr:
+                pass
+            delta = rc-lastrc
+            lastrc = rc
+        # if reader leaks during read, delta should be 5 or more
+        self.assertEqual(delta < 5, True)
 
-        def test_write(self):
-            delta = 0
-            rows = [[1,2,3]]*5
-            s = NUL()
-            lastrc = sys.gettotalrefcount()
-            for i in xrange(20):
-                gc.collect()
-                self.assertEqual(gc.garbage, [])
-                rc = sys.gettotalrefcount()
-                writer = csv.writer(s)
-                for row in rows:
-                    writer.writerow(row)
-                delta = rc-lastrc
-                lastrc = rc
-            # if writer leaks during write, last delta should be 5 or more
-            self.assertEqual(delta < 5, True)
+    def test_write(self):
+        delta = 0
+        rows = [[1,2,3]]*5
+        s = NUL()
+        lastrc = sys.gettotalrefcount()
+        for i in xrange(20):
+            gc.collect()
+            self.assertEqual(gc.garbage, [])
+            rc = sys.gettotalrefcount()
+            writer = csv.writer(s)
+            for row in rows:
+                writer.writerow(row)
+            delta = rc-lastrc
+            lastrc = rc
+        # if writer leaks during write, last delta should be 5 or more
+        self.assertEqual(delta < 5, True)
 
 # commented out for now - csv module doesn't yet support Unicode
 ## class TestUnicode(unittest.TestCase):
diff -r 3a1db0d2747e Lib/test/test_datetime.py
--- a/Lib/test/test_datetime.py
+++ b/Lib/test/test_datetime.py
@@ -101,11 +101,11 @@
         # carry no data), but they need to be picklable anyway else
         # concrete subclasses can't be pickled.
         orig = tzinfo.__new__(tzinfo)
-        self.assertTrue(type(orig) is tzinfo)
+        self.assertIs(type(orig), tzinfo)
         for pickler, unpickler, proto in pickle_choices:
             green = pickler.dumps(orig, proto)
             derived = unpickler.loads(green)
-            self.assertTrue(type(derived) is tzinfo)
+            self.assertIs(type(derived), tzinfo)
 
     def test_pickling_subclass(self):
         # Make sure we can pickle/unpickle an instance of a subclass.
@@ -328,9 +328,9 @@
         self.assertTrue(t1 == t2)
         self.assertTrue(t1 <= t2)
         self.assertTrue(t1 >= t2)
-        self.assertTrue(not t1 != t2)
-        self.assertTrue(not t1 < t2)
-        self.assertTrue(not t1 > t2)
+        self.assertFalse(t1 != t2)
+        self.assertFalse(t1 < t2)
+        self.assertFalse(t1 > t2)
         self.assertEqual(cmp(t1, t2), 0)
         self.assertEqual(cmp(t2, t1), 0)
 
@@ -342,12 +342,12 @@
             self.assertTrue(t2 >= t1)
             self.assertTrue(t1 != t2)
             self.assertTrue(t2 != t1)
-            self.assertTrue(not t1 == t2)
-            self.assertTrue(not t2 == t1)
-            self.assertTrue(not t1 > t2)
-            self.assertTrue(not t2 < t1)
-            self.assertTrue(not t1 >= t2)
-            self.assertTrue(not t2 <= t1)
+            self.assertFalse(t1 == t2)
+            self.assertFalse(t2 == t1)
+            self.assertFalse(t1 > t2)
+            self.assertFalse(t2 < t1)
+            self.assertFalse(t1 >= t2)
+            self.assertFalse(t2 <= t1)
             self.assertEqual(cmp(t1, t2), -1)
             self.assertEqual(cmp(t2, t1), 1)
 
@@ -459,7 +459,7 @@
         self.assertTrue(timedelta(0, 1))
         self.assertTrue(timedelta(0, 0, 1))
         self.assertTrue(timedelta(microseconds=1))
-        self.assertTrue(not timedelta(0))
+        self.assertFalse(timedelta(0))
 
     def test_subclass_timedelta(self):
 
@@ -475,17 +475,17 @@
                 return round(sum)
 
         t1 = T(days=1)
-        self.assertTrue(type(t1) is T)
+        self.assertIs(type(t1), T)
         self.assertEqual(t1.as_hours(), 24)
 
         t2 = T(days=-1, seconds=-3600)
-        self.assertTrue(type(t2) is T)
+        self.assertIs(type(t2), T)
         self.assertEqual(t2.as_hours(), -25)
 
         t3 = t1 + t2
-        self.assertTrue(type(t3) is timedelta)
+        self.assertIs(type(t3), timedelta)
         t4 = T.from_td(t3)
-        self.assertTrue(type(t4) is T)
+        self.assertIs(type(t4), T)
         self.assertEqual(t3.days, t4.days)
         self.assertEqual(t3.seconds, t4.seconds)
         self.assertEqual(t3.microseconds, t4.microseconds)
@@ -783,8 +783,9 @@
 
         # It worked or it didn't.  If it didn't, assume it's reason #2, and
         # let the test pass if they're within half a second of each other.
-        self.assertTrue(today == todayagain or
-                        abs(todayagain - today) < timedelta(seconds=0.5))
+        if today != todayagain:
+            self.assertAlmostEqual(todayagain, today,
+                                   delta=timedelta(seconds=0.5))
 
     def test_weekday(self):
         for i in range(7):
@@ -974,9 +975,9 @@
         self.assertTrue(t1 == t2)
         self.assertTrue(t1 <= t2)
         self.assertTrue(t1 >= t2)
-        self.assertTrue(not t1 != t2)
-        self.assertTrue(not t1 < t2)
-        self.assertTrue(not t1 > t2)
+        self.assertFalse(t1 != t2)
+        self.assertFalse(t1 < t2)
+        self.assertFalse(t1 > t2)
         self.assertEqual(cmp(t1, t2), 0)
         self.assertEqual(cmp(t2, t1), 0)
 
@@ -988,12 +989,12 @@
             self.assertTrue(t2 >= t1)
             self.assertTrue(t1 != t2)
             self.assertTrue(t2 != t1)
-            self.assertTrue(not t1 == t2)
-            self.assertTrue(not t2 == t1)
-            self.assertTrue(not t1 > t2)
-            self.assertTrue(not t2 < t1)
-            self.assertTrue(not t1 >= t2)
-            self.assertTrue(not t2 <= t1)
+            self.assertFalse(t1 == t2)
+            self.assertFalse(t2 == t1)
+            self.assertFalse(t1 > t2)
+            self.assertFalse(t2 < t1)
+            self.assertFalse(t1 >= t2)
+            self.assertFalse(t2 <= t1)
             self.assertEqual(cmp(t1, t2), -1)
             self.assertEqual(cmp(t2, t1), 1)
 
@@ -1444,9 +1445,9 @@
         self.assertTrue(t1 == t2)
         self.assertTrue(t1 <= t2)
         self.assertTrue(t1 >= t2)
-        self.assertTrue(not t1 != t2)
-        self.assertTrue(not t1 < t2)
-        self.assertTrue(not t1 > t2)
+        self.assertFalse(t1 != t2)
+        self.assertFalse(t1 < t2)
+        self.assertFalse(t1 > t2)
         self.assertEqual(cmp(t1, t2), 0)
         self.assertEqual(cmp(t2, t1), 0)
 
@@ -1460,12 +1461,12 @@
             self.assertTrue(t2 >= t1)
             self.assertTrue(t1 != t2)
             self.assertTrue(t2 != t1)
-            self.assertTrue(not t1 == t2)
-            self.assertTrue(not t2 == t1)
-            self.assertTrue(not t1 > t2)
-            self.assertTrue(not t2 < t1)
-            self.assertTrue(not t1 >= t2)
-            self.assertTrue(not t2 <= t1)
+            self.assertFalse(t1 == t2)
+            self.assertFalse(t2 == t1)
+            self.assertFalse(t1 > t2)
+            self.assertFalse(t2 < t1)
+            self.assertFalse(t1 >= t2)
+            self.assertFalse(t2 <= t1)
             self.assertEqual(cmp(t1, t2), -1)
             self.assertEqual(cmp(t2, t1), 1)
 
@@ -1541,7 +1542,7 @@
             if abs(from_timestamp - from_now) <= tolerance:
                 break
             # Else try again a few times.
-        self.assertTrue(abs(from_timestamp - from_now) <= tolerance)
+        self.assertLessEqual(abs(from_timestamp - from_now), tolerance)
 
     def test_strptime(self):
         import _strptime
@@ -1727,9 +1728,9 @@
         self.assertTrue(t1 == t2)
         self.assertTrue(t1 <= t2)
         self.assertTrue(t1 >= t2)
-        self.assertTrue(not t1 != t2)
-        self.assertTrue(not t1 < t2)
-        self.assertTrue(not t1 > t2)
+        self.assertFalse(t1 != t2)
+        self.assertFalse(t1 < t2)
+        self.assertFalse(t1 > t2)
         self.assertEqual(cmp(t1, t2), 0)
         self.assertEqual(cmp(t2, t1), 0)
 
@@ -1743,12 +1744,12 @@
             self.assertTrue(t2 >= t1)
             self.assertTrue(t1 != t2)
             self.assertTrue(t2 != t1)
-            self.assertTrue(not t1 == t2)
-            self.assertTrue(not t2 == t1)
-            self.assertTrue(not t1 > t2)
-            self.assertTrue(not t2 < t1)
-            self.assertTrue(not t1 >= t2)
-            self.assertTrue(not t2 <= t1)
+            self.assertFalse(t1 == t2)
+            self.assertFalse(t2 == t1)
+            self.assertFalse(t1 > t2)
+            self.assertFalse(t2 < t1)
+            self.assertFalse(t1 >= t2)
+            self.assertFalse(t2 <= t1)
             self.assertEqual(cmp(t1, t2), -1)
             self.assertEqual(cmp(t2, t1), 1)
 
@@ -1928,8 +1929,8 @@
         self.assertTrue(cls(0, 1))
         self.assertTrue(cls(0, 0, 1))
         self.assertTrue(cls(0, 0, 0, 1))
-        self.assertTrue(not cls(0))
-        self.assertTrue(not cls())
+        self.assertFalse(cls(0))
+        self.assertFalse(cls())
 
     def test_replace(self):
         cls = self.theclass
@@ -2026,7 +2027,7 @@
             def utcoffset(self, dt): pass
         b = BetterTry()
         t = cls(1, 1, 1, tzinfo=b)
-        self.assertTrue(t.tzinfo is b)
+        self.assertIs(t.tzinfo, b)
 
     def test_utc_offset_out_of_bounds(self):
         class Edgy(tzinfo):
@@ -2065,9 +2066,9 @@
         for t in (cls(1, 1, 1),
                   cls(1, 1, 1, tzinfo=None),
                   cls(1, 1, 1, tzinfo=C1())):
-            self.assertTrue(t.utcoffset() is None)
-            self.assertTrue(t.dst() is None)
-            self.assertTrue(t.tzname() is None)
+            self.assertIsNone(t.utcoffset())
+            self.assertIsNone(t.dst())
+            self.assertIsNone(t.tzname())
 
         class C3(tzinfo):
             def utcoffset(self, dt): return timedelta(minutes=-1439)
@@ -2161,7 +2162,7 @@
         self.assertEqual(t.minute, 0)
         self.assertEqual(t.second, 0)
         self.assertEqual(t.microsecond, 0)
-        self.assertTrue(t.tzinfo is None)
+        self.assertIsNone(t.tzinfo)
 
     def test_zones(self):
         est = FixedOffset(-300, "EST", 1)
@@ -2176,25 +2177,25 @@
         self.assertEqual(t1.tzinfo, est)
         self.assertEqual(t2.tzinfo, utc)
         self.assertEqual(t3.tzinfo, met)
-        self.assertTrue(t4.tzinfo is None)
+        self.assertIsNone(t4.tzinfo)
         self.assertEqual(t5.tzinfo, utc)
 
         self.assertEqual(t1.utcoffset(), timedelta(minutes=-300))
         self.assertEqual(t2.utcoffset(), timedelta(minutes=0))
         self.assertEqual(t3.utcoffset(), timedelta(minutes=60))
-        self.assertTrue(t4.utcoffset() is None)
+        self.assertIsNone(t4.utcoffset())
         self.assertRaises(TypeError, t1.utcoffset, "no args")
 
         self.assertEqual(t1.tzname(), "EST")
         self.assertEqual(t2.tzname(), "UTC")
         self.assertEqual(t3.tzname(), "MET")
-        self.assertTrue(t4.tzname() is None)
+        self.assertIsNone(t4.tzname())
         self.assertRaises(TypeError, t1.tzname, "no args")
 
         self.assertEqual(t1.dst(), timedelta(minutes=1))
         self.assertEqual(t2.dst(), timedelta(minutes=-2))
         self.assertEqual(t3.dst(), timedelta(minutes=3))
-        self.assertTrue(t4.dst() is None)
+        self.assertIsNone(t4.dst())
         self.assertRaises(TypeError, t1.dst, "no args")
 
         self.assertEqual(hash(t1), hash(t2))
@@ -2285,10 +2286,10 @@
         self.assertTrue(t)
 
         t = cls(5, tzinfo=FixedOffset(300, ""))
-        self.assertTrue(not t)
+        self.assertFalse(t)
 
         t = cls(23, 59, tzinfo=FixedOffset(23*60 + 59, ""))
-        self.assertTrue(not t)
+        self.assertFalse(t)
 
         # Mostly ensuring this doesn't overflow internally.
         t = cls(0, tzinfo=FixedOffset(23*60 + 59, ""))
@@ -2326,13 +2327,13 @@
         # Ensure we can get rid of a tzinfo.
         self.assertEqual(base.tzname(), "+100")
         base2 = base.replace(tzinfo=None)
-        self.assertTrue(base2.tzinfo is None)
-        self.assertTrue(base2.tzname() is None)
+        self.assertIsNone(base2.tzinfo)
+        self.assertIsNone(base2.tzname())
 
         # Ensure we can add one.
         base3 = base2.replace(tzinfo=z100)
         self.assertEqual(base, base3)
-        self.assertTrue(base.tzinfo is base3.tzinfo)
+        self.assertIs(base.tzinfo, base3.tzinfo)
 
         # Out of bounds.
         base = cls(1)
@@ -2567,7 +2568,7 @@
         tz55 = FixedOffset(-330, "west 5:30")
         timeaware = now.time().replace(tzinfo=tz55)
         nowaware = self.theclass.combine(now.date(), timeaware)
-        self.assertTrue(nowaware.tzinfo is tz55)
+        self.assertIs(nowaware.tzinfo, tz55)
         self.assertEqual(nowaware.timetz(), timeaware)
 
         # Can't mix aware and non-aware.
@@ -2586,15 +2587,15 @@
         # Adding a delta should preserve tzinfo.
         delta = timedelta(weeks=1, minutes=12, microseconds=5678)
         nowawareplus = nowaware + delta
-        self.assertTrue(nowaware.tzinfo is tz55)
+        self.assertIs(nowaware.tzinfo, tz55)
         nowawareplus2 = delta + nowaware
-        self.assertTrue(nowawareplus2.tzinfo is tz55)
+        self.assertIs(nowawareplus2.tzinfo, tz55)
         self.assertEqual(nowawareplus, nowawareplus2)
 
         # that - delta should be what we started with, and that - what we
         # started with should be delta.
         diff = nowawareplus - delta
-        self.assertTrue(diff.tzinfo is tz55)
+        self.assertIs(diff.tzinfo, tz55)
         self.assertEqual(nowaware, diff)
         self.assertRaises(TypeError, lambda: delta - nowawareplus)
         self.assertEqual(nowawareplus - nowaware, delta)
@@ -2603,7 +2604,7 @@
         tzr = FixedOffset(random.randrange(-1439, 1440), "randomtimezone")
         # Attach it to nowawareplus.
         nowawareplus = nowawareplus.replace(tzinfo=tzr)
-        self.assertTrue(nowawareplus.tzinfo is tzr)
+        self.assertIs(nowawareplus.tzinfo, tzr)
         # Make sure the difference takes the timezone adjustments into account.
         got = nowaware - nowawareplus
         # Expected:  (nowaware base - nowaware offset) -
@@ -2630,7 +2631,7 @@
         off42 = FixedOffset(42, "42")
         another = meth(off42)
         again = meth(tz=off42)
-        self.assertTrue(another.tzinfo is again.tzinfo)
+        self.assertIs(another.tzinfo, again.tzinfo)
         self.assertEqual(another.utcoffset(), timedelta(minutes=42))
         # Bad argument with and w/o naming the keyword.
         self.assertRaises(TypeError, meth, 16)
@@ -2647,7 +2648,7 @@
         utc = FixedOffset(0, "utc", 0)
         for dummy in range(3):
             now = datetime.now(weirdtz)
-            self.assertTrue(now.tzinfo is weirdtz)
+            self.assertIs(now.tzinfo, weirdtz)
             utcnow = datetime.utcnow().replace(tzinfo=utc)
             now2 = utcnow.astimezone(weirdtz)
             if abs(now - now2) < timedelta(seconds=30):
@@ -2668,7 +2669,7 @@
         off42 = FixedOffset(42, "42")
         another = meth(ts, off42)
         again = meth(ts, tz=off42)
-        self.assertTrue(another.tzinfo is again.tzinfo)
+        self.assertIs(another.tzinfo, again.tzinfo)
         self.assertEqual(another.utcoffset(), timedelta(minutes=42))
         # Bad argument with and w/o naming the keyword.
         self.assertRaises(TypeError, meth, ts, 16)
@@ -2862,13 +2863,13 @@
         # Ensure we can get rid of a tzinfo.
         self.assertEqual(base.tzname(), "+100")
         base2 = base.replace(tzinfo=None)
-        self.assertTrue(base2.tzinfo is None)
-        self.assertTrue(base2.tzname() is None)
+        self.assertIsNone(base2.tzinfo)
+        self.assertIsNone(base2.tzname())
 
         # Ensure we can add one.
         base3 = base2.replace(tzinfo=z100)
         self.assertEqual(base, base3)
-        self.assertTrue(base.tzinfo is base3.tzinfo)
+        self.assertIs(base.tzinfo, base3.tzinfo)
 
         # Out of bounds.
         base = cls(2000, 2, 29)
@@ -2881,20 +2882,20 @@
         fm5h = FixedOffset(-timedelta(hours=5), "m300")
 
         dt = self.theclass.now(tz=f44m)
-        self.assertTrue(dt.tzinfo is f44m)
+        self.assertIs(dt.tzinfo, f44m)
         # Replacing with degenerate tzinfo raises an exception.
         self.assertRaises(ValueError, dt.astimezone, fnone)
         # Ditto with None tz.
         self.assertRaises(TypeError, dt.astimezone, None)
         # Replacing with same tzinfo makes no change.
         x = dt.astimezone(dt.tzinfo)
-        self.assertTrue(x.tzinfo is f44m)
+        self.assertIs(x.tzinfo, f44m)
         self.assertEqual(x.date(), dt.date())
         self.assertEqual(x.time(), dt.time())
 
         # Replacing with different tzinfo does adjust.
         got = dt.astimezone(fm5h)
-        self.assertTrue(got.tzinfo is fm5h)
+        self.assertIs(got.tzinfo, fm5h)
         self.assertEqual(got.utcoffset(), timedelta(hours=-5))
         expected = dt - dt.utcoffset()  # in effect, convert to UTC
         expected += fm5h.utcoffset(dt)  # and from there to local time
@@ -2902,7 +2903,7 @@
         self.assertEqual(got.date(), expected.date())
         self.assertEqual(got.time(), expected.time())
         self.assertEqual(got.timetz(), expected.timetz())
-        self.assertTrue(got.tzinfo is expected.tzinfo)
+        self.assertIs(got.tzinfo, expected.tzinfo)
         self.assertEqual(got, expected)
 
     def test_aware_subtract(self):
@@ -3330,8 +3331,8 @@
         as_datetime = datetime.combine(as_date, time())
         self.assertTrue(as_date != as_datetime)
         self.assertTrue(as_datetime != as_date)
-        self.assertTrue(not as_date == as_datetime)
-        self.assertTrue(not as_datetime == as_date)
+        self.assertFalse(as_date == as_datetime)
+        self.assertFalse(as_datetime == as_date)
         self.assertRaises(TypeError, lambda: as_date < as_datetime)
         self.assertRaises(TypeError, lambda: as_datetime < as_date)
         self.assertRaises(TypeError, lambda: as_date <= as_datetime)
@@ -3345,8 +3346,7 @@
         # projection if use of a date method is forced.
         self.assertTrue(as_date.__eq__(as_datetime))
         different_day = (as_date.day + 1) % 20 + 1
-        self.assertTrue(not as_date.__eq__(as_datetime.replace(day=
-                                                     different_day)))
+        self.assertFalse(as_date.__eq__(as_datetime.replace(day=different_day)))
 
         # And date should compare with other subclasses of date.  If a
         # subclass wants to stop this, it's up to the subclass to do so.
diff -r 3a1db0d2747e Lib/test/test_decimal.py
--- a/Lib/test/test_decimal.py
+++ b/Lib/test/test_decimal.py
@@ -223,7 +223,6 @@
         global skip_expected
         if skip_expected:
             raise unittest.SkipTest
-            return
         with open(file) as f:
             for line in f:
                 line = line.replace('\r\n', '').replace('\n', '')
@@ -234,7 +233,6 @@
                     #Exception raised where there shouldn't have been one.
                     self.fail('Exception "'+exception.__class__.__name__ + '" raised on line '+line)
 
-        return
 
     def eval_line(self, s):
         if s.find(' -> ') >= 0 and s[:2] != '--' and not s.startswith('  --'):
@@ -391,7 +389,6 @@
                          'Incorrect answer for ' + s + ' -- got ' + result)
         self.assertItemsEqual(myexceptions, theirexceptions,
               'Incorrect flags set in ' + s + ' -- got ' + str(myexceptions))
-        return
 
     def getexceptions(self):
         return [e for e in Signals if self.context.flags[e]]
@@ -834,7 +831,7 @@
         try:
             from locale import CHAR_MAX
         except ImportError:
-            return
+            self.skipTest('locale.CHAR_MAX not available')
 
         # Set up some localeconv-like dictionaries
         en_US = {
@@ -1196,7 +1193,6 @@
 
     cls.assertEqual(test1, Decimal('0.3333333333333333333333333333'))
     cls.assertEqual(test2, Decimal('0.3333333333333333333333333333'))
-    return
 
 def thfunc2(cls):
     d1 = Decimal(1)
@@ -1210,17 +1206,12 @@
 
     cls.assertEqual(test1, Decimal('0.3333333333333333333333333333'))
     cls.assertEqual(test2, Decimal('0.333333333333333333'))
-    return
 
 
+@unittest.skipUnless(threading, 'threading required')
 class DecimalUseOfContextTest(unittest.TestCase):
     '''Unit tests for Use of Context cases in Decimal.'''
 
-    try:
-        import threading
-    except ImportError:
-        threading = None
-
     # Take care executing this test from IDLE, there's an issue in threading
     # that hangs IDLE and I couldn't find it
 
@@ -1239,10 +1230,6 @@
 
         self.finish1.wait()
         self.finish2.wait()
-        return
-
-    if threading is None:
-        del test_threading
 
 
 class DecimalUsabilityTest(unittest.TestCase):
@@ -1540,7 +1527,6 @@
                 self.assertEqual(d1._sign, b1._sign)
                 self.assertEqual(d1._int, b1._int)
                 self.assertEqual(d1._exp, b1._exp)
-            return
 
         Decimal(d1)
         self.assertEqual(d1._sign, b1._sign)
diff -r 3a1db0d2747e Lib/test/test_descr.py
--- a/Lib/test/test_descr.py
+++ b/Lib/test/test_descr.py
@@ -398,13 +398,21 @@
 
 class ClassPropertiesAndMethods(unittest.TestCase):
 
+    def assertHasAttr(self, obj, name):
+        self.assertTrue(hasattr(obj, name),
+                        '%r has no attribute %r' % (obj, name))
+
+    def assertNotHasAttr(self, obj, name):
+        self.assertFalse(hasattr(obj, name),
+                         '%r has unexpected attribute %r' % (obj, name))
+
     def test_python_dicts(self):
         # Testing Python subclass of dict...
         self.assertTrue(issubclass(dict, dict))
         self.assertIsInstance({}, dict)
         d = dict()
         self.assertEqual(d, {})
-        self.assertTrue(d.__class__ is dict)
+        self.assertIs(d.__class__, dict)
         self.assertIsInstance(d, dict)
         class C(dict):
             state = -1
@@ -585,7 +593,7 @@
             def _set_x(self, x):
                 self.__x = -x
         a = A()
-        self.assertTrue(not hasattr(a, "x"))
+        self.assertNotHasAttr(a, "x")
         a.x = 12
         self.assertEqual(a.x, 12)
         self.assertEqual(a._A__x, -12)
@@ -934,14 +942,14 @@
         self.assertEqual(type(a), object)
         b = object()
         self.assertNotEqual(a, b)
-        self.assertFalse(hasattr(a, "foo"))
+        self.assertNotHasAttr(a, "foo")
         try:
             a.foo = 12
         except (AttributeError, TypeError):
             pass
         else:
             self.fail("object() should not allow setting a foo attribute")
-        self.assertFalse(hasattr(object(), "__dict__"))
+        self.assertNotHasAttr(object(), "__dict__")
 
         class Cdict(object):
             pass
@@ -956,28 +964,28 @@
         class C0(object):
             __slots__ = []
         x = C0()
-        self.assertFalse(hasattr(x, "__dict__"))
-        self.assertFalse(hasattr(x, "foo"))
+        self.assertNotHasAttr(x, "__dict__")
+        self.assertNotHasAttr(x, "foo")
 
         class C1(object):
             __slots__ = ['a']
         x = C1()
-        self.assertFalse(hasattr(x, "__dict__"))
-        self.assertFalse(hasattr(x, "a"))
+        self.assertNotHasAttr(x, "__dict__")
+        self.assertNotHasAttr(x, "a")
         x.a = 1
         self.assertEqual(x.a, 1)
         x.a = None
         self.assertEqual(x.a, None)
         del x.a
-        self.assertFalse(hasattr(x, "a"))
+        self.assertNotHasAttr(x, "a")
 
         class C3(object):
             __slots__ = ['a', 'b', 'c']
         x = C3()
-        self.assertFalse(hasattr(x, "__dict__"))
-        self.assertFalse(hasattr(x, 'a'))
-        self.assertFalse(hasattr(x, 'b'))
-        self.assertFalse(hasattr(x, 'c'))
+        self.assertNotHasAttr(x, "__dict__")
+        self.assertNotHasAttr(x, 'a')
+        self.assertNotHasAttr(x, 'b')
+        self.assertNotHasAttr(x, 'c')
         x.a = 1
         x.b = 2
         x.c = 3
@@ -993,8 +1001,8 @@
             def get(self):
                 return self.__a
         x = C4(5)
-        self.assertFalse(hasattr(x, '__dict__'))
-        self.assertFalse(hasattr(x, '__a'))
+        self.assertNotHasAttr(x, '__dict__')
+        self.assertNotHasAttr(x, '__a')
         self.assertEqual(x.get(), 5)
         try:
             x.__a = 6
@@ -1051,11 +1059,12 @@
         c.abc = 5
         self.assertEqual(c.abc, 5)
 
+    def test_unicode_slots(self):
         # Test unicode slot names
         try:
             unicode
         except NameError:
-            pass
+            self.skipTest('no unicode support')
         else:
             # Test a single unicode string is not expanded as a sequence.
             class C(object):
@@ -1164,16 +1173,16 @@
         class D(object):
             __slots__ = ["__dict__"]
         a = D()
-        self.assertTrue(hasattr(a, "__dict__"))
-        self.assertFalse(hasattr(a, "__weakref__"))
+        self.assertHasAttr(a, "__dict__")
+        self.assertNotHasAttr(a, "__weakref__")
         a.foo = 42
         self.assertEqual(a.__dict__, {"foo": 42})
 
         class W(object):
             __slots__ = ["__weakref__"]
         a = W()
-        self.assertTrue(hasattr(a, "__weakref__"))
-        self.assertFalse(hasattr(a, "__dict__"))
+        self.assertHasAttr(a, "__weakref__")
+        self.assertNotHasAttr(a, "__dict__")
         try:
             a.foo = 42
         except AttributeError:
@@ -1184,16 +1193,16 @@
         class C1(W, D):
             __slots__ = []
         a = C1()
-        self.assertTrue(hasattr(a, "__dict__"))
-        self.assertTrue(hasattr(a, "__weakref__"))
+        self.assertHasAttr(a, "__dict__")
+        self.assertHasAttr(a, "__weakref__")
         a.foo = 42
         self.assertEqual(a.__dict__, {"foo": 42})
 
         class C2(D, W):
             __slots__ = []
         a = C2()
-        self.assertTrue(hasattr(a, "__dict__"))
-        self.assertTrue(hasattr(a, "__weakref__"))
+        self.assertHasAttr(a, "__dict__")
+        self.assertHasAttr(a, "__weakref__")
         a.foo = 42
         self.assertEqual(a.__dict__, {"foo": 42})
 
@@ -1241,7 +1250,7 @@
         class C(object):
             pass
         a = C()
-        self.assertFalse(hasattr(a, "foobar"))
+        self.assertNotHasAttr(a, "foobar")
         C.foobar = 2
         self.assertEqual(a.foobar, 2)
         C.method = lambda self: 42
@@ -1251,7 +1260,7 @@
         C.__int__ = lambda self: 100
         self.assertEqual(int(a), 100)
         self.assertEqual(a.foobar, 2)
-        self.assertFalse(hasattr(a, "spam"))
+        self.assertNotHasAttr(a, "spam")
         def mygetattr(self, name):
             if name == "spam":
                 return "spam"
@@ -1521,7 +1530,7 @@
         self.assertEqual(a.x, 10)
         self.assertEqual(a.x, 11)
         del a.x
-        self.assertEqual(hasattr(a, 'x'), 0)
+        self.assertNotHasAttr(a, 'x')
 
     def test_newslots(self):
         # Testing __new__ slot override...
@@ -1797,18 +1806,18 @@
                 raise IndexError
         c1 = C()
         c2 = C()
-        self.assertTrue(not not c1) # What?
+        self.assertFalse(not c1)
         self.assertNotEqual(id(c1), id(c2))
         hash(c1)
         hash(c2)
         self.assertEqual(cmp(c1, c2), cmp(id(c1), id(c2)))
         self.assertEqual(c1, c1)
         self.assertTrue(c1 != c2)
-        self.assertTrue(not c1 != c1)
-        self.assertTrue(not c1 == c2)
+        self.assertFalse(c1 != c1)
+        self.assertFalse(c1 == c2)
         # Note that the module name appears in str/repr, and that varies
         # depending on whether this test is run standalone or from a framework.
-        self.assertTrue(str(c1).find('C object at ') >= 0)
+        self.assertGreaterEqual(str(c1).find('C object at '), 0)
         self.assertEqual(str(c1), repr(c1))
         self.assertNotIn(-1, c1)
         for i in range(10):
@@ -1821,18 +1830,18 @@
                 raise IndexError
         d1 = D()
         d2 = D()
-        self.assertTrue(not not d1)
+        self.assertFalse(not d1)
         self.assertNotEqual(id(d1), id(d2))
         hash(d1)
         hash(d2)
         self.assertEqual(cmp(d1, d2), cmp(id(d1), id(d2)))
         self.assertEqual(d1, d1)
         self.assertNotEqual(d1, d2)
-        self.assertTrue(not d1 != d1)
-        self.assertTrue(not d1 == d2)
+        self.assertFalse(d1 != d1)
+        self.assertFalse(d1 == d2)
         # Note that the module name appears in str/repr, and that varies
         # depending on whether this test is run standalone or from a framework.
-        self.assertTrue(str(d1).find('D object at ') >= 0)
+        self.assertGreaterEqual(str(d1).find('D object at '), 0)
         self.assertEqual(str(d1), repr(d1))
         self.assertNotIn(-1, d1)
         for i in range(10):
@@ -1862,11 +1871,11 @@
         p1 = Proxy(1)
         p_1 = Proxy(-1)
         self.assertFalse(p0)
-        self.assertTrue(not not p1)
+        self.assertFalse(not p1)
         self.assertEqual(hash(p0), hash(0))
         self.assertEqual(p0, p0)
         self.assertNotEqual(p0, p1)
-        self.assertTrue(not p0 != p0)
+        self.assertFalse(p0 != p0)
         self.assertEqual(not p0, p1)
         self.assertEqual(cmp(p0, p1), -1)
         self.assertEqual(cmp(p0, p0), 0)
@@ -1902,7 +1911,7 @@
         p1 = DProxy(1)
         p_1 = DProxy(-1)
         self.assertFalse(p0)
-        self.assertTrue(not not p1)
+        self.assertFalse(not p1)
         self.assertEqual(hash(p0), hash(0))
         self.assertEqual(p0, p0)
         self.assertNotEqual(p0, p1)
@@ -1995,7 +2004,7 @@
         try:
             weakref.ref(no)
         except TypeError, msg:
-            self.assertTrue(str(msg).find("weak reference") >= 0)
+            self.assertIn("weak reference", str(msg))
         else:
             self.fail("weakref.ref(no) should be illegal")
         class Weak(object):
@@ -2019,17 +2028,17 @@
                 del self.__x
             x = property(getx, setx, delx, doc="I'm the x property.")
         a = C()
-        self.assertFalse(hasattr(a, "x"))
+        self.assertNotHasAttr(a, "x")
         a.x = 42
         self.assertEqual(a._C__x, 42)
         self.assertEqual(a.x, 42)
         del a.x
-        self.assertFalse(hasattr(a, "x"))
-        self.assertFalse(hasattr(a, "_C__x"))
+        self.assertNotHasAttr(a, "x")
+        self.assertNotHasAttr(a, "_C__x")
         C.x.__set__(a, 100)
         self.assertEqual(C.x.__get__(a), 100)
         C.x.__delete__(a)
-        self.assertFalse(hasattr(a, "x"))
+        self.assertNotHasAttr(a, "x")
 
         raw = C.__dict__['x']
         self.assertIsInstance(raw, property)
@@ -2041,9 +2050,9 @@
         self.assertIn("fdel", attrs)
 
         self.assertEqual(raw.__doc__, "I'm the x property.")
-        self.assertTrue(raw.fget is C.__dict__['getx'])
-        self.assertTrue(raw.fset is C.__dict__['setx'])
-        self.assertTrue(raw.fdel is C.__dict__['delx'])
+        self.assertIs(raw.fget, C.__dict__['getx'])
+        self.assertIs(raw.fset, C.__dict__['setx'])
+        self.assertIs(raw.fdel, C.__dict__['delx'])
 
         for attr in "__doc__", "fget", "fset", "fdel":
             try:
@@ -2107,14 +2116,14 @@
                 del self._foo
         c = C()
         self.assertEqual(C.foo.__doc__, "hello")
-        self.assertFalse(hasattr(c, "foo"))
+        self.assertNotHasAttr(c, "foo")
         c.foo = -42
-        self.assertTrue(hasattr(c, '_foo'))
+        self.assertHasAttr(c, '_foo')
         self.assertEqual(c._foo, 42)
         self.assertEqual(c.foo, 42)
         del c.foo
-        self.assertFalse(hasattr(c, '_foo'))
-        self.assertFalse(hasattr(c, "foo"))
+        self.assertNotHasAttr(c, '_foo')
+        self.assertNotHasAttr(c, "foo")
 
         class D(C):
             @C.foo.deleter
@@ -2500,13 +2509,13 @@
         a = hexint(12345)
         self.assertEqual(a, 12345)
         self.assertEqual(int(a), 12345)
-        self.assertTrue(int(a).__class__ is int)
+        self.assertIs(int(a).__class__, int)
         self.assertEqual(hash(a), hash(12345))
-        self.assertTrue((+a).__class__ is int)
-        self.assertTrue((a >> 0).__class__ is int)
-        self.assertTrue((a << 0).__class__ is int)
-        self.assertTrue((hexint(0) << 12).__class__ is int)
-        self.assertTrue((hexint(0) >> 12).__class__ is int)
+        self.assertIs((+a).__class__, int)
+        self.assertIs((a >> 0).__class__, int)
+        self.assertIs((a << 0).__class__, int)
+        self.assertIs((hexint(0) << 12).__class__, int)
+        self.assertIs((hexint(0) >> 12).__class__, int)
 
         class octlong(long):
             __slots__ = []
@@ -2526,31 +2535,31 @@
         self.assertEqual(a, 12345L)
         self.assertEqual(long(a), 12345L)
         self.assertEqual(hash(a), hash(12345L))
-        self.assertTrue(long(a).__class__ is long)
-        self.assertTrue((+a).__class__ is long)
-        self.assertTrue((-a).__class__ is long)
-        self.assertTrue((-octlong(0)).__class__ is long)
-        self.assertTrue((a >> 0).__class__ is long)
-        self.assertTrue((a << 0).__class__ is long)
-        self.assertTrue((a - 0).__class__ is long)
-        self.assertTrue((a * 1).__class__ is long)
-        self.assertTrue((a ** 1).__class__ is long)
-        self.assertTrue((a // 1).__class__ is long)
-        self.assertTrue((1 * a).__class__ is long)
-        self.assertTrue((a | 0).__class__ is long)
-        self.assertTrue((a ^ 0).__class__ is long)
-        self.assertTrue((a & -1L).__class__ is long)
-        self.assertTrue((octlong(0) << 12).__class__ is long)
-        self.assertTrue((octlong(0) >> 12).__class__ is long)
-        self.assertTrue(abs(octlong(0)).__class__ is long)
+        self.assertIs(long(a).__class__, long)
+        self.assertIs((+a).__class__, long)
+        self.assertIs((-a).__class__, long)
+        self.assertIs((-octlong(0)).__class__, long)
+        self.assertIs((a >> 0).__class__, long)
+        self.assertIs((a << 0).__class__, long)
+        self.assertIs((a - 0).__class__, long)
+        self.assertIs((a * 1).__class__, long)
+        self.assertIs((a ** 1).__class__, long)
+        self.assertIs((a // 1).__class__, long)
+        self.assertIs((1 * a).__class__, long)
+        self.assertIs((a | 0).__class__, long)
+        self.assertIs((a ^ 0).__class__, long)
+        self.assertIs((a & -1L).__class__, long)
+        self.assertIs((octlong(0) << 12).__class__, long)
+        self.assertIs((octlong(0) >> 12).__class__, long)
+        self.assertIs(abs(octlong(0)).__class__, long)
 
         # Because octlong overrides __add__, we can't check the absence of +0
         # optimizations using octlong.
         class longclone(long):
             pass
         a = longclone(1)
-        self.assertTrue((a + 0).__class__ is long)
-        self.assertTrue((0 + a).__class__ is long)
+        self.assertIs((a + 0).__class__, long)
+        self.assertIs((0 + a).__class__, long)
 
         # Check that negative clones don't segfault
         a = longclone(-1)
@@ -2567,9 +2576,9 @@
         a = precfloat(12345)
         self.assertEqual(a, 12345.0)
         self.assertEqual(float(a), 12345.0)
-        self.assertTrue(float(a).__class__ is float)
+        self.assertIs(float(a).__class__, float)
         self.assertEqual(hash(a), hash(12345.0))
-        self.assertTrue((+a).__class__ is float)
+        self.assertIs((+a).__class__, float)
 
         class madcomplex(complex):
             def __repr__(self):
@@ -2617,20 +2626,20 @@
             self.assertEqual(v, t)
         a = madtuple((1,2,3,4,5))
         self.assertEqual(tuple(a), (1,2,3,4,5))
-        self.assertTrue(tuple(a).__class__ is tuple)
+        self.assertIs(tuple(a).__class__, tuple)
         self.assertEqual(hash(a), hash((1,2,3,4,5)))
-        self.assertTrue(a[:].__class__ is tuple)
-        self.assertTrue((a * 1).__class__ is tuple)
-        self.assertTrue((a * 0).__class__ is tuple)
-        self.assertTrue((a + ()).__class__ is tuple)
+        self.assertIs(a[:].__class__, tuple)
+        self.assertIs((a * 1).__class__, tuple)
+        self.assertIs((a * 0).__class__, tuple)
+        self.assertIs((a + ()).__class__, tuple)
         a = madtuple(())
         self.assertEqual(tuple(a), ())
-        self.assertTrue(tuple(a).__class__ is tuple)
-        self.assertTrue((a + a).__class__ is tuple)
-        self.assertTrue((a * 0).__class__ is tuple)
-        self.assertTrue((a * 1).__class__ is tuple)
-        self.assertTrue((a * 2).__class__ is tuple)
-        self.assertTrue(a[:].__class__ is tuple)
+        self.assertIs(tuple(a).__class__, tuple)
+        self.assertIs((a + a).__class__, tuple)
+        self.assertIs((a * 0).__class__, tuple)
+        self.assertIs((a * 1).__class__, tuple)
+        self.assertIs((a * 2).__class__, tuple)
+        self.assertIs(a[:].__class__, tuple)
 
         class madstring(str):
             _rev = None
@@ -2652,51 +2661,51 @@
             self.assertEqual(u, s)
         s = madstring("12345")
         self.assertEqual(str(s), "12345")
-        self.assertTrue(str(s).__class__ is str)
+        self.assertIs(str(s).__class__, str)
 
         base = "\x00" * 5
         s = madstring(base)
         self.assertEqual(s, base)
         self.assertEqual(str(s), base)
-        self.assertTrue(str(s).__class__ is str)
+        self.assertIs(str(s).__class__, str)
         self.assertEqual(hash(s), hash(base))
         self.assertEqual({s: 1}[base], 1)
         self.assertEqual({base: 1}[s], 1)
-        self.assertTrue((s + "").__class__ is str)
+        self.assertIs((s + "").__class__, str)
         self.assertEqual(s + "", base)
-        self.assertTrue(("" + s).__class__ is str)
+        self.assertIs(("" + s).__class__, str)
         self.assertEqual("" + s, base)
-        self.assertTrue((s * 0).__class__ is str)
+        self.assertIs((s * 0).__class__, str)
         self.assertEqual(s * 0, "")
-        self.assertTrue((s * 1).__class__ is str)
+        self.assertIs((s * 1).__class__, str)
         self.assertEqual(s * 1, base)
-        self.assertTrue((s * 2).__class__ is str)
+        self.assertIs((s * 2).__class__, str)
         self.assertEqual(s * 2, base + base)
-        self.assertTrue(s[:].__class__ is str)
+        self.assertIs(s[:].__class__, str)
         self.assertEqual(s[:], base)
-        self.assertTrue(s[0:0].__class__ is str)
+        self.assertIs(s[0:0].__class__, str)
         self.assertEqual(s[0:0], "")
-        self.assertTrue(s.strip().__class__ is str)
+        self.assertIs(s.strip().__class__, str)
         self.assertEqual(s.strip(), base)
-        self.assertTrue(s.lstrip().__class__ is str)
+        self.assertIs(s.lstrip().__class__, str)
         self.assertEqual(s.lstrip(), base)
-        self.assertTrue(s.rstrip().__class__ is str)
+        self.assertIs(s.rstrip().__class__, str)
         self.assertEqual(s.rstrip(), base)
         identitytab = ''.join([chr(i) for i in range(256)])
-        self.assertTrue(s.translate(identitytab).__class__ is str)
+        self.assertIs(s.translate(identitytab).__class__, str)
         self.assertEqual(s.translate(identitytab), base)
-        self.assertTrue(s.translate(identitytab, "x").__class__ is str)
+        self.assertIs(s.translate(identitytab, "x").__class__, str)
         self.assertEqual(s.translate(identitytab, "x"), base)
         self.assertEqual(s.translate(identitytab, "\x00"), "")
-        self.assertTrue(s.replace("x", "x").__class__ is str)
+        self.assertIs(s.replace("x", "x").__class__, str)
         self.assertEqual(s.replace("x", "x"), base)
-        self.assertTrue(s.ljust(len(s)).__class__ is str)
+        self.assertIs(s.ljust(len(s)).__class__, str)
         self.assertEqual(s.ljust(len(s)), base)
-        self.assertTrue(s.rjust(len(s)).__class__ is str)
+        self.assertIs(s.rjust(len(s)).__class__, str)
         self.assertEqual(s.rjust(len(s)), base)
-        self.assertTrue(s.center(len(s)).__class__ is str)
+        self.assertIs(s.center(len(s)).__class__, str)
         self.assertEqual(s.center(len(s)), base)
-        self.assertTrue(s.lower().__class__ is str)
+        self.assertIs(s.lower().__class__, str)
         self.assertEqual(s.lower(), base)
 
         class madunicode(unicode):
@@ -2715,47 +2724,47 @@
         base = u"12345"
         u = madunicode(base)
         self.assertEqual(unicode(u), base)
-        self.assertTrue(unicode(u).__class__ is unicode)
+        self.assertIs(unicode(u).__class__, unicode)
         self.assertEqual(hash(u), hash(base))
         self.assertEqual({u: 1}[base], 1)
         self.assertEqual({base: 1}[u], 1)
-        self.assertTrue(u.strip().__class__ is unicode)
+        self.assertIs(u.strip().__class__, unicode)
         self.assertEqual(u.strip(), base)
-        self.assertTrue(u.lstrip().__class__ is unicode)
+        self.assertIs(u.lstrip().__class__, unicode)
         self.assertEqual(u.lstrip(), base)
-        self.assertTrue(u.rstrip().__class__ is unicode)
+        self.assertIs(u.rstrip().__class__, unicode)
         self.assertEqual(u.rstrip(), base)
-        self.assertTrue(u.replace(u"x", u"x").__class__ is unicode)
+        self.assertIs(u.replace(u"x", u"x").__class__, unicode)
         self.assertEqual(u.replace(u"x", u"x"), base)
-        self.assertTrue(u.replace(u"xy", u"xy").__class__ is unicode)
+        self.assertIs(u.replace(u"xy", u"xy").__class__, unicode)
         self.assertEqual(u.replace(u"xy", u"xy"), base)
-        self.assertTrue(u.center(len(u)).__class__ is unicode)
+        self.assertIs(u.center(len(u)).__class__, unicode)
         self.assertEqual(u.center(len(u)), base)
-        self.assertTrue(u.ljust(len(u)).__class__ is unicode)
+        self.assertIs(u.ljust(len(u)).__class__, unicode)
         self.assertEqual(u.ljust(len(u)), base)
-        self.assertTrue(u.rjust(len(u)).__class__ is unicode)
+        self.assertIs(u.rjust(len(u)).__class__, unicode)
         self.assertEqual(u.rjust(len(u)), base)
-        self.assertTrue(u.lower().__class__ is unicode)
+        self.assertIs(u.lower().__class__, unicode)
         self.assertEqual(u.lower(), base)
-        self.assertTrue(u.upper().__class__ is unicode)
+        self.assertIs(u.upper().__class__, unicode)
         self.assertEqual(u.upper(), base)
-        self.assertTrue(u.capitalize().__class__ is unicode)
+        self.assertIs(u.capitalize().__class__, unicode)
         self.assertEqual(u.capitalize(), base)
-        self.assertTrue(u.title().__class__ is unicode)
+        self.assertIs(u.title().__class__, unicode)
         self.assertEqual(u.title(), base)
-        self.assertTrue((u + u"").__class__ is unicode)
+        self.assertIs((u + u"").__class__, unicode)
         self.assertEqual(u + u"", base)
-        self.assertTrue((u"" + u).__class__ is unicode)
+        self.assertIs((u"" + u).__class__, unicode)
         self.assertEqual(u"" + u, base)
-        self.assertTrue((u * 0).__class__ is unicode)
+        self.assertIs((u * 0).__class__, unicode)
         self.assertEqual(u * 0, u"")
-        self.assertTrue((u * 1).__class__ is unicode)
+        self.assertIs((u * 1).__class__, unicode)
         self.assertEqual(u * 1, base)
-        self.assertTrue((u * 2).__class__ is unicode)
+        self.assertIs((u * 2).__class__, unicode)
         self.assertEqual(u * 2, base + base)
-        self.assertTrue(u[:].__class__ is unicode)
+        self.assertIs(u[:].__class__, unicode)
         self.assertEqual(u[:], base)
-        self.assertTrue(u[0:0].__class__ is unicode)
+        self.assertIs(u[0:0].__class__, unicode)
         self.assertEqual(u[0:0], u"")
 
         class sublist(list):
@@ -2901,12 +2910,16 @@
             c = {1: c1, 2: c2, 3: c3}
             for x in 1, 2, 3:
                 for y in 1, 2, 3:
-                    self.assertTrue(cmp(c[x], c[y]) == cmp(x, y), "x=%d, y=%d" % (x, y))
+                    self.assertEqual(cmp(c[x], c[y]), cmp(x, y),
+                                     "x=%d, y=%d" % (x, y))
                     for op in "<", "<=", "==", "!=", ">", ">=":
-                        self.assertTrue(eval("c[x] %s c[y]" % op) == eval("x %s y" % op),
-                               "x=%d, y=%d" % (x, y))
-                    self.assertTrue(cmp(c[x], y) == cmp(x, y), "x=%d, y=%d" % (x, y))
-                    self.assertTrue(cmp(x, c[y]) == cmp(x, y), "x=%d, y=%d" % (x, y))
+                        self.assertEqual(eval("c[x] %s c[y]" % op),
+                                         eval("x %s y" % op),
+                                         "x=%d, y=%d" % (x, y))
+                    self.assertEqual(cmp(c[x], y), cmp(x, y),
+                                     "x=%d, y=%d" % (x, y))
+                    self.assertEqual(cmp(x, c[y]), cmp(x, y),
+                                     "x=%d, y=%d" % (x, y))
 
     def test_rich_comparisons(self):
         # Testing rich comparisons...
@@ -2979,12 +2992,15 @@
             for x in 1, 2, 3:
                 for y in 1, 2, 3:
                     for op in "<", "<=", "==", "!=", ">", ">=":
-                        self.assertTrue(eval("c[x] %s c[y]" % op) == eval("x %s y" % op),
-                               "x=%d, y=%d" % (x, y))
-                        self.assertTrue(eval("c[x] %s y" % op) == eval("x %s y" % op),
-                               "x=%d, y=%d" % (x, y))
-                        self.assertTrue(eval("x %s c[y]" % op) == eval("x %s y" % op),
-                               "x=%d, y=%d" % (x, y))
+                        self.assertEqual(eval("c[x] %s c[y]" % op),
+                                         eval("x %s y" % op),
+                                         "x=%d, y=%d" % (x, y))
+                        self.assertEqual(eval("c[x] %s y" % op),
+                                         eval("x %s y" % op),
+                                         "x=%d, y=%d" % (x, y))
+                        self.assertEqual(eval("x %s c[y]" % op),
+                                         eval("x %s y" % op),
+                                         "x=%d, y=%d" % (x, y))
 
     def test_coercions(self):
         # Testing coercions...
@@ -3049,9 +3065,9 @@
             for cls2 in C, D, E, F:
                 x = cls()
                 x.__class__ = cls2
-                self.assertTrue(x.__class__ is cls2)
+                self.assertIs(x.__class__, cls2)
                 x.__class__ = cls
-                self.assertTrue(x.__class__ is cls)
+                self.assertIs(x.__class__, cls)
         def cant(x, C):
             try:
                 x.__class__ = C
@@ -3113,11 +3129,11 @@
             x = cls()
             x.a = 1
             x.__class__ = cls2
-            self.assertTrue(x.__class__ is cls2,
+            self.assertIs(x.__class__, cls2,
                    "assigning %r as __class__ for %r silently failed" % (cls2, x))
             self.assertEqual(x.a, 1)
             x.__class__ = cls
-            self.assertTrue(x.__class__ is cls,
+            self.assertIs(x.__class__, cls,
                    "assigning %r as __class__ for %r silently failed" % (cls, x))
             self.assertEqual(x.a, 1)
         for cls in G, J, K, L, M, N, P, R, list, Int:
@@ -3287,7 +3303,7 @@
                 for cls in C, C1, C2:
                     s = p.dumps(cls, bin)
                     cls2 = p.loads(s)
-                    self.assertTrue(cls2 is cls)
+                    self.assertIs(cls2, cls)
 
                 a = C1(1, 2); a.append(42); a.append(24)
                 b = C2("hello", "world", 42)
@@ -3317,7 +3333,7 @@
         import copy
         for cls in C, C1, C2:
             cls2 = copy.deepcopy(cls)
-            self.assertTrue(cls2 is cls)
+            self.assertIs(cls2, cls)
 
         a = C1(1, 2); a.append(42); a.append(24)
         b = C2("hello", "world", 42)
@@ -3388,9 +3404,9 @@
             # Now it should work
             x = C()
             y = pickle.loads(pickle.dumps(x))
-            self.assertEqual(hasattr(y, 'a'), 0)
+            self.assertNotHasAttr(y, 'a')
             y = cPickle.loads(cPickle.dumps(x))
-            self.assertEqual(hasattr(y, 'a'), 0)
+            self.assertNotHasAttr(y, 'a')
             x.a = 42
             y = pickle.loads(pickle.dumps(x))
             self.assertEqual(y.a, 42)
@@ -3706,9 +3722,9 @@
         from types import ModuleType as M
         m = M.__new__(M)
         str(m)
-        self.assertEqual(hasattr(m, "__name__"), 0)
-        self.assertEqual(hasattr(m, "__file__"), 0)
-        self.assertEqual(hasattr(m, "foo"), 0)
+        self.assertNotHasAttr(m, "__name__")
+        self.assertNotHasAttr(m, "__file__")
+        self.assertNotHasAttr(m, "foo")
         self.assertFalse(m.__dict__)   # None or {} are both reasonable answers
         m.foo = 1
         self.assertEqual(m.__dict__, {"foo": 1})
@@ -3888,8 +3904,8 @@
             __slots__=()
         if test_support.check_impl_detail():
             self.assertEqual(C.__basicsize__, B.__basicsize__)
-        self.assertTrue(hasattr(C, '__dict__'))
-        self.assertTrue(hasattr(C, '__weakref__'))
+        self.assertHasAttr(C, '__dict__')
+        self.assertHasAttr(C, '__weakref__')
         C().x = 2
 
     def test_rmul(self):
@@ -4390,7 +4406,7 @@
         self.assertEqual(c.attr, 1)
         # this makes a crash more likely:
         test_support.gc_collect()
-        self.assertEqual(hasattr(c, 'attr'), False)
+        self.assertNotHasAttr(c, 'attr')
 
     def test_init(self):
         # SF 1155938
@@ -4411,17 +4427,17 @@
         l = []
         self.assertEqual(l.__add__, l.__add__)
         self.assertEqual(l.__add__, [].__add__)
-        self.assertTrue(l.__add__ != [5].__add__)
-        self.assertTrue(l.__add__ != l.__mul__)
-        self.assertTrue(l.__add__.__name__ == '__add__')
+        self.assertNotEqual(l.__add__, [5].__add__)
+        self.assertNotEqual(l.__add__, l.__mul__)
+        self.assertEqual(l.__add__.__name__, '__add__')
         if hasattr(l.__add__, '__self__'):
             # CPython
-            self.assertTrue(l.__add__.__self__ is l)
-            self.assertTrue(l.__add__.__objclass__ is list)
+            self.assertIs(l.__add__.__self__, l)
+            self.assertIs(l.__add__.__objclass__, list)
         else:
             # Python implementations where [].__add__ is a normal bound method
-            self.assertTrue(l.__add__.im_self is l)
-            self.assertTrue(l.__add__.im_class is list)
+            self.assertIs(l.__add__.im_self, l)
+            self.assertIs(l.__add__.im_class, list)
         self.assertEqual(l.__add__.__doc__, list.__add__.__doc__)
         try:
             hash(l.__add__)
@@ -4604,7 +4620,7 @@
 
         fake_str = FakeStr()
         # isinstance() reads __class__ on new style classes
-        self.assertTrue(isinstance(fake_str, str))
+        self.assertIsInstance(fake_str, str)
 
         # call a method descriptor
         with self.assertRaises(TypeError):
diff -r 3a1db0d2747e Lib/test/test_dis.py
--- a/Lib/test/test_dis.py
+++ b/Lib/test/test_dis.py
@@ -125,6 +125,8 @@
         # so fails if the tests are run with -O.  Skip this test then.
         if __debug__:
             self.do_disassembly_test(bug1333982, dis_bug1333982)
+        else:
+            self.skipTest('need asserts, run without -O')
 
     def test_big_linenos(self):
         def func(count):
diff -r 3a1db0d2747e Lib/test/test_doctest.py
--- a/Lib/test/test_doctest.py
+++ b/Lib/test/test_doctest.py
@@ -1019,6 +1019,33 @@
         ValueError: message
     TestResults(failed=1, attempted=1)
 
+If the exception does not have a message, you can still use
+IGNORE_EXCEPTION_DETAIL to normalize the modules between Python 2 and 3:
+
+    >>> def f(x):
+    ...     r'''
+    ...     >>> from Queue import Empty
+    ...     >>> raise Empty() #doctest: +IGNORE_EXCEPTION_DETAIL
+    ...     Traceback (most recent call last):
+    ...     foo.bar.Empty
+    ...     '''
+    >>> test = doctest.DocTestFinder().find(f)[0]
+    >>> doctest.DocTestRunner(verbose=False).run(test)
+    TestResults(failed=0, attempted=2)
+
+Note that a trailing colon doesn't matter either:
+
+    >>> def f(x):
+    ...     r'''
+    ...     >>> from Queue import Empty
+    ...     >>> raise Empty() #doctest: +IGNORE_EXCEPTION_DETAIL
+    ...     Traceback (most recent call last):
+    ...     foo.bar.Empty:
+    ...     '''
+    >>> test = doctest.DocTestFinder().find(f)[0]
+    >>> doctest.DocTestRunner(verbose=False).run(test)
+    TestResults(failed=0, attempted=2)
+
 If an exception is raised but not expected, then it is reported as an
 unexpected exception:
 
diff -r 3a1db0d2747e Lib/test/test_dumbdbm.py
--- a/Lib/test/test_dumbdbm.py
+++ b/Lib/test/test_dumbdbm.py
@@ -38,11 +38,9 @@
         self.read_helper(f)
         f.close()
 
+    @unittest.skipUnless(hasattr(os, 'chmod'), 'os.chmod not available')
+    @unittest.skipUnless(hasattr(os, 'umask'), 'os.umask not available')
     def test_dumbdbm_creation_mode(self):
-        # On platforms without chmod, don't do anything.
-        if not (hasattr(os, 'chmod') and hasattr(os, 'umask')):
-            return
-
         try:
             old_umask = os.umask(0002)
             f = dumbdbm.open(_fname, 'c', 0637)
diff -r 3a1db0d2747e Lib/test/test_enumerate.py
--- a/Lib/test/test_enumerate.py
+++ b/Lib/test/test_enumerate.py
@@ -188,11 +188,10 @@
         self.assertRaises(TypeError, reversed)
         self.assertRaises(TypeError, reversed, [], 'extra')
 
+    @unittest.skipUnless(hasattr(sys, 'getrefcount'), 'test needs sys.getrefcount()')
     def test_bug1229429(self):
         # this bug was never in reversed, it was in
         # PyObject_CallMethod, and reversed_new calls that sometimes.
-        if not hasattr(sys, "getrefcount"):
-            return
         def f():
             pass
         r = f.__reversed__ = object()
diff -r 3a1db0d2747e Lib/test/test_fcntl.py
--- a/Lib/test/test_fcntl.py
+++ b/Lib/test/test_fcntl.py
@@ -113,7 +113,10 @@
             self.skipTest("F_NOTIFY or DN_MULTISHOT unavailable")
         fd = os.open(os.path.dirname(os.path.abspath(TESTFN)), os.O_RDONLY)
         try:
+            # This will raise OverflowError if issue1309352 is present.
             fcntl.fcntl(fd, cmd, flags)
+        except IOError:
+            pass  # Running on a system that doesn't support these flags.
         finally:
             os.close(fd)
 
diff -r 3a1db0d2747e Lib/test/test_file2k.py
--- a/Lib/test/test_file2k.py
+++ b/Lib/test/test_file2k.py
@@ -415,6 +415,20 @@
         finally:
             os.unlink(TESTFN)
 
+    @unittest.skipUnless(os.name == 'posix', 'test requires a posix system.')
+    def test_write_full(self):
+        # Issue #17976
+        try:
+            f = open('/dev/full', 'w', 1)
+        except IOError:
+            self.skipTest("requires '/dev/full'")
+        try:
+            with self.assertRaises(IOError):
+                f.write('hello')
+                f.write('\n')
+        finally:
+            f.close()
+
 class FileSubclassTests(unittest.TestCase):
 
     def testExit(self):
diff -r 3a1db0d2747e Lib/test/test_fileio.py
--- a/Lib/test/test_fileio.py
+++ b/Lib/test/test_fileio.py
@@ -283,28 +283,29 @@
             self.assertEqual(f.seekable(), True)
             self.assertEqual(f.isatty(), False)
             f.close()
-
-            if sys.platform != "win32":
-                try:
-                    f = _FileIO("/dev/tty", "a")
-                except EnvironmentError:
-                    # When run in a cron job there just aren't any
-                    # ttys, so skip the test.  This also handles other
-                    # OS'es that don't support /dev/tty.
-                    pass
-                else:
-                    self.assertEqual(f.readable(), False)
-                    self.assertEqual(f.writable(), True)
-                    if sys.platform != "darwin" and \
-                       'bsd' not in sys.platform and \
-                       not sys.platform.startswith('sunos'):
-                        # Somehow /dev/tty appears seekable on some BSDs
-                        self.assertEqual(f.seekable(), False)
-                    self.assertEqual(f.isatty(), True)
-                    f.close()
         finally:
             os.unlink(TESTFN)
 
+    @unittest.skipIf(sys.platform == 'win32', 'no ttys on Windows')
+    def testAblesOnTTY(self):
+        try:
+            f = _FileIO("/dev/tty", "a")
+        except EnvironmentError:
+            # When run in a cron job there just aren't any
+            # ttys, so skip the test.  This also handles other
+            # OS'es that don't support /dev/tty.
+            self.skipTest('need /dev/tty')
+        else:
+            self.assertEqual(f.readable(), False)
+            self.assertEqual(f.writable(), True)
+            if sys.platform != "darwin" and \
+               'bsd' not in sys.platform and \
+               not sys.platform.startswith('sunos'):
+                # Somehow /dev/tty appears seekable on some BSDs
+                self.assertEqual(f.seekable(), False)
+            self.assertEqual(f.isatty(), True)
+            f.close()
+
     def testInvalidModeStrings(self):
         # check invalid mode strings
         for mode in ("", "aU", "wU+", "rw", "rt"):
@@ -342,8 +343,7 @@
         try:
             fn = TESTFN.encode("ascii")
         except UnicodeEncodeError:
-            # Skip test
-            return
+            self.skipTest('could not encode %r to ascii' % TESTFN)
         f = _FileIO(fn, "w")
         try:
             f.write(b"abc")
diff -r 3a1db0d2747e Lib/test/test_float.py
--- a/Lib/test/test_float.py
+++ b/Lib/test/test_float.py
@@ -101,7 +101,7 @@
         # it still has to accept the normal python syntax
         import locale
         if not locale.localeconv()['decimal_point'] == ',':
-            return
+            self.skipTest('decimal_point is not ","')
 
         self.assertEqual(float("  3.14  "), 3.14)
         self.assertEqual(float("+3.14  "), 3.14)
diff -r 3a1db0d2747e Lib/test/test_ftplib.py
--- a/Lib/test/test_ftplib.py
+++ b/Lib/test/test_ftplib.py
@@ -15,7 +15,7 @@
 except ImportError:
     ssl = None
 
-from unittest import TestCase
+from unittest import TestCase, SkipTest, skipUnless
 from test import test_support
 from test.test_support import HOST, HOSTv6
 threading = test_support.import_module('threading')
@@ -579,8 +579,16 @@
         self.assertRaises(ftplib.Error, self.client.storlines, 'stor', f)
 
 
+@skipUnless(socket.has_ipv6, "IPv6 not enabled")
 class TestIPv6Environment(TestCase):
 
+    @classmethod
+    def setUpClass(cls):
+        try:
+            DummyFTPServer((HOST, 0), af=socket.AF_INET6)
+        except socket.error:
+            raise SkipTest("IPv6 not enabled")
+
     def setUp(self):
         self.server = DummyFTPServer((HOSTv6, 0), af=socket.AF_INET6)
         self.server.start()
@@ -615,6 +623,7 @@
         retr()
 
 
+@skipUnless(ssl, "SSL not available")
 class TestTLS_FTPClassMixin(TestFTPClass):
     """Repeat TestFTPClass tests starting the TLS layer for both control
     and data connections first.
@@ -630,6 +639,7 @@
         self.client.prot_p()
 
 
+@skipUnless(ssl, "SSL not available")
 class TestTLS_FTPClass(TestCase):
     """Specific TLS_FTP class tests."""
 
@@ -783,17 +793,9 @@
 
 
 def test_main():
-    tests = [TestFTPClass, TestTimeouts]
-    if socket.has_ipv6:
-        try:
-            DummyFTPServer((HOST, 0), af=socket.AF_INET6)
-        except socket.error:
-            pass
-        else:
-            tests.append(TestIPv6Environment)
-
-    if ssl is not None:
-        tests.extend([TestTLS_FTPClassMixin, TestTLS_FTPClass])
+    tests = [TestFTPClass, TestTimeouts,
+             TestIPv6Environment,
+             TestTLS_FTPClassMixin, TestTLS_FTPClass]
 
     thread_info = test_support.threading_setup()
     try:
diff -r 3a1db0d2747e Lib/test/test_functools.py
--- a/Lib/test/test_functools.py
+++ b/Lib/test/test_functools.py
@@ -43,8 +43,6 @@
         self.assertEqual(p.args, (1, 2))
         self.assertEqual(p.keywords, dict(a=10, b=20))
         # attributes should not be writable
-        if not isinstance(self.thetype, type):
-            return
         self.assertRaises(TypeError, setattr, p, 'func', map)
         self.assertRaises(TypeError, setattr, p, 'args', (1, 2))
         self.assertRaises(TypeError, setattr, p, 'keywords', dict(a=1, b=2))
@@ -180,8 +178,10 @@
     thetype = PythonPartial
 
     # the python version isn't picklable
-    def test_pickle(self): pass
-    def test_setstate_refcount(self): pass
+    test_pickle = test_setstate_refcount = None
+
+    # the python version isn't a type
+    test_attributes = None
 
 class TestUpdateWrapper(unittest.TestCase):
 
diff -r 3a1db0d2747e Lib/test/test_gdb.py
--- a/Lib/test/test_gdb.py
+++ b/Lib/test/test_gdb.py
@@ -49,7 +49,7 @@
     return out, err
 
 # Verify that "gdb" was built with the embedded python support enabled:
-gdbpy_version, _ = run_gdb("--eval-command=python import sys; print sys.version_info")
+gdbpy_version, _ = run_gdb("--eval-command=python import sys; print(sys.version_info)")
 if not gdbpy_version:
     raise unittest.SkipTest("gdb not built with embedded python support")
 
@@ -214,7 +214,7 @@
         # matches repr(value) in this process:
         gdb_repr, gdb_output = self.get_gdb_repr('print ' + repr(val),
                                                  cmds_after_breakpoint)
-        self.assertEqual(gdb_repr, repr(val), gdb_output)
+        self.assertEqual(gdb_repr, repr(val))
 
     def test_int(self):
         'Verify the pretty-printing of various "int" values'
diff -r 3a1db0d2747e Lib/test/test_getargs2.py
--- a/Lib/test/test_getargs2.py
+++ b/Lib/test/test_getargs2.py
@@ -42,6 +42,13 @@
      INT_MIN, LONG_MIN, LONG_MAX, PY_SSIZE_T_MIN, PY_SSIZE_T_MAX, \
      SHRT_MIN, SHRT_MAX
 
+try:
+    from _testcapi import getargs_L, getargs_K
+except ImportError:
+    _PY_LONG_LONG_available = False
+else:
+    _PY_LONG_LONG_available = True
+
 # fake, they are not defined in Python's header files
 LLONG_MAX = 2**63-1
 LLONG_MIN = -2**63
@@ -208,6 +215,7 @@
         self.assertRaises(OverflowError, getargs_n, VERY_LARGE)
 
 
+@unittest.skipUnless(_PY_LONG_LONG_available, 'PY_LONG_LONG not available')
 class LongLong_TestCase(unittest.TestCase):
     def test_L(self):
         from _testcapi import getargs_L
@@ -322,13 +330,8 @@
             self.fail('TypeError should have been raised')
 
 def test_main():
-    tests = [Signed_TestCase, Unsigned_TestCase, Tuple_TestCase, Keywords_TestCase]
-    try:
-        from _testcapi import getargs_L, getargs_K
-    except ImportError:
-        pass # PY_LONG_LONG not available
-    else:
-        tests.append(LongLong_TestCase)
+    tests = [Signed_TestCase, Unsigned_TestCase, LongLong_TestCase,
+             Tuple_TestCase, Keywords_TestCase]
     test_support.run_unittest(*tests)
 
 if __name__ == "__main__":
diff -r 3a1db0d2747e Lib/test/test_grp.py
--- a/Lib/test/test_grp.py
+++ b/Lib/test/test_grp.py
@@ -26,8 +26,10 @@
         for e in entries:
             self.check_value(e)
 
+    def test_values_extended(self):
+        entries = grp.getgrall()
         if len(entries) > 1000:  # Huge group file (NIS?) -- skip the rest
-            return
+            self.skipTest('huge group file, extended test skipped')
 
         for e in entries:
             e2 = grp.getgrgid(e.gr_gid)
diff -r 3a1db0d2747e Lib/test/test_hashlib.py
--- a/Lib/test/test_hashlib.py
+++ b/Lib/test/test_hashlib.py
@@ -207,30 +207,20 @@
         self.check('md5', 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
                    'd174ab98d277d9f5a5611c2c9f419d9f')
 
-    @precisionbigmemtest(size=_4G + 5, memuse=1)
+    @unittest.skipIf(sys.maxsize < _4G + 5, 'test cannot run on 32-bit systems')
+    @precisionbigmemtest(size=_4G + 5, memuse=1, dry_run=False)
     def test_case_md5_huge(self, size):
-        if size == _4G + 5:
-            try:
-                self.check('md5', 'A'*size, 'c9af2dff37468ce5dfee8f2cfc0a9c6d')
-            except OverflowError:
-                pass # 32-bit arch
+        self.check('md5', 'A'*size, 'c9af2dff37468ce5dfee8f2cfc0a9c6d')
 
-    @precisionbigmemtest(size=_4G + 5, memuse=1)
+    @unittest.skipIf(sys.maxsize < _4G + 5, 'test cannot run on 32-bit systems')
+    @precisionbigmemtest(size=_4G + 5, memuse=1, dry_run=False)
     def test_case_md5_huge_update(self, size):
-        if size == _4G + 5:
-            try:
-                self.check_update('md5', 'A'*size,
-                        'c9af2dff37468ce5dfee8f2cfc0a9c6d')
-            except OverflowError:
-                pass # 32-bit arch
+        self.check_update('md5', 'A'*size, 'c9af2dff37468ce5dfee8f2cfc0a9c6d')
 
-    @precisionbigmemtest(size=_4G - 1, memuse=1)
+    @unittest.skipIf(sys.maxsize < _4G - 1, 'test cannot run on 32-bit systems')
+    @precisionbigmemtest(size=_4G - 1, memuse=1, dry_run=False)
     def test_case_md5_uintmax(self, size):
-        if size == _4G - 1:
-            try:
-                self.check('md5', 'A'*size, '28138d306ff1b8281f1a9067e1a1a2b3')
-            except OverflowError:
-                pass # 32-bit arch
+        self.check('md5', 'A'*size, '28138d306ff1b8281f1a9067e1a1a2b3')
 
     # use the three examples from Federal Information Processing Standards
     # Publication 180-1, Secure Hash Standard,  1995 April 17
diff -r 3a1db0d2747e Lib/test/test_htmlparser.py
--- a/Lib/test/test_htmlparser.py
+++ b/Lib/test/test_htmlparser.py
@@ -206,8 +206,7 @@
         self._run_check("</$>", [('comment', '$')])
         self._run_check("</", [('data', '</')])
         self._run_check("</a", [('data', '</a')])
-        # XXX this might be wrong
-        self._run_check("<a<a>", [('data', '<a'), ('starttag', 'a', [])])
+        self._run_check("<a<a>", [('starttag', 'a<a', [])])
         self._run_check("</a<a>", [('endtag', 'a<a')])
         self._run_check("<!", [('data', '<!')])
         self._run_check("<a", [('data', '<a')])
@@ -215,6 +214,11 @@
         self._run_check("<a foo='bar", [('data', "<a foo='bar")])
         self._run_check("<a foo='>'", [('data', "<a foo='>'")])
         self._run_check("<a foo='>", [('data', "<a foo='>")])
+        self._run_check("<a$>", [('starttag', 'a$', [])])
+        self._run_check("<a$b>", [('starttag', 'a$b', [])])
+        self._run_check("<a$b/>", [('startendtag', 'a$b', [])])
+        self._run_check("<a$b  >", [('starttag', 'a$b', [])])
+        self._run_check("<a$b  />", [('startendtag', 'a$b', [])])
 
     def test_valid_doctypes(self):
         # from http://www.w3.org/QA/2002/04/valid-dtd-list.html
diff -r 3a1db0d2747e Lib/test/test_httplib.py
--- a/Lib/test/test_httplib.py
+++ b/Lib/test/test_httplib.py
@@ -153,6 +153,8 @@
         sock = FakeSocket(body)
         resp = httplib.HTTPResponse(sock)
         resp.begin()
+        self.assertEqual(resp.read(0), '')  # Issue #20007
+        self.assertFalse(resp.isclosed())
         self.assertEqual(resp.read(), 'Text')
         self.assertTrue(resp.isclosed())
 
diff -r 3a1db0d2747e Lib/test/test_idle.py
--- a/Lib/test/test_idle.py
+++ b/Lib/test/test_idle.py
@@ -23,6 +23,10 @@
 # load_tests() if it finds it. (Unittest.main does the same.)
 load_tests = idletest.load_tests
 
+# pre-3.3 regrtest does not support the load_tests protocol. use test_main
+def test_main():
+    support.run_unittest(unittest.TestLoader().loadTestsFromModule(idletest))
+
 if __name__ == '__main__':
     # Until unittest supports resources, we emulate regrtest's -ugui
     # so loaded tests run the same as if textually present here.
diff -r 3a1db0d2747e Lib/test/test_imaplib.py
--- a/Lib/test/test_imaplib.py
+++ b/Lib/test/test_imaplib.py
@@ -165,6 +165,16 @@
                               self.imap_class, *server.server_address)
 
 
+    def test_linetoolong(self):
+        class TooLongHandler(SimpleIMAPHandler):
+            def handle(self):
+                # Send a very long response line
+                self.wfile.write('* OK ' + imaplib._MAXLINE*'x' + '\r\n')
+
+        with self.reaped_server(TooLongHandler) as server:
+            self.assertRaises(imaplib.IMAP4.error,
+                              self.imap_class, *server.server_address)
+
 class ThreadedNetworkedTests(BaseThreadedNetworkedTests):
 
     server_class = SocketServer.TCPServer
@@ -177,6 +187,9 @@
     server_class = SecureTCPServer
     imap_class = IMAP4_SSL
 
+    def test_linetoolong(self):
+        raise unittest.SkipTest("test is not reliable on 2.7; see issue 20118")
+
 
 class RemoteIMAPTest(unittest.TestCase):
     host = 'cyrus.andrew.cmu.edu'
diff -r 3a1db0d2747e Lib/test/test_imp.py
--- a/Lib/test/test_imp.py
+++ b/Lib/test/test_imp.py
@@ -2,7 +2,12 @@
 import unittest
 from test import test_support
 
+try:
+    import thread
+except ImportError:
+    thread = None
 
+@unittest.skipUnless(thread, 'threading not available')
 class LockTests(unittest.TestCase):
 
     """Very basic test of import lock functions."""
@@ -68,13 +73,8 @@
 def test_main():
     tests = [
         ReloadTests,
+        LockTests,
     ]
-    try:
-        import thread
-    except ImportError:
-        pass
-    else:
-        tests.append(LockTests)
     test_support.run_unittest(*tests)
 
 if __name__ == "__main__":
diff -r 3a1db0d2747e Lib/test/test_index.py
--- a/Lib/test/test_index.py
+++ b/Lib/test/test_index.py
@@ -91,7 +91,7 @@
         self.assertEqual(self.seq[self.o:self.o2], self.seq[1:3])
         self.assertEqual(self.seq[self.n:self.n2], self.seq[2:4])
 
-    def test_slice_bug7532(self):
+    def test_slice_bug7532a(self):
         seqlen = len(self.seq)
         self.o.ind = int(seqlen * 1.5)
         self.n.ind = seqlen + 2
@@ -99,9 +99,12 @@
         self.assertEqual(self.seq[:self.o], self.seq)
         self.assertEqual(self.seq[self.n:], self.seq[0:0])
         self.assertEqual(self.seq[:self.n], self.seq)
+
+    def test_slice_bug7532b(self):
         if isinstance(self.seq, ClassicSeq):
-            return
+            self.skipTest('test fails for ClassicSeq')
         # These tests fail for ClassicSeq (see bug #7532)
+        seqlen = len(self.seq)
         self.o2.ind = -seqlen - 2
         self.n2.ind = -int(seqlen * 1.5)
         self.assertEqual(self.seq[self.o2:], self.seq)
diff -r 3a1db0d2747e Lib/test/test_io.py
--- a/Lib/test/test_io.py
+++ b/Lib/test/test_io.py
@@ -393,14 +393,9 @@
         # a long time to build the >2GB file and takes >2GB of disk space
         # therefore the resource must be enabled to run this test.
         if sys.platform[:3] == 'win' or sys.platform == 'darwin':
-            if not support.is_resource_enabled("largefile"):
-                print("\nTesting large file ops skipped on %s." % sys.platform,
-                      file=sys.stderr)
-                print("It requires %d bytes and a long time." % self.LARGE,
-                      file=sys.stderr)
-                print("Use 'regrtest.py -u largefile test_io' to run it.",
-                      file=sys.stderr)
-                return
+            support.requires(
+                'largefile',
+                'test requires %s bytes and a long time to run' % self.LARGE)
         with self.open(support.TESTFN, "w+b", 0) as f:
             self.large_file_ops(f)
         with self.open(support.TESTFN, "w+b") as f:
@@ -650,6 +645,7 @@
 
         self.assertEqual(42, bufio.fileno())
 
+    @unittest.skip('test having existential crisis')
     def test_no_fileno(self):
         # XXX will we always have fileno() function? If so, kill
         # this test. Else, write it.
diff -r 3a1db0d2747e Lib/test/test_iter.py
--- a/Lib/test/test_iter.py
+++ b/Lib/test/test_iter.py
@@ -526,7 +526,7 @@
         d = {"one": 1, "two": 2, "three": 3}
         self.assertEqual(reduce(add, d), "".join(d.keys()))
 
-    # This test case will be removed if we don't have Unicode
+    @unittest.skipUnless(have_unicode, 'needs unicode support')
     def test_unicode_join_endcase(self):
 
         # This class inserts a Unicode object into its argument's natural
@@ -567,8 +567,6 @@
                 unlink(TESTFN)
             except OSError:
                 pass
-    if not have_unicode:
-        def test_unicode_join_endcase(self): pass
 
     # Test iterators with 'x in y' and 'x not in y'.
     def test_in_and_not_in(self):
diff -r 3a1db0d2747e Lib/test/test_locale.py
--- a/Lib/test/test_locale.py
+++ b/Lib/test/test_locale.py
@@ -372,6 +372,77 @@
             self.assertEqual('\xec\xa0\xbc'.split(), ['\xec\xa0\xbc'])
 
 
+class NormalizeTest(unittest.TestCase):
+    def check(self, localename, expected):
+        self.assertEqual(locale.normalize(localename), expected, msg=localename)
+
+    def test_locale_alias(self):
+        for localename, alias in locale.locale_alias.items():
+            self.check(localename, alias)
+
+    def test_empty(self):
+        self.check('', '')
+
+    def test_c(self):
+        self.check('c', 'C')
+        self.check('posix', 'C')
+
+    def test_english(self):
+        self.check('en', 'en_US.ISO8859-1')
+        self.check('EN', 'en_US.ISO8859-1')
+        self.check('en_US', 'en_US.ISO8859-1')
+        self.check('en_us', 'en_US.ISO8859-1')
+        self.check('en_GB', 'en_GB.ISO8859-1')
+        self.check('en_US.UTF-8', 'en_US.UTF-8')
+        self.check('en_US.utf8', 'en_US.UTF-8')
+        self.check('en_US:UTF-8', 'en_US.UTF-8')
+        self.check('en_US.ISO8859-1', 'en_US.ISO8859-1')
+        self.check('en_US.US-ASCII', 'en_US.ISO8859-1')
+        self.check('english', 'en_EN.ISO8859-1')
+
+    def test_hyphenated_encoding(self):
+        self.check('az_AZ.iso88599e', 'az_AZ.ISO8859-9E')
+        self.check('az_AZ.ISO8859-9E', 'az_AZ.ISO8859-9E')
+        self.check('tt_RU.koi8c', 'tt_RU.KOI8-C')
+        self.check('tt_RU.KOI8-C', 'tt_RU.KOI8-C')
+        self.check('lo_LA.cp1133', 'lo_LA.IBM-CP1133')
+        self.check('lo_LA.ibmcp1133', 'lo_LA.IBM-CP1133')
+        self.check('lo_LA.IBM-CP1133', 'lo_LA.IBM-CP1133')
+        self.check('uk_ua.microsoftcp1251', 'uk_UA.CP1251')
+        self.check('uk_ua.microsoft-cp1251', 'uk_UA.CP1251')
+        self.check('ka_ge.georgianacademy', 'ka_GE.GEORGIAN-ACADEMY')
+        self.check('ka_GE.GEORGIAN-ACADEMY', 'ka_GE.GEORGIAN-ACADEMY')
+        self.check('cs_CZ.iso88592', 'cs_CZ.ISO8859-2')
+        self.check('cs_CZ.ISO8859-2', 'cs_CZ.ISO8859-2')
+
+    def test_euro_modifier(self):
+        self.check('de_DE@euro', 'de_DE.ISO8859-15')
+        self.check('en_US.ISO8859-15@euro', 'en_US.ISO8859-15')
+
+    def test_latin_modifier(self):
+        self.check('be_BY.UTF-8@latin', 'be_BY.UTF-8@latin')
+        self.check('sr_RS.UTF-8@latin', 'sr_RS.UTF-8@latin')
+
+    def test_valencia_modifier(self):
+        self.check('ca_ES.UTF-8@valencia', 'ca_ES.UTF-8@valencia')
+        self.check('ca_ES@valencia', 'ca_ES.ISO8859-1@valencia')
+        self.check('ca@valencia', 'ca_ES.ISO8859-1@valencia')
+
+    def test_devanagari_modifier(self):
+        self.check('ks_IN.UTF-8@devanagari', 'ks_IN.UTF-8@devanagari')
+        self.check('ks_IN@devanagari', 'ks_IN.UTF-8@devanagari')
+        self.check('ks@devanagari', 'ks_IN.UTF-8@devanagari')
+        self.check('ks_IN.UTF-8', 'ks_IN.UTF-8')
+        self.check('ks_IN', 'ks_IN.UTF-8')
+        self.check('ks', 'ks_IN.UTF-8')
+        self.check('sd_IN.UTF-8@devanagari', 'sd_IN.UTF-8@devanagari')
+        self.check('sd_IN@devanagari', 'sd_IN.UTF-8@devanagari')
+        self.check('sd@devanagari', 'sd_IN.UTF-8@devanagari')
+        self.check('sd_IN.UTF-8', 'sd_IN.UTF-8')
+        self.check('sd_IN', 'sd_IN.UTF-8')
+        self.check('sd', 'sd_IN.UTF-8')
+
+
 class TestMiscellaneous(unittest.TestCase):
     def test_getpreferredencoding(self):
         # Invoke getpreferredencoding to make sure it does not cause exceptions.
@@ -406,7 +477,12 @@
             # Unsupported locale on this system
             self.skipTest('test needs Turkish locale')
         loc = locale.getlocale()
-        locale.setlocale(locale.LC_CTYPE, loc)
+        try:
+            locale.setlocale(locale.LC_CTYPE, loc)
+        except Exception as e:
+            self.fail("Failed to set locale %r (default locale is %r): %r" %
+                      (loc, oldlocale, e))
+        print("set locale %r (default locale is %r)" % (loc, oldlocale))
         self.assertEqual(loc, locale.getlocale())
 
     def test_normalize_issue12752(self):
diff -r 3a1db0d2747e Lib/test/test_macos.py
--- a/Lib/test/test_macos.py
+++ b/Lib/test/test_macos.py
@@ -8,11 +8,9 @@
 TESTFN2 = test_support.TESTFN + '2'
 
 class TestMacOS(unittest.TestCase):
-
+    @unittest.skipUnless(os.path.exists('/Developer/Tools/SetFile'),
+                         '/Developer/Tools/SetFile does not exist')
     def testGetCreatorAndType(self):
-        if not os.path.exists('/Developer/Tools/SetFile'):
-            return
-
         try:
             fp = open(test_support.TESTFN, 'w')
             fp.write('\n')
@@ -29,10 +27,9 @@
         finally:
             os.unlink(test_support.TESTFN)
 
+    @unittest.skipUnless(os.path.exists('/Developer/Tools/GetFileInfo'),
+                         '/Developer/Tools/GetFileInfo does not exist')
     def testSetCreatorAndType(self):
-        if not os.path.exists('/Developer/Tools/GetFileInfo'):
-            return
-
         try:
             fp = open(test_support.TESTFN, 'w')
             fp.write('\n')
diff -r 3a1db0d2747e Lib/test/test_macostools.py
--- a/Lib/test/test_macostools.py
+++ b/Lib/test/test_macostools.py
@@ -12,6 +12,8 @@
 
 TESTFN2 = test_support.TESTFN + '2'
 
+requires_32bit = unittest.skipUnless(sys.maxint < 2**32, '32-bit only test')
+
 class TestMacostools(unittest.TestCase):
 
     def setUp(self):
@@ -51,30 +53,32 @@
                                           DeprecationWarning), quiet=True):
             macostools.touched(test_support.TESTFN)
 
-    if sys.maxint < 2**32:
-        def test_copy(self):
-            test_support.unlink(TESTFN2)
-            macostools.copy(test_support.TESTFN, TESTFN2)
-            self.assertEqual(self.compareData(), '')
+    @requires_32bit
+    def test_copy(self):
+        test_support.unlink(TESTFN2)
+        macostools.copy(test_support.TESTFN, TESTFN2)
+        self.assertEqual(self.compareData(), '')
 
-    if sys.maxint < 2**32:
-        def test_mkalias(self):
-            test_support.unlink(TESTFN2)
-            macostools.mkalias(test_support.TESTFN, TESTFN2)
-            fss, _, _ = Carbon.File.ResolveAliasFile(TESTFN2, 0)
-            self.assertEqual(fss.as_pathname(), os.path.realpath(test_support.TESTFN))
+    @requires_32bit
+    def test_mkalias(self):
+        test_support.unlink(TESTFN2)
+        macostools.mkalias(test_support.TESTFN, TESTFN2)
+        fss, _, _ = Carbon.File.ResolveAliasFile(TESTFN2, 0)
+        self.assertEqual(fss.as_pathname(), os.path.realpath(test_support.TESTFN))
 
-        def test_mkalias_relative(self):
-            test_support.unlink(TESTFN2)
-            # If the directory doesn't exist, then chances are this is a new
-            # install of Python so don't create it since the user might end up
-            # running ``sudo make install`` and creating the directory here won't
-            # leave it with the proper permissions.
-            if not os.path.exists(sys.prefix):
-                return
-            macostools.mkalias(test_support.TESTFN, TESTFN2, sys.prefix)
-            fss, _, _ = Carbon.File.ResolveAliasFile(TESTFN2, 0)
-            self.assertEqual(fss.as_pathname(), os.path.realpath(test_support.TESTFN))
+    @requires_32bit
+    # If the directory doesn't exist, then chances are this is a new
+    # install of Python so don't create it since the user might end up
+    # running ``sudo make install`` and creating the directory here won't
+    # leave it with the proper permissions.
+    @unittest.skipUnless(os.path.exists(sys.prefix),
+                         "%r doesn't exist" % sys.prefix)
+    def test_mkalias_relative(self):
+        test_support.unlink(TESTFN2)
+
+        macostools.mkalias(test_support.TESTFN, TESTFN2, sys.prefix)
+        fss, _, _ = Carbon.File.ResolveAliasFile(TESTFN2, 0)
+        self.assertEqual(fss.as_pathname(), os.path.realpath(test_support.TESTFN))
 
 
 def test_main():
diff -r 3a1db0d2747e Lib/test/test_mailbox.py
--- a/Lib/test/test_mailbox.py
+++ b/Lib/test/test_mailbox.py
@@ -772,10 +772,10 @@
         for msg in self._box:
             pass
 
+    @unittest.skipUnless(hasattr(os, 'umask'), 'test needs os.umask()')
+    @unittest.skipUnless(hasattr(os, 'stat'), 'test needs os.stat()')
     def test_file_permissions(self):
         # Verify that message files are created without execute permissions
-        if not hasattr(os, "stat") or not hasattr(os, "umask"):
-            return
         msg = mailbox.MaildirMessage(self._template % 0)
         orig_umask = os.umask(0)
         try:
@@ -786,12 +786,11 @@
         mode = os.stat(path).st_mode
         self.assertEqual(mode & 0111, 0)
 
+    @unittest.skipUnless(hasattr(os, 'umask'), 'test needs os.umask()')
+    @unittest.skipUnless(hasattr(os, 'stat'), 'test needs os.stat()')
     def test_folder_file_perms(self):
         # From bug #3228, we want to verify that the file created inside a Maildir
         # subfolder isn't marked as executable.
-        if not hasattr(os, "stat") or not hasattr(os, "umask"):
-            return
-
         orig_umask = os.umask(0)
         try:
             subfolder = self._box.add_folder('subfolder')
@@ -991,24 +990,25 @@
 
     _factory = lambda self, path, factory=None: mailbox.mbox(path, factory)
 
+    @unittest.skipUnless(hasattr(os, 'umask'), 'test needs os.umask()')
+    @unittest.skipUnless(hasattr(os, 'stat'), 'test needs os.stat()')
     def test_file_perms(self):
         # From bug #3228, we want to verify that the mailbox file isn't executable,
         # even if the umask is set to something that would leave executable bits set.
         # We only run this test on platforms that support umask.
-        if hasattr(os, 'umask') and hasattr(os, 'stat'):
-            try:
-                old_umask = os.umask(0077)
-                self._box.close()
-                os.unlink(self._path)
-                self._box = mailbox.mbox(self._path, create=True)
-                self._box.add('')
-                self._box.close()
-            finally:
-                os.umask(old_umask)
+        try:
+            old_umask = os.umask(0077)
+            self._box.close()
+            os.unlink(self._path)
+            self._box = mailbox.mbox(self._path, create=True)
+            self._box.add('')
+            self._box.close()
+        finally:
+            os.umask(old_umask)
 
-            st = os.stat(self._path)
-            perms = st.st_mode
-            self.assertFalse((perms & 0111)) # Execute bits should all be off.
+        st = os.stat(self._path)
+        perms = st.st_mode
+        self.assertFalse((perms & 0111)) # Execute bits should all be off.
 
     def test_terminating_newline(self):
         message = email.message.Message()
diff -r 3a1db0d2747e Lib/test/test_marshal.py
--- a/Lib/test/test_marshal.py
+++ b/Lib/test/test_marshal.py
@@ -286,7 +286,7 @@
         self.check_unmarshallable('x' * size)
 
     @test_support.precisionbigmemtest(size=LARGE_SIZE,
-            memuse=character_size, dry_run=False)
+            memuse=character_size + 2, dry_run=False)
     def test_unicode(self, size):
         self.check_unmarshallable(u'x' * size)
 
diff -r 3a1db0d2747e Lib/test/test_math.py
--- a/Lib/test/test_math.py
+++ b/Lib/test/test_math.py
@@ -906,38 +906,37 @@
     # still fails this part of the test on some platforms.  For now, we only
     # *run* test_exceptions() in verbose mode, so that this isn't normally
     # tested.
+    @unittest.skipUnless(verbose, 'requires verbose mode')
+    def test_exceptions(self):
+        try:
+            x = math.exp(-1000000000)
+        except:
+            # mathmodule.c is failing to weed out underflows from libm, or
+            # we've got an fp format with huge dynamic range
+            self.fail("underflowing exp() should not have raised "
+                        "an exception")
+        if x != 0:
+            self.fail("underflowing exp() should have returned 0")
 
-    if verbose:
-        def test_exceptions(self):
-            try:
-                x = math.exp(-1000000000)
-            except:
-                # mathmodule.c is failing to weed out underflows from libm, or
-                # we've got an fp format with huge dynamic range
-                self.fail("underflowing exp() should not have raised "
-                          "an exception")
-            if x != 0:
-                self.fail("underflowing exp() should have returned 0")
+        # If this fails, probably using a strict IEEE-754 conforming libm, and x
+        # is +Inf afterwards.  But Python wants overflows detected by default.
+        try:
+            x = math.exp(1000000000)
+        except OverflowError:
+            pass
+        else:
+            self.fail("overflowing exp() didn't trigger OverflowError")
 
-            # If this fails, probably using a strict IEEE-754 conforming libm, and x
-            # is +Inf afterwards.  But Python wants overflows detected by default.
-            try:
-                x = math.exp(1000000000)
-            except OverflowError:
-                pass
-            else:
-                self.fail("overflowing exp() didn't trigger OverflowError")
-
-            # If this fails, it could be a puzzle.  One odd possibility is that
-            # mathmodule.c's macros are getting confused while comparing
-            # Inf (HUGE_VAL) to a NaN, and artificially setting errno to ERANGE
-            # as a result (and so raising OverflowError instead).
-            try:
-                x = math.sqrt(-1.0)
-            except ValueError:
-                pass
-            else:
-                self.fail("sqrt(-1) didn't raise ValueError")
+        # If this fails, it could be a puzzle.  One odd possibility is that
+        # mathmodule.c's macros are getting confused while comparing
+        # Inf (HUGE_VAL) to a NaN, and artificially setting errno to ERANGE
+        # as a result (and so raising OverflowError instead).
+        try:
+            x = math.sqrt(-1.0)
+        except ValueError:
+            pass
+        else:
+            self.fail("sqrt(-1) didn't raise ValueError")
 
     @requires_IEEE_754
     def test_testfile(self):
diff -r 3a1db0d2747e Lib/test/test_memoryview.py
--- a/Lib/test/test_memoryview.py
+++ b/Lib/test/test_memoryview.py
@@ -63,7 +63,7 @@
 
     def test_setitem_readonly(self):
         if not self.ro_type:
-            return
+            self.skipTest("no read-only type to test")
         b = self.ro_type(self._source)
         oldrefcount = sys.getrefcount(b)
         m = self._view(b)
@@ -77,7 +77,7 @@
 
     def test_setitem_writable(self):
         if not self.rw_type:
-            return
+            self.skipTest("no writable type to test")
         tp = self.rw_type
         b = self.rw_type(self._source)
         oldrefcount = sys.getrefcount(b)
@@ -183,13 +183,13 @@
 
     def test_attributes_readonly(self):
         if not self.ro_type:
-            return
+            self.skipTest("no read-only type to test")
         m = self.check_attributes_with_type(self.ro_type)
         self.assertEqual(m.readonly, True)
 
     def test_attributes_writable(self):
         if not self.rw_type:
-            return
+            self.skipTest("no writable type to test")
         m = self.check_attributes_with_type(self.rw_type)
         self.assertEqual(m.readonly, False)
 
@@ -236,7 +236,7 @@
         # buffer as writable causing a segfault if using mmap
         tp = self.ro_type
         if tp is None:
-            return
+            self.skipTest("no read-only type to test")
         b = tp(self._source)
         m = self._view(b)
         i = io.BytesIO(b'ZZZZ')
diff -r 3a1db0d2747e Lib/test/test_minidom.py
--- a/Lib/test/test_minidom.py
+++ b/Lib/test/test_minidom.py
@@ -340,19 +340,6 @@
                 and el.getAttribute("spam2") == "bam2")
         dom.unlink()
 
-    def testGetAttrList(self):
-        pass
-
-    def testGetAttrValues(self): pass
-
-    def testGetAttrLength(self): pass
-
-    def testGetAttribute(self): pass
-
-    def testGetAttributeNS(self): pass
-
-    def testGetAttributeNode(self): pass
-
     def testGetElementsByTagNameNS(self):
         d="""<foo xmlns:minidom='http://pyxml.sf.net/minidom'>
         <minidom:myelem/>
@@ -423,8 +410,6 @@
         self.confirm(str(node) == repr(node))
         dom.unlink()
 
-    def testTextNodeRepr(self): pass
-
     def testWriteXML(self):
         str = '<?xml version="1.0" ?><a b="c"/>'
         dom = parseString(str)
@@ -488,14 +473,6 @@
                 and pi.localName is None
                 and pi.namespaceURI == xml.dom.EMPTY_NAMESPACE)
 
-    def testProcessingInstructionRepr(self): pass
-
-    def testTextRepr(self): pass
-
-    def testWriteText(self): pass
-
-    def testDocumentElement(self): pass
-
     def testTooManyDocumentElements(self):
         doc = parseString("<doc/>")
         elem = doc.createElement("extra")
@@ -504,26 +481,6 @@
         elem.unlink()
         doc.unlink()
 
-    def testCreateElementNS(self): pass
-
-    def testCreateAttributeNS(self): pass
-
-    def testParse(self): pass
-
-    def testParseString(self): pass
-
-    def testComment(self): pass
-
-    def testAttrListItem(self): pass
-
-    def testAttrListItems(self): pass
-
-    def testAttrListItemNS(self): pass
-
-    def testAttrListKeys(self): pass
-
-    def testAttrListKeysNS(self): pass
-
     def testRemoveNamedItem(self):
         doc = parseString("<doc a=''/>")
         e = doc.documentElement
@@ -543,32 +500,6 @@
         self.assertRaises(xml.dom.NotFoundErr, attrs.removeNamedItemNS,
                           "http://xml.python.org/", "b")
 
-    def testAttrListValues(self): pass
-
-    def testAttrListLength(self): pass
-
-    def testAttrList__getitem__(self): pass
-
-    def testAttrList__setitem__(self): pass
-
-    def testSetAttrValueandNodeValue(self): pass
-
-    def testParseElement(self): pass
-
-    def testParseAttributes(self): pass
-
-    def testParseElementNamespaces(self): pass
-
-    def testParseAttributeNamespaces(self): pass
-
-    def testParseProcessingInstructions(self): pass
-
-    def testChildNodes(self): pass
-
-    def testFirstChild(self): pass
-
-    def testHasChildNodes(self): pass
-
     def _testCloneElementCopiesAttributes(self, e1, e2, test):
         attrs1 = e1.attributes
         attrs2 = e2.attributes
diff -r 3a1db0d2747e Lib/test/test_mmap.py
--- a/Lib/test/test_mmap.py
+++ b/Lib/test/test_mmap.py
@@ -320,26 +320,25 @@
         mf.close()
         f.close()
 
+    @unittest.skipUnless(hasattr(os, "stat"), "needs os.stat()")
     def test_entire_file(self):
         # test mapping of entire file by passing 0 for map length
-        if hasattr(os, "stat"):
-            f = open(TESTFN, "w+")
+        f = open(TESTFN, "w+")
 
-            f.write(2**16 * 'm') # Arbitrary character
-            f.close()
+        f.write(2**16 * 'm') # Arbitrary character
+        f.close()
 
-            f = open(TESTFN, "rb+")
-            mf = mmap.mmap(f.fileno(), 0)
-            self.assertEqual(len(mf), 2**16, "Map size should equal file size.")
-            self.assertEqual(mf.read(2**16), 2**16 * "m")
-            mf.close()
-            f.close()
+        f = open(TESTFN, "rb+")
+        mf = mmap.mmap(f.fileno(), 0)
+        self.assertEqual(len(mf), 2**16, "Map size should equal file size.")
+        self.assertEqual(mf.read(2**16), 2**16 * "m")
+        mf.close()
+        f.close()
 
+    @unittest.skipUnless(hasattr(os, "stat"), "needs os.stat()")
     def test_length_0_offset(self):
         # Issue #10916: test mapping of remainder of file by passing 0 for
         # map length with an offset doesn't cause a segfault.
-        if not hasattr(os, "stat"):
-            self.skipTest("needs os.stat")
         # NOTE: allocation granularity is currently 65536 under Win64,
         # and therefore the minimum offset alignment.
         with open(TESTFN, "wb") as f:
@@ -352,12 +351,10 @@
             finally:
                 mf.close()
 
+    @unittest.skipUnless(hasattr(os, "stat"), "needs os.stat()")
     def test_length_0_large_offset(self):
         # Issue #10959: test mapping of a file by passing 0 for
         # map length with a large offset doesn't cause a segfault.
-        if not hasattr(os, "stat"):
-            self.skipTest("needs os.stat")
-
         with open(TESTFN, "wb") as f:
             f.write(115699 * b'm') # Arbitrary character
 
@@ -538,9 +535,8 @@
                 return mmap.mmap.__new__(klass, -1, *args, **kwargs)
         anon_mmap(PAGESIZE)
 
+    @unittest.skipUnless(hasattr(mmap, 'PROT_READ'), "needs mmap.PROT_READ")
     def test_prot_readonly(self):
-        if not hasattr(mmap, 'PROT_READ'):
-            return
         mapsize = 10
         open(TESTFN, "wb").write("a"*mapsize)
         f = open(TESTFN, "rb")
@@ -584,66 +580,68 @@
         m.seek(8)
         self.assertRaises(ValueError, m.write, "bar")
 
-    if os.name == 'nt':
-        def test_tagname(self):
-            data1 = "0123456789"
-            data2 = "abcdefghij"
-            assert len(data1) == len(data2)
+    @unittest.skipUnless(os.name == 'nt', 'requires Windows')
+    def test_tagname(self):
+        data1 = "0123456789"
+        data2 = "abcdefghij"
+        assert len(data1) == len(data2)
 
-            # Test same tag
-            m1 = mmap.mmap(-1, len(data1), tagname="foo")
-            m1[:] = data1
-            m2 = mmap.mmap(-1, len(data2), tagname="foo")
-            m2[:] = data2
-            self.assertEqual(m1[:], data2)
-            self.assertEqual(m2[:], data2)
-            m2.close()
-            m1.close()
+        # Test same tag
+        m1 = mmap.mmap(-1, len(data1), tagname="foo")
+        m1[:] = data1
+        m2 = mmap.mmap(-1, len(data2), tagname="foo")
+        m2[:] = data2
+        self.assertEqual(m1[:], data2)
+        self.assertEqual(m2[:], data2)
+        m2.close()
+        m1.close()
 
-            # Test different tag
-            m1 = mmap.mmap(-1, len(data1), tagname="foo")
-            m1[:] = data1
-            m2 = mmap.mmap(-1, len(data2), tagname="boo")
-            m2[:] = data2
-            self.assertEqual(m1[:], data1)
-            self.assertEqual(m2[:], data2)
-            m2.close()
-            m1.close()
+        # Test different tag
+        m1 = mmap.mmap(-1, len(data1), tagname="foo")
+        m1[:] = data1
+        m2 = mmap.mmap(-1, len(data2), tagname="boo")
+        m2[:] = data2
+        self.assertEqual(m1[:], data1)
+        self.assertEqual(m2[:], data2)
+        m2.close()
+        m1.close()
 
-        def test_crasher_on_windows(self):
-            # Should not crash (Issue 1733986)
-            m = mmap.mmap(-1, 1000, tagname="foo")
-            try:
-                mmap.mmap(-1, 5000, tagname="foo")[:] # same tagname, but larger size
-            except:
-                pass
-            m.close()
+    @unittest.skipUnless(os.name == 'nt', 'requires Windows')
+    def test_crasher_on_windows(self):
+        # Should not crash (Issue 1733986)
+        m = mmap.mmap(-1, 1000, tagname="foo")
+        try:
+            mmap.mmap(-1, 5000, tagname="foo")[:] # same tagname, but larger size
+        except:
+            pass
+        m.close()
 
-            # Should not crash (Issue 5385)
-            open(TESTFN, "wb").write("x"*10)
-            f = open(TESTFN, "r+b")
-            m = mmap.mmap(f.fileno(), 0)
-            f.close()
-            try:
-                m.resize(0) # will raise WindowsError
-            except:
-                pass
-            try:
-                m[:]
-            except:
-                pass
-            m.close()
+        # Should not crash (Issue 5385)
+        open(TESTFN, "wb").write("x"*10)
+        f = open(TESTFN, "r+b")
+        m = mmap.mmap(f.fileno(), 0)
+        f.close()
+        try:
+            m.resize(0) # will raise WindowsError
+        except:
+            pass
+        try:
+            m[:]
+        except:
+            pass
+        m.close()
 
-        def test_invalid_descriptor(self):
-            # socket file descriptors are valid, but out of range
-            # for _get_osfhandle, causing a crash when validating the
-            # parameters to _get_osfhandle.
-            s = socket.socket()
-            try:
-                with self.assertRaises(mmap.error):
-                    m = mmap.mmap(s.fileno(), 10)
-            finally:
-                s.close()
+    @unittest.skipUnless(os.name == 'nt', 'requires Windows')
+    def test_invalid_descriptor(self):
+        # socket file descriptors are valid, but out of range
+        # for _get_osfhandle, causing a crash when validating the
+        # parameters to _get_osfhandle.
+        s = socket.socket()
+        try:
+            with self.assertRaises(mmap.error):
+                m = mmap.mmap(s.fileno(), 10)
+        finally:
+            s.close()
 
 
 class LargeMmapTests(unittest.TestCase):
diff -r 3a1db0d2747e Lib/test/test_multibytecodec.py
--- a/Lib/test/test_multibytecodec.py
+++ b/Lib/test/test_multibytecodec.py
@@ -157,57 +157,55 @@
             os.unlink(TESTFN)
 
 class Test_StreamWriter(unittest.TestCase):
-    if len(u'\U00012345') == 2: # UCS2
-        def test_gb18030(self):
-            s = StringIO.StringIO()
-            c = codecs.getwriter('gb18030')(s)
-            c.write(u'123')
-            self.assertEqual(s.getvalue(), '123')
-            c.write(u'\U00012345')
-            self.assertEqual(s.getvalue(), '123\x907\x959')
+    @unittest.skipUnless(len(u'\U00012345') == 2, 'need a narrow build')
+    def test_gb18030(self):
+        s = StringIO.StringIO()
+        c = codecs.getwriter('gb18030')(s)
+        c.write(u'123')
+        self.assertEqual(s.getvalue(), '123')
+        c.write(u'\U00012345')
+        self.assertEqual(s.getvalue(), '123\x907\x959')
+        c.write(u'\U00012345'[0])
+        self.assertEqual(s.getvalue(), '123\x907\x959')
+        c.write(u'\U00012345'[1] + u'\U00012345' + u'\uac00\u00ac')
+        self.assertEqual(s.getvalue(),
+                '123\x907\x959\x907\x959\x907\x959\x827\xcf5\x810\x851')
+        c.write(u'\U00012345'[0])
+        self.assertEqual(s.getvalue(),
+                '123\x907\x959\x907\x959\x907\x959\x827\xcf5\x810\x851')
+        self.assertRaises(UnicodeError, c.reset)
+        self.assertEqual(s.getvalue(),
+                '123\x907\x959\x907\x959\x907\x959\x827\xcf5\x810\x851')
+
+    @unittest.skipUnless(len(u'\U00012345') == 2, 'need a narrow build')
+    def test_utf_8(self):
+        s= StringIO.StringIO()
+        c = codecs.getwriter('utf-8')(s)
+        c.write(u'123')
+        self.assertEqual(s.getvalue(), '123')
+        c.write(u'\U00012345')
+        self.assertEqual(s.getvalue(), '123\xf0\x92\x8d\x85')
+
+        # Python utf-8 codec can't buffer surrogate pairs yet.
+        if 0:
             c.write(u'\U00012345'[0])
-            self.assertEqual(s.getvalue(), '123\x907\x959')
+            self.assertEqual(s.getvalue(), '123\xf0\x92\x8d\x85')
             c.write(u'\U00012345'[1] + u'\U00012345' + u'\uac00\u00ac')
             self.assertEqual(s.getvalue(),
-                    '123\x907\x959\x907\x959\x907\x959\x827\xcf5\x810\x851')
+                '123\xf0\x92\x8d\x85\xf0\x92\x8d\x85\xf0\x92\x8d\x85'
+                '\xea\xb0\x80\xc2\xac')
             c.write(u'\U00012345'[0])
             self.assertEqual(s.getvalue(),
-                    '123\x907\x959\x907\x959\x907\x959\x827\xcf5\x810\x851')
-            self.assertRaises(UnicodeError, c.reset)
+                '123\xf0\x92\x8d\x85\xf0\x92\x8d\x85\xf0\x92\x8d\x85'
+                '\xea\xb0\x80\xc2\xac')
+            c.reset()
             self.assertEqual(s.getvalue(),
-                    '123\x907\x959\x907\x959\x907\x959\x827\xcf5\x810\x851')
-
-        def test_utf_8(self):
-            s= StringIO.StringIO()
-            c = codecs.getwriter('utf-8')(s)
-            c.write(u'123')
-            self.assertEqual(s.getvalue(), '123')
-            c.write(u'\U00012345')
-            self.assertEqual(s.getvalue(), '123\xf0\x92\x8d\x85')
-
-            # Python utf-8 codec can't buffer surrogate pairs yet.
-            if 0:
-                c.write(u'\U00012345'[0])
-                self.assertEqual(s.getvalue(), '123\xf0\x92\x8d\x85')
-                c.write(u'\U00012345'[1] + u'\U00012345' + u'\uac00\u00ac')
-                self.assertEqual(s.getvalue(),
-                    '123\xf0\x92\x8d\x85\xf0\x92\x8d\x85\xf0\x92\x8d\x85'
-                    '\xea\xb0\x80\xc2\xac')
-                c.write(u'\U00012345'[0])
-                self.assertEqual(s.getvalue(),
-                    '123\xf0\x92\x8d\x85\xf0\x92\x8d\x85\xf0\x92\x8d\x85'
-                    '\xea\xb0\x80\xc2\xac')
-                c.reset()
-                self.assertEqual(s.getvalue(),
-                    '123\xf0\x92\x8d\x85\xf0\x92\x8d\x85\xf0\x92\x8d\x85'
-                    '\xea\xb0\x80\xc2\xac\xed\xa0\x88')
-                c.write(u'\U00012345'[1])
-                self.assertEqual(s.getvalue(),
-                    '123\xf0\x92\x8d\x85\xf0\x92\x8d\x85\xf0\x92\x8d\x85'
-                    '\xea\xb0\x80\xc2\xac\xed\xa0\x88\xed\xbd\x85')
-
-    else: # UCS4
-        pass
+                '123\xf0\x92\x8d\x85\xf0\x92\x8d\x85\xf0\x92\x8d\x85'
+                '\xea\xb0\x80\xc2\xac\xed\xa0\x88')
+            c.write(u'\U00012345'[1])
+            self.assertEqual(s.getvalue(),
+                '123\xf0\x92\x8d\x85\xf0\x92\x8d\x85\xf0\x92\x8d\x85'
+                '\xea\xb0\x80\xc2\xac\xed\xa0\x88\xed\xbd\x85')
 
     def test_streamwriter_strwrite(self):
         s = StringIO.StringIO()
diff -r 3a1db0d2747e Lib/test/test_multibytecodec_support.py
--- a/Lib/test/test_multibytecodec_support.py
+++ b/Lib/test/test_multibytecodec_support.py
@@ -67,7 +67,7 @@
 
     def test_xmlcharrefreplace(self):
         if self.has_iso10646:
-            return
+            self.skipTest('encoding contains full ISO 10646 map')
 
         s = u"\u0b13\u0b23\u0b60 nd eggs"
         self.assertEqual(
@@ -77,7 +77,7 @@
 
     def test_customreplace_encode(self):
         if self.has_iso10646:
-            return
+            self.skipTest('encoding contains full ISO 10646 map')
 
         from htmlentitydefs import codepoint2name
 
diff -r 3a1db0d2747e Lib/test/test_multiprocessing.py
--- a/Lib/test/test_multiprocessing.py
+++ b/Lib/test/test_multiprocessing.py
@@ -182,7 +182,7 @@
 
     def test_current(self):
         if self.TYPE == 'threads':
-            return
+            self.skipTest('test not appropriate for {}'.format(self.TYPE))
 
         current = self.current_process()
         authkey = current.authkey
@@ -249,7 +249,7 @@
 
     def test_terminate(self):
         if self.TYPE == 'threads':
-            return
+            self.skipTest('test not appropriate for {}'.format(self.TYPE))
 
         p = self.Process(target=self._test_terminate)
         p.daemon = True
@@ -334,12 +334,12 @@
     def test_sys_exit(self):
         # See Issue 13854
         if self.TYPE == 'threads':
-            return
+            self.skipTest('test not appropriate for {}'.format(self.TYPE))
 
         testfn = test_support.TESTFN
         self.addCleanup(test_support.unlink, testfn)
 
-        for reason, code in (([1, 2, 3], 1), ('ignore this', 0)):
+        for reason, code in (([1, 2, 3], 1), ('ignore this', 1)):
             p = self.Process(target=self._test_sys_exit, args=(reason, testfn))
             p.daemon = True
             p.start()
@@ -582,7 +582,7 @@
         try:
             self.assertEqual(q.qsize(), 0)
         except NotImplementedError:
-            return
+            self.skipTest('qsize method not implemented')
         q.put(1)
         self.assertEqual(q.qsize(), 1)
         q.put(5)
@@ -683,7 +683,7 @@
 
     def test_timeout(self):
         if self.TYPE != 'processes':
-            return
+            self.skipTest('test not appropriate for {}'.format(self.TYPE))
 
         sem = self.Semaphore(0)
         acquire = TimingWrapper(sem.acquire)
@@ -1117,6 +1117,16 @@
         self.assertEqual(pmap(sqr, range(100), chunksize=20),
                          map(sqr, range(100)))
 
+    def test_map_unplicklable(self):
+        # Issue #19425 -- failure to pickle should not cause a hang
+        if self.TYPE == 'threads':
+            self.skipTest('test not appropriate for {}'.format(self.TYPE))
+        class A(object):
+            def __reduce__(self):
+                raise RuntimeError('cannot pickle')
+        with self.assertRaises(RuntimeError):
+            self.pool.map(sqr, [A()]*10)
+
     def test_map_chunksize(self):
         try:
             self.pool.map_async(sqr, [], chunksize=1).get(timeout=TIMEOUT1)
@@ -1130,7 +1140,7 @@
         self.assertTimingAlmostEqual(get.elapsed, TIMEOUT1)
 
     def test_async_timeout(self):
-        res = self.pool.apply_async(sqr, (6, TIMEOUT2 + 0.2))
+        res = self.pool.apply_async(sqr, (6, TIMEOUT2 + 1.0))
         get = TimingWrapper(res.get)
         self.assertRaises(multiprocessing.TimeoutError, get, timeout=TIMEOUT2)
         self.assertTimingAlmostEqual(get.elapsed, TIMEOUT2)
@@ -1166,20 +1176,12 @@
         p.join()
 
     def test_terminate(self):
-        if self.TYPE == 'manager':
-            # On Unix a forked process increfs each shared object to
-            # which its parent process held a reference.  If the
-            # forked process gets terminated then there is likely to
-            # be a reference leak.  So to prevent
-            # _TestZZZNumberOfObjects from failing we skip this test
-            # when using a manager.
-            return
-
-        result = self.pool.map_async(
+        p = self.Pool(4)
+        result = p.map_async(
             time.sleep, [0.1 for i in range(10000)], chunksize=1
             )
-        self.pool.terminate()
-        join = TimingWrapper(self.pool.join)
+        p.terminate()
+        join = TimingWrapper(p.join)
         join()
         self.assertTrue(join.elapsed < 0.2)
 
@@ -1571,7 +1573,7 @@
 
     def test_sendbytes(self):
         if self.TYPE != 'processes':
-            return
+            self.skipTest('test not appropriate for {}'.format(self.TYPE))
 
         msg = latin('abcdefghijklmnopqrstuvwxyz')
         a, b = self.Pipe()
diff -r 3a1db0d2747e Lib/test/test_nis.py
--- a/Lib/test/test_nis.py
+++ b/Lib/test/test_nis.py
@@ -9,11 +9,7 @@
             maps = nis.maps()
         except nis.error, msg:
             # NIS is probably not active, so this test isn't useful
-            if test_support.verbose:
-                print "Test Skipped:", msg
-            # Can't raise SkipTest as regrtest only recognizes the exception
-            #   import time.
-            return
+            self.skipTest(str(msg))
         try:
             # On some systems, this map is only accessible to the
             # super user
diff -r 3a1db0d2747e Lib/test/test_ntpath.py
--- a/Lib/test/test_ntpath.py
+++ b/Lib/test/test_ntpath.py
@@ -33,10 +33,24 @@
                ('c:', '/foo/bar'))
 
     def test_splitunc(self):
+        tester('ntpath.splitunc("c:\\foo\\bar")',
+               ('', 'c:\\foo\\bar'))
+        tester('ntpath.splitunc("c:/foo/bar")',
+               ('', 'c:/foo/bar'))
         tester('ntpath.splitunc("\\\\conky\\mountpoint\\foo\\bar")',
                ('\\\\conky\\mountpoint', '\\foo\\bar'))
         tester('ntpath.splitunc("//conky/mountpoint/foo/bar")',
                ('//conky/mountpoint', '/foo/bar'))
+        tester('ntpath.splitunc("\\\\\\conky\\mountpoint\\foo\\bar")',
+               ('', '\\\\\\conky\\mountpoint\\foo\\bar'))
+        tester('ntpath.splitunc("///conky/mountpoint/foo/bar")',
+               ('', '///conky/mountpoint/foo/bar'))
+        tester('ntpath.splitunc("\\\\conky\\\\mountpoint\\foo\\bar")',
+               ('', '\\\\conky\\\\mountpoint\\foo\\bar'))
+        tester('ntpath.splitunc("//conky//mountpoint/foo/bar")',
+               ('', '//conky//mountpoint/foo/bar'))
+        self.assertEqual(ntpath.splitunc(u'//conky/MOUNTPO\u0130NT/foo/bar'),
+                         (u'//conky/MOUNTPO\u0130NT', u'/foo/bar'))
 
     def test_split(self):
         tester('ntpath.split("c:\\foo\\bar")', ('c:\\foo', 'bar'))
diff -r 3a1db0d2747e Lib/test/test_optparse.py
--- a/Lib/test/test_optparse.py
+++ b/Lib/test/test_optparse.py
@@ -1444,6 +1444,39 @@
   -h, --help         show this help message and exit
 """
 
+_expected_very_help_short_lines = """\
+Usage: bar.py [options]
+
+Options:
+  -a APPLE
+    throw
+    APPLEs at
+    basket
+  -b NUM, --boo=NUM
+    shout
+    "boo!" NUM
+    times (in
+    order to
+    frighten
+    away all
+    the evil
+    spirits
+    that cause
+    trouble and
+    mayhem)
+  --foo=FOO
+    store FOO
+    in the foo
+    list for
+    later
+    fooing
+  -h, --help
+    show this
+    help
+    message and
+    exit
+"""
+
 class TestHelp(BaseTest):
     def setUp(self):
         self.parser = self.make_parser(80)
@@ -1505,6 +1538,8 @@
         # we look at $COLUMNS.
         self.parser = self.make_parser(60)
         self.assertHelpEquals(_expected_help_short_lines)
+        self.parser = self.make_parser(0)
+        self.assertHelpEquals(_expected_very_help_short_lines)
 
     def test_help_unicode(self):
         self.parser = InterceptingOptionParser(usage=SUPPRESS_USAGE)
diff -r 3a1db0d2747e Lib/test/test_os.py
--- a/Lib/test/test_os.py
+++ b/Lib/test/test_os.py
@@ -83,9 +83,8 @@
         open(name, "w")
         self.files.append(name)
 
+    @unittest.skipUnless(hasattr(os, 'tempnam'), 'test needs os.tempnam()')
     def test_tempnam(self):
-        if not hasattr(os, "tempnam"):
-            return
         with warnings.catch_warnings():
             warnings.filterwarnings("ignore", "tempnam", RuntimeWarning,
                                     r"test_os$")
@@ -99,9 +98,8 @@
             self.assertTrue(os.path.basename(name)[:3] == "pfx")
             self.check_tempfile(name)
 
+    @unittest.skipUnless(hasattr(os, 'tmpfile'), 'test needs os.tmpfile()')
     def test_tmpfile(self):
-        if not hasattr(os, "tmpfile"):
-            return
         # As with test_tmpnam() below, the Windows implementation of tmpfile()
         # attempts to create a file in the root directory of the current drive.
         # On Vista and Server 2008, this test will always fail for normal users
@@ -150,9 +148,8 @@
             fp.close()
             self.assertTrue(s == "foobar")
 
+    @unittest.skipUnless(hasattr(os, 'tmpnam'), 'test needs os.tmpnam()')
     def test_tmpnam(self):
-        if not hasattr(os, "tmpnam"):
-            return
         with warnings.catch_warnings():
             warnings.filterwarnings("ignore", "tmpnam", RuntimeWarning,
                                     r"test_os$")
@@ -193,10 +190,8 @@
         os.unlink(self.fname)
         os.rmdir(test_support.TESTFN)
 
+    @unittest.skipUnless(hasattr(os, 'stat'), 'test needs os.stat()')
     def test_stat_attributes(self):
-        if not hasattr(os, "stat"):
-            return
-
         import stat
         result = os.stat(self.fname)
 
@@ -256,16 +251,14 @@
             pass
 
 
+    @unittest.skipUnless(hasattr(os, 'statvfs'), 'test needs os.statvfs()')
     def test_statvfs_attributes(self):
-        if not hasattr(os, "statvfs"):
-            return
-
         try:
             result = os.statvfs(self.fname)
         except OSError, e:
             # On AtheOS, glibc always returns ENOSYS
             if e.errno == errno.ENOSYS:
-                return
+                self.skipTest('glibc always returns ENOSYS on AtheOS')
 
         # Make sure direct access works
         self.assertEqual(result.f_bfree, result[3])
@@ -311,10 +304,10 @@
         st2 = os.stat(test_support.TESTFN)
         self.assertEqual(st2.st_mtime, int(st.st_mtime-delta))
 
-    # Restrict test to Win32, since there is no guarantee other
+    # Restrict tests to Win32, since there is no guarantee other
     # systems support centiseconds
-    if sys.platform == 'win32':
-        def get_file_system(path):
+    def get_file_system(path):
+        if sys.platform == 'win32':
             root = os.path.splitdrive(os.path.abspath(path))[0] + '\\'
             import ctypes
             kernel32 = ctypes.windll.kernel32
@@ -322,25 +315,31 @@
             if kernel32.GetVolumeInformationA(root, None, 0, None, None, None, buf, len(buf)):
                 return buf.value
 
-        if get_file_system(test_support.TESTFN) == "NTFS":
-            def test_1565150(self):
-                t1 = 1159195039.25
-                os.utime(self.fname, (t1, t1))
-                self.assertEqual(os.stat(self.fname).st_mtime, t1)
+    @unittest.skipUnless(sys.platform == "win32", "Win32 specific tests")
+    @unittest.skipUnless(get_file_system(test_support.TESTFN) == "NTFS",
+                         "requires NTFS")
+    def test_1565150(self):
+        t1 = 1159195039.25
+        os.utime(self.fname, (t1, t1))
+        self.assertEqual(os.stat(self.fname).st_mtime, t1)
 
-            def test_large_time(self):
-                t1 = 5000000000 # some day in 2128
-                os.utime(self.fname, (t1, t1))
-                self.assertEqual(os.stat(self.fname).st_mtime, t1)
+    @unittest.skipUnless(sys.platform == "win32", "Win32 specific tests")
+    @unittest.skipUnless(get_file_system(test_support.TESTFN) == "NTFS",
+                         "requires NTFS")
+    def test_large_time(self):
+        t1 = 5000000000 # some day in 2128
+        os.utime(self.fname, (t1, t1))
+        self.assertEqual(os.stat(self.fname).st_mtime, t1)
 
-        def test_1686475(self):
-            # Verify that an open file can be stat'ed
-            try:
-                os.stat(r"c:\pagefile.sys")
-            except WindowsError, e:
-                if e.errno == 2: # file does not exist; cannot run test
-                    return
-                self.fail("Could not stat pagefile.sys")
+    @unittest.skipUnless(sys.platform == "win32", "Win32 specific tests")
+    def test_1686475(self):
+        # Verify that an open file can be stat'ed
+        try:
+            os.stat(r"c:\pagefile.sys")
+        except WindowsError, e:
+            if e.errno == 2: # file does not exist; cannot run test
+                self.skipTest(r'c:\pagefile.sys does not exist')
+            self.fail("Could not stat pagefile.sys")
 
 from test import mapping_tests
 
@@ -598,6 +597,7 @@
         self.assertRaises(ValueError, os.execvpe, 'notepad', [], None)
 
 
+@unittest.skipUnless(sys.platform == "win32", "Win32 specific tests")
 class Win32ErrorTests(unittest.TestCase):
     def test_rename(self):
         self.assertRaises(WindowsError, os.rename, test_support.TESTFN, test_support.TESTFN+".bak")
@@ -644,121 +644,118 @@
             self.fail("%r didn't raise a OSError with a bad file descriptor"
                       % f)
 
+    @unittest.skipUnless(hasattr(os, 'isatty'), 'test needs os.isatty()')
     def test_isatty(self):
-        if hasattr(os, "isatty"):
-            self.assertEqual(os.isatty(test_support.make_bad_fd()), False)
+        self.assertEqual(os.isatty(test_support.make_bad_fd()), False)
 
+    @unittest.skipUnless(hasattr(os, 'closerange'), 'test needs os.closerange()')
     def test_closerange(self):
-        if hasattr(os, "closerange"):
-            fd = test_support.make_bad_fd()
-            # Make sure none of the descriptors we are about to close are
-            # currently valid (issue 6542).
-            for i in range(10):
-                try: os.fstat(fd+i)
-                except OSError:
-                    pass
-                else:
-                    break
-            if i < 2:
-                raise unittest.SkipTest(
-                    "Unable to acquire a range of invalid file descriptors")
-            self.assertEqual(os.closerange(fd, fd + i-1), None)
+        fd = test_support.make_bad_fd()
+        # Make sure none of the descriptors we are about to close are
+        # currently valid (issue 6542).
+        for i in range(10):
+            try: os.fstat(fd+i)
+            except OSError:
+                pass
+            else:
+                break
+        if i < 2:
+            raise unittest.SkipTest(
+                "Unable to acquire a range of invalid file descriptors")
+        self.assertEqual(os.closerange(fd, fd + i-1), None)
 
+    @unittest.skipUnless(hasattr(os, 'dup2'), 'test needs os.dup2()')
     def test_dup2(self):
-        if hasattr(os, "dup2"):
-            self.check(os.dup2, 20)
+        self.check(os.dup2, 20)
 
+    @unittest.skipUnless(hasattr(os, 'fchmod'), 'test needs os.fchmod()')
     def test_fchmod(self):
-        if hasattr(os, "fchmod"):
-            self.check(os.fchmod, 0)
+        self.check(os.fchmod, 0)
 
+    @unittest.skipUnless(hasattr(os, 'fchown'), 'test needs os.fchown()')
     def test_fchown(self):
-        if hasattr(os, "fchown"):
-            self.check(os.fchown, -1, -1)
+        self.check(os.fchown, -1, -1)
 
+    @unittest.skipUnless(hasattr(os, 'fpathconf'), 'test needs os.fpathconf()')
     def test_fpathconf(self):
-        if hasattr(os, "fpathconf"):
-            self.check(os.fpathconf, "PC_NAME_MAX")
+        self.check(os.fpathconf, "PC_NAME_MAX")
 
+    @unittest.skipUnless(hasattr(os, 'ftruncate'), 'test needs os.ftruncate()')
     def test_ftruncate(self):
-        if hasattr(os, "ftruncate"):
-            self.check(os.ftruncate, 0)
+        self.check(os.ftruncate, 0)
 
+    @unittest.skipUnless(hasattr(os, 'lseek'), 'test needs os.lseek()')
     def test_lseek(self):
-        if hasattr(os, "lseek"):
-            self.check(os.lseek, 0, 0)
+        self.check(os.lseek, 0, 0)
 
+    @unittest.skipUnless(hasattr(os, 'read'), 'test needs os.read()')
     def test_read(self):
-        if hasattr(os, "read"):
-            self.check(os.read, 1)
+        self.check(os.read, 1)
 
+    @unittest.skipUnless(hasattr(os, 'tcsetpgrp'), 'test needs os.tcsetpgrp()')
     def test_tcsetpgrpt(self):
-        if hasattr(os, "tcsetpgrp"):
-            self.check(os.tcsetpgrp, 0)
+        self.check(os.tcsetpgrp, 0)
 
+    @unittest.skipUnless(hasattr(os, 'write'), 'test needs os.write()')
     def test_write(self):
-        if hasattr(os, "write"):
-            self.check(os.write, " ")
+        self.check(os.write, " ")
 
-if sys.platform != 'win32':
-    class Win32ErrorTests(unittest.TestCase):
-        pass
+@unittest.skipIf(sys.platform == "win32", "Posix specific tests")
+class PosixUidGidTests(unittest.TestCase):
+    @unittest.skipUnless(hasattr(os, 'setuid'), 'test needs os.setuid()')
+    def test_setuid(self):
+        if os.getuid() != 0:
+            self.assertRaises(os.error, os.setuid, 0)
+        self.assertRaises(OverflowError, os.setuid, 1<<32)
 
-    class PosixUidGidTests(unittest.TestCase):
-        if hasattr(os, 'setuid'):
-            def test_setuid(self):
-                if os.getuid() != 0:
-                    self.assertRaises(os.error, os.setuid, 0)
-                self.assertRaises(OverflowError, os.setuid, 1<<32)
+    @unittest.skipUnless(hasattr(os, 'setgid'), 'test needs os.setgid()')
+    def test_setgid(self):
+        if os.getuid() != 0:
+            self.assertRaises(os.error, os.setgid, 0)
+        self.assertRaises(OverflowError, os.setgid, 1<<32)
 
-        if hasattr(os, 'setgid'):
-            def test_setgid(self):
-                if os.getuid() != 0:
-                    self.assertRaises(os.error, os.setgid, 0)
-                self.assertRaises(OverflowError, os.setgid, 1<<32)
+    @unittest.skipUnless(hasattr(os, 'seteuid'), 'test needs os.seteuid()')
+    def test_seteuid(self):
+        if os.getuid() != 0:
+            self.assertRaises(os.error, os.seteuid, 0)
+        self.assertRaises(OverflowError, os.seteuid, 1<<32)
 
-        if hasattr(os, 'seteuid'):
-            def test_seteuid(self):
-                if os.getuid() != 0:
-                    self.assertRaises(os.error, os.seteuid, 0)
-                self.assertRaises(OverflowError, os.seteuid, 1<<32)
+    @unittest.skipUnless(hasattr(os, 'setegid'), 'test needs os.setegid()')
+    def test_setegid(self):
+        if os.getuid() != 0:
+            self.assertRaises(os.error, os.setegid, 0)
+        self.assertRaises(OverflowError, os.setegid, 1<<32)
 
-        if hasattr(os, 'setegid'):
-            def test_setegid(self):
-                if os.getuid() != 0:
-                    self.assertRaises(os.error, os.setegid, 0)
-                self.assertRaises(OverflowError, os.setegid, 1<<32)
+    @unittest.skipUnless(hasattr(os, 'setreuid'), 'test needs os.setreuid()')
+    def test_setreuid(self):
+        if os.getuid() != 0:
+            self.assertRaises(os.error, os.setreuid, 0, 0)
+        self.assertRaises(OverflowError, os.setreuid, 1<<32, 0)
+        self.assertRaises(OverflowError, os.setreuid, 0, 1<<32)
 
-        if hasattr(os, 'setreuid'):
-            def test_setreuid(self):
-                if os.getuid() != 0:
-                    self.assertRaises(os.error, os.setreuid, 0, 0)
-                self.assertRaises(OverflowError, os.setreuid, 1<<32, 0)
-                self.assertRaises(OverflowError, os.setreuid, 0, 1<<32)
+    @unittest.skipUnless(hasattr(os, 'setreuid'), 'test needs os.setreuid()')
+    def test_setreuid_neg1(self):
+        # Needs to accept -1.  We run this in a subprocess to avoid
+        # altering the test runner's process state (issue8045).
+        subprocess.check_call([
+                sys.executable, '-c',
+                'import os,sys;os.setreuid(-1,-1);sys.exit(0)'])
 
-            def test_setreuid_neg1(self):
-                # Needs to accept -1.  We run this in a subprocess to avoid
-                # altering the test runner's process state (issue8045).
-                subprocess.check_call([
-                        sys.executable, '-c',
-                        'import os,sys;os.setreuid(-1,-1);sys.exit(0)'])
+    @unittest.skipUnless(hasattr(os, 'setregid'), 'test needs os.setregid()')
+    def test_setregid(self):
+        if os.getuid() != 0:
+            self.assertRaises(os.error, os.setregid, 0, 0)
+        self.assertRaises(OverflowError, os.setregid, 1<<32, 0)
+        self.assertRaises(OverflowError, os.setregid, 0, 1<<32)
 
-        if hasattr(os, 'setregid'):
-            def test_setregid(self):
-                if os.getuid() != 0:
-                    self.assertRaises(os.error, os.setregid, 0, 0)
-                self.assertRaises(OverflowError, os.setregid, 1<<32, 0)
-                self.assertRaises(OverflowError, os.setregid, 0, 1<<32)
+    @unittest.skipUnless(hasattr(os, 'setregid'), 'test needs os.setregid()')
+    def test_setregid_neg1(self):
+        # Needs to accept -1.  We run this in a subprocess to avoid
+        # altering the test runner's process state (issue8045).
+        subprocess.check_call([
+                sys.executable, '-c',
+                'import os,sys;os.setregid(-1,-1);sys.exit(0)'])
 
-            def test_setregid_neg1(self):
-                # Needs to accept -1.  We run this in a subprocess to avoid
-                # altering the test runner's process state (issue8045).
-                subprocess.check_call([
-                        sys.executable, '-c',
-                        'import os,sys;os.setregid(-1,-1);sys.exit(0)'])
-else:
-    class PosixUidGidTests(unittest.TestCase):
-        pass
 
 @unittest.skipUnless(sys.platform == "win32", "Win32 specific tests")
 class Win32KillTests(unittest.TestCase):
diff -r 3a1db0d2747e Lib/test/test_pep263.py
--- a/Lib/test/test_pep263.py
+++ b/Lib/test/test_pep263.py
@@ -58,6 +58,11 @@
         with self.assertRaisesRegexp(SyntaxError, 'BOM'):
             compile('\xef\xbb\xbf# -*- coding: fake -*-\n', 'dummy', 'exec')
 
+    def test_non_unicode_codec(self):
+        with self.assertRaisesRegexp(SyntaxError,
+                                     'codec did not return a unicode'):
+            from test import bad_coding3
+
 
 def test_main():
     test_support.run_unittest(PEP263Test)
diff -r 3a1db0d2747e Lib/test/test_pkgutil.py
--- a/Lib/test/test_pkgutil.py
+++ b/Lib/test/test_pkgutil.py
@@ -133,9 +133,7 @@
 
 def test_main():
     run_unittest(PkgutilTests, PkgutilPEP302Tests)
-    # this is necessary if test is run repeated (like when finding leaks)
-    import zipimport
-    zipimport._zip_directory_cache.clear()
+
 
 if __name__ == '__main__':
     test_main()
diff -r 3a1db0d2747e Lib/test/test_poll.py
--- a/Lib/test/test_poll.py
+++ b/Lib/test/test_poll.py
@@ -3,7 +3,7 @@
 import os
 import random
 import select
-import _testcapi
+from _testcapi import USHRT_MAX, INT_MAX, UINT_MAX
 try:
     import threading
 except ImportError:
@@ -159,14 +159,13 @@
         if x != 5:
             self.fail('Overflow must have occurred')
 
-        pollster = select.poll()
-        # Issue 15989
-        self.assertRaises(OverflowError, pollster.register, 0,
-                          _testcapi.SHRT_MAX + 1)
-        self.assertRaises(OverflowError, pollster.register, 0,
-                          _testcapi.USHRT_MAX + 1)
-        self.assertRaises(OverflowError, pollster.poll, _testcapi.INT_MAX + 1)
-        self.assertRaises(OverflowError, pollster.poll, _testcapi.UINT_MAX + 1)
+        # Issues #15989, #17919
+        self.assertRaises(OverflowError, pollster.register, 0, -1)
+        self.assertRaises(OverflowError, pollster.register, 0, USHRT_MAX + 1)
+        self.assertRaises(OverflowError, pollster.modify, 1, -1)
+        self.assertRaises(OverflowError, pollster.modify, 1, USHRT_MAX + 1)
+        self.assertRaises(OverflowError, pollster.poll, INT_MAX + 1)
+        self.assertRaises(OverflowError, pollster.poll, UINT_MAX + 1)
 
     @unittest.skipUnless(threading, 'Threading required for this test.')
     @reap_threads
diff -r 3a1db0d2747e Lib/test/test_poplib.py
--- a/Lib/test/test_poplib.py
+++ b/Lib/test/test_poplib.py
@@ -11,7 +11,7 @@
 import time
 import errno
 
-from unittest import TestCase
+from unittest import TestCase, skipUnless
 from test import test_support
 from test.test_support import HOST
 threading = test_support.import_module('threading')
@@ -263,17 +263,20 @@
             else:
                 DummyPOP3Handler.handle_read(self)
 
-    class TestPOP3_SSLClass(TestPOP3Class):
-        # repeat previous tests by using poplib.POP3_SSL
+requires_ssl = skipUnless(SUPPORTS_SSL, 'SSL not supported')
 
-        def setUp(self):
-            self.server = DummyPOP3Server((HOST, 0))
-            self.server.handler = DummyPOP3_SSLHandler
-            self.server.start()
-            self.client = poplib.POP3_SSL(self.server.host, self.server.port)
+@requires_ssl
+class TestPOP3_SSLClass(TestPOP3Class):
+    # repeat previous tests by using poplib.POP3_SSL
 
-        def test__all__(self):
-            self.assertIn('POP3_SSL', poplib.__all__)
+    def setUp(self):
+        self.server = DummyPOP3Server((HOST, 0))
+        self.server.handler = DummyPOP3_SSLHandler
+        self.server.start()
+        self.client = poplib.POP3_SSL(self.server.host, self.server.port)
+
+    def test__all__(self):
+        self.assertIn('POP3_SSL', poplib.__all__)
 
 
 class TestTimeouts(TestCase):
@@ -331,9 +334,8 @@
 
 
 def test_main():
-    tests = [TestPOP3Class, TestTimeouts]
-    if SUPPORTS_SSL:
-        tests.append(TestPOP3_SSLClass)
+    tests = [TestPOP3Class, TestTimeouts,
+             TestPOP3_SSLClass]
     thread_info = test_support.threading_setup()
     try:
         test_support.run_unittest(*tests)
diff -r 3a1db0d2747e Lib/test/test_posix.py
--- a/Lib/test/test_posix.py
+++ b/Lib/test/test_posix.py
@@ -53,47 +53,55 @@
                     posix_func()
                     self.assertRaises(TypeError, posix_func, 1)
 
-    if hasattr(posix, 'getresuid'):
-        def test_getresuid(self):
-            user_ids = posix.getresuid()
-            self.assertEqual(len(user_ids), 3)
-            for val in user_ids:
-                self.assertGreaterEqual(val, 0)
+    @unittest.skipUnless(hasattr(posix, 'getresuid'),
+                         'test needs posix.getresuid()')
+    def test_getresuid(self):
+        user_ids = posix.getresuid()
+        self.assertEqual(len(user_ids), 3)
+        for val in user_ids:
+            self.assertGreaterEqual(val, 0)
 
-    if hasattr(posix, 'getresgid'):
-        def test_getresgid(self):
-            group_ids = posix.getresgid()
-            self.assertEqual(len(group_ids), 3)
-            for val in group_ids:
-                self.assertGreaterEqual(val, 0)
+    @unittest.skipUnless(hasattr(posix, 'getresgid'),
+                         'test needs posix.getresgid()')
+    def test_getresgid(self):
+        group_ids = posix.getresgid()
+        self.assertEqual(len(group_ids), 3)
+        for val in group_ids:
+            self.assertGreaterEqual(val, 0)
 
-    if hasattr(posix, 'setresuid'):
-        def test_setresuid(self):
-            current_user_ids = posix.getresuid()
-            self.assertIsNone(posix.setresuid(*current_user_ids))
-            # -1 means don't change that value.
-            self.assertIsNone(posix.setresuid(-1, -1, -1))
+    @unittest.skipUnless(hasattr(posix, 'setresuid'),
+                         'test needs posix.setresuid()')
+    def test_setresuid(self):
+        current_user_ids = posix.getresuid()
+        self.assertIsNone(posix.setresuid(*current_user_ids))
+        # -1 means don't change that value.
+        self.assertIsNone(posix.setresuid(-1, -1, -1))
 
-        def test_setresuid_exception(self):
-            # Don't do this test if someone is silly enough to run us as root.
-            current_user_ids = posix.getresuid()
-            if 0 not in current_user_ids:
-                new_user_ids = (current_user_ids[0]+1, -1, -1)
-                self.assertRaises(OSError, posix.setresuid, *new_user_ids)
+    @unittest.skipUnless(hasattr(posix, 'setresuid'),
+                         'test needs posix.setresuid()')
+    def test_setresuid_exception(self):
+        # Don't do this test if someone is silly enough to run us as root.
+        current_user_ids = posix.getresuid()
+        if 0 not in current_user_ids:
+            new_user_ids = (current_user_ids[0]+1, -1, -1)
+            self.assertRaises(OSError, posix.setresuid, *new_user_ids)
 
-    if hasattr(posix, 'setresgid'):
-        def test_setresgid(self):
-            current_group_ids = posix.getresgid()
-            self.assertIsNone(posix.setresgid(*current_group_ids))
-            # -1 means don't change that value.
-            self.assertIsNone(posix.setresgid(-1, -1, -1))
+    @unittest.skipUnless(hasattr(posix, 'setresgid'),
+                         'test needs posix.setresgid()')
+    def test_setresgid(self):
+        current_group_ids = posix.getresgid()
+        self.assertIsNone(posix.setresgid(*current_group_ids))
+        # -1 means don't change that value.
+        self.assertIsNone(posix.setresgid(-1, -1, -1))
 
-        def test_setresgid_exception(self):
-            # Don't do this test if someone is silly enough to run us as root.
-            current_group_ids = posix.getresgid()
-            if 0 not in current_group_ids:
-                new_group_ids = (current_group_ids[0]+1, -1, -1)
-                self.assertRaises(OSError, posix.setresgid, *new_group_ids)
+    @unittest.skipUnless(hasattr(posix, 'setresgid'),
+                         'test needs posix.setresgid()')
+    def test_setresgid_exception(self):
+        # Don't do this test if someone is silly enough to run us as root.
+        current_group_ids = posix.getresgid()
+        if 0 not in current_group_ids:
+            new_group_ids = (current_group_ids[0]+1, -1, -1)
+            self.assertRaises(OSError, posix.setresgid, *new_group_ids)
 
     @unittest.skipUnless(hasattr(posix, 'initgroups'),
                          "test needs os.initgroups()")
@@ -120,107 +128,118 @@
             else:
                 self.fail("Expected OSError to be raised by initgroups")
 
+    @unittest.skipUnless(hasattr(posix, 'statvfs'),
+                         'test needs posix.statvfs()')
     def test_statvfs(self):
-        if hasattr(posix, 'statvfs'):
-            self.assertTrue(posix.statvfs(os.curdir))
+        self.assertTrue(posix.statvfs(os.curdir))
 
+    @unittest.skipUnless(hasattr(posix, 'fstatvfs'),
+                         'test needs posix.fstatvfs()')
     def test_fstatvfs(self):
-        if hasattr(posix, 'fstatvfs'):
-            fp = open(test_support.TESTFN)
-            try:
-                self.assertTrue(posix.fstatvfs(fp.fileno()))
-            finally:
-                fp.close()
+        fp = open(test_support.TESTFN)
+        try:
+            self.assertTrue(posix.fstatvfs(fp.fileno()))
+        finally:
+            fp.close()
 
+    @unittest.skipUnless(hasattr(posix, 'ftruncate'),
+                         'test needs posix.ftruncate()')
     def test_ftruncate(self):
-        if hasattr(posix, 'ftruncate'):
-            fp = open(test_support.TESTFN, 'w+')
-            try:
-                # we need to have some data to truncate
-                fp.write('test')
-                fp.flush()
-                posix.ftruncate(fp.fileno(), 0)
-            finally:
-                fp.close()
+        fp = open(test_support.TESTFN, 'w+')
+        try:
+            # we need to have some data to truncate
+            fp.write('test')
+            fp.flush()
+            posix.ftruncate(fp.fileno(), 0)
+        finally:
+            fp.close()
 
+    @unittest.skipUnless(hasattr(posix, 'dup'),
+                         'test needs posix.dup()')
     def test_dup(self):
-        if hasattr(posix, 'dup'):
-            fp = open(test_support.TESTFN)
-            try:
-                fd = posix.dup(fp.fileno())
-                self.assertIsInstance(fd, int)
-                os.close(fd)
-            finally:
-                fp.close()
+        fp = open(test_support.TESTFN)
+        try:
+            fd = posix.dup(fp.fileno())
+            self.assertIsInstance(fd, int)
+            os.close(fd)
+        finally:
+            fp.close()
 
+    @unittest.skipUnless(hasattr(posix, 'confstr'),
+                         'test needs posix.confstr()')
     def test_confstr(self):
-        if hasattr(posix, 'confstr'):
-            self.assertRaises(ValueError, posix.confstr, "CS_garbage")
-            self.assertEqual(len(posix.confstr("CS_PATH")) > 0, True)
+        self.assertRaises(ValueError, posix.confstr, "CS_garbage")
+        self.assertEqual(len(posix.confstr("CS_PATH")) > 0, True)
 
+    @unittest.skipUnless(hasattr(posix, 'dup2'),
+                         'test needs posix.dup2()')
     def test_dup2(self):
-        if hasattr(posix, 'dup2'):
-            fp1 = open(test_support.TESTFN)
-            fp2 = open(test_support.TESTFN)
-            try:
-                posix.dup2(fp1.fileno(), fp2.fileno())
-            finally:
-                fp1.close()
-                fp2.close()
+        fp1 = open(test_support.TESTFN)
+        fp2 = open(test_support.TESTFN)
+        try:
+            posix.dup2(fp1.fileno(), fp2.fileno())
+        finally:
+            fp1.close()
+            fp2.close()
 
     def fdopen_helper(self, *args):
         fd = os.open(test_support.TESTFN, os.O_RDONLY)
         fp2 = posix.fdopen(fd, *args)
         fp2.close()
 
+    @unittest.skipUnless(hasattr(posix, 'fdopen'),
+                         'test needs posix.fdopen()')
     def test_fdopen(self):
-        if hasattr(posix, 'fdopen'):
-            self.fdopen_helper()
-            self.fdopen_helper('r')
-            self.fdopen_helper('r', 100)
+        self.fdopen_helper()
+        self.fdopen_helper('r')
+        self.fdopen_helper('r', 100)
 
+    @unittest.skipUnless(hasattr(posix, 'O_EXLOCK'),
+                         'test needs posix.O_EXLOCK')
     def test_osexlock(self):
-        if hasattr(posix, "O_EXLOCK"):
+        fd = os.open(test_support.TESTFN,
+                     os.O_WRONLY|os.O_EXLOCK|os.O_CREAT)
+        self.assertRaises(OSError, os.open, test_support.TESTFN,
+                          os.O_WRONLY|os.O_EXLOCK|os.O_NONBLOCK)
+        os.close(fd)
+
+        if hasattr(posix, "O_SHLOCK"):
             fd = os.open(test_support.TESTFN,
-                         os.O_WRONLY|os.O_EXLOCK|os.O_CREAT)
+                         os.O_WRONLY|os.O_SHLOCK|os.O_CREAT)
             self.assertRaises(OSError, os.open, test_support.TESTFN,
                               os.O_WRONLY|os.O_EXLOCK|os.O_NONBLOCK)
             os.close(fd)
 
-            if hasattr(posix, "O_SHLOCK"):
-                fd = os.open(test_support.TESTFN,
-                             os.O_WRONLY|os.O_SHLOCK|os.O_CREAT)
-                self.assertRaises(OSError, os.open, test_support.TESTFN,
-                                  os.O_WRONLY|os.O_EXLOCK|os.O_NONBLOCK)
-                os.close(fd)
+    @unittest.skipUnless(hasattr(posix, 'O_SHLOCK'),
+                         'test needs posix.O_SHLOCK')
+    def test_osshlock(self):
+        fd1 = os.open(test_support.TESTFN,
+                      os.O_WRONLY|os.O_SHLOCK|os.O_CREAT)
+        fd2 = os.open(test_support.TESTFN,
+                      os.O_WRONLY|os.O_SHLOCK|os.O_CREAT)
+        os.close(fd2)
+        os.close(fd1)
 
-    def test_osshlock(self):
-        if hasattr(posix, "O_SHLOCK"):
-            fd1 = os.open(test_support.TESTFN,
+        if hasattr(posix, "O_EXLOCK"):
+            fd = os.open(test_support.TESTFN,
                          os.O_WRONLY|os.O_SHLOCK|os.O_CREAT)
-            fd2 = os.open(test_support.TESTFN,
-                          os.O_WRONLY|os.O_SHLOCK|os.O_CREAT)
-            os.close(fd2)
-            os.close(fd1)
+            self.assertRaises(OSError, os.open, test_support.TESTFN,
+                              os.O_RDONLY|os.O_EXLOCK|os.O_NONBLOCK)
+            os.close(fd)
 
-            if hasattr(posix, "O_EXLOCK"):
-                fd = os.open(test_support.TESTFN,
-                             os.O_WRONLY|os.O_SHLOCK|os.O_CREAT)
-                self.assertRaises(OSError, os.open, test_support.TESTFN,
-                                  os.O_RDONLY|os.O_EXLOCK|os.O_NONBLOCK)
-                os.close(fd)
+    @unittest.skipUnless(hasattr(posix, 'fstat'),
+                         'test needs posix.fstat()')
+    def test_fstat(self):
+        fp = open(test_support.TESTFN)
+        try:
+            self.assertTrue(posix.fstat(fp.fileno()))
+        finally:
+            fp.close()
 
-    def test_fstat(self):
-        if hasattr(posix, 'fstat'):
-            fp = open(test_support.TESTFN)
-            try:
-                self.assertTrue(posix.fstat(fp.fileno()))
-            finally:
-                fp.close()
-
+    @unittest.skipUnless(hasattr(posix, 'stat'),
+                         'test needs posix.stat()')
     def test_stat(self):
-        if hasattr(posix, 'stat'):
-            self.assertTrue(posix.stat(test_support.TESTFN))
+        self.assertTrue(posix.stat(test_support.TESTFN))
 
     def _test_all_chown_common(self, chown_func, first_param, stat_func):
         """Common code for chown, fchown and lchown tests."""
@@ -313,59 +332,62 @@
         self._test_all_chown_common(posix.lchown, test_support.TESTFN,
                                     getattr(posix, 'lstat', None))
 
+    @unittest.skipUnless(hasattr(posix, 'chdir'), 'test needs posix.chdir()')
     def test_chdir(self):
-        if hasattr(posix, 'chdir'):
-            posix.chdir(os.curdir)
-            self.assertRaises(OSError, posix.chdir, test_support.TESTFN)
+        posix.chdir(os.curdir)
+        self.assertRaises(OSError, posix.chdir, test_support.TESTFN)
 
+    @unittest.skipUnless(hasattr(posix, 'lsdir'), 'test needs posix.lsdir()')
     def test_lsdir(self):
-        if hasattr(posix, 'lsdir'):
-            self.assertIn(test_support.TESTFN, posix.lsdir(os.curdir))
+        self.assertIn(test_support.TESTFN, posix.lsdir(os.curdir))
 
+    @unittest.skipUnless(hasattr(posix, 'access'), 'test needs posix.access()')
     def test_access(self):
-        if hasattr(posix, 'access'):
-            self.assertTrue(posix.access(test_support.TESTFN, os.R_OK))
+        self.assertTrue(posix.access(test_support.TESTFN, os.R_OK))
 
+    @unittest.skipUnless(hasattr(posix, 'umask'), 'test needs posix.umask()')
     def test_umask(self):
-        if hasattr(posix, 'umask'):
-            old_mask = posix.umask(0)
-            self.assertIsInstance(old_mask, int)
-            posix.umask(old_mask)
+        old_mask = posix.umask(0)
+        self.assertIsInstance(old_mask, int)
+        posix.umask(old_mask)
 
+    @unittest.skipUnless(hasattr(posix, 'strerror'),
+                         'test needs posix.strerror()')
     def test_strerror(self):
-        if hasattr(posix, 'strerror'):
-            self.assertTrue(posix.strerror(0))
+        self.assertTrue(posix.strerror(0))
 
+    @unittest.skipUnless(hasattr(posix, 'pipe'), 'test needs posix.pipe()')
     def test_pipe(self):
-        if hasattr(posix, 'pipe'):
-            reader, writer = posix.pipe()
-            os.close(reader)
-            os.close(writer)
+        reader, writer = posix.pipe()
+        os.close(reader)
+        os.close(writer)
 
+    @unittest.skipUnless(hasattr(posix, 'tempnam'),
+                         'test needs posix.tempnam()')
     def test_tempnam(self):
-        if hasattr(posix, 'tempnam'):
-            with warnings.catch_warnings():
-                warnings.filterwarnings("ignore", "tempnam", DeprecationWarning)
-                self.assertTrue(posix.tempnam())
-                self.assertTrue(posix.tempnam(os.curdir))
-                self.assertTrue(posix.tempnam(os.curdir, 'blah'))
+        with warnings.catch_warnings():
+            warnings.filterwarnings("ignore", "tempnam", DeprecationWarning)
+            self.assertTrue(posix.tempnam())
+            self.assertTrue(posix.tempnam(os.curdir))
+            self.assertTrue(posix.tempnam(os.curdir, 'blah'))
 
+    @unittest.skipUnless(hasattr(posix, 'tmpfile'),
+                         'test needs posix.tmpfile()')
     def test_tmpfile(self):
-        if hasattr(posix, 'tmpfile'):
-            with warnings.catch_warnings():
-                warnings.filterwarnings("ignore", "tmpfile", DeprecationWarning)
-                fp = posix.tmpfile()
-                fp.close()
+        with warnings.catch_warnings():
+            warnings.filterwarnings("ignore", "tmpfile", DeprecationWarning)
+            fp = posix.tmpfile()
+            fp.close()
 
+    @unittest.skipUnless(hasattr(posix, 'utime'), 'test needs posix.utime()')
     def test_utime(self):
-        if hasattr(posix, 'utime'):
-            now = time.time()
-            posix.utime(test_support.TESTFN, None)
-            self.assertRaises(TypeError, posix.utime, test_support.TESTFN, (None, None))
-            self.assertRaises(TypeError, posix.utime, test_support.TESTFN, (now, None))
-            self.assertRaises(TypeError, posix.utime, test_support.TESTFN, (None, now))
-            posix.utime(test_support.TESTFN, (int(now), int(now)))
-            posix.utime(test_support.TESTFN, (now, now))
+        now = time.time()
+        posix.utime(test_support.TESTFN, None)
+        self.assertRaises(TypeError, posix.utime, test_support.TESTFN, (None, None))
+        self.assertRaises(TypeError, posix.utime, test_support.TESTFN, (now, None))
+        self.assertRaises(TypeError, posix.utime, test_support.TESTFN, (None, now))
+        posix.utime(test_support.TESTFN, (int(now), int(now)))
+        posix.utime(test_support.TESTFN, (now, now))
 
     def _test_chflags_regular_file(self, chflags_func, target_file):
         st = os.stat(target_file)
@@ -428,56 +450,54 @@
         finally:
             posix.lchflags(_DUMMY_SYMLINK, dummy_symlink_st.st_flags)
 
+    @unittest.skipUnless(hasattr(posix, 'getcwd'),
+                         'test needs posix.getcwd()')
     def test_getcwd_long_pathnames(self):
-        if hasattr(posix, 'getcwd'):
-            dirname = 'getcwd-test-directory-0123456789abcdef-01234567890abcdef'
-            curdir = os.getcwd()
-            base_path = os.path.abspath(test_support.TESTFN) + '.getcwd'
+        dirname = 'getcwd-test-directory-0123456789abcdef-01234567890abcdef'
+        curdir = os.getcwd()
+        base_path = os.path.abspath(test_support.TESTFN) + '.getcwd'
 
-            try:
-                os.mkdir(base_path)
-                os.chdir(base_path)
-            except:
-#               Just returning nothing instead of the SkipTest exception,
-#               because the test results in Error in that case.
-#               Is that ok?
-#                raise unittest.SkipTest, "cannot create directory for testing"
-                return
+        try:
+            os.mkdir(base_path)
+            os.chdir(base_path)
+        except:
+            self.skipTest("cannot create directory for testing")
 
-            try:
-                def _create_and_do_getcwd(dirname, current_path_length = 0):
-                    try:
-                        os.mkdir(dirname)
-                    except:
-                        raise unittest.SkipTest, "mkdir cannot create directory sufficiently deep for getcwd test"
+        try:
+            def _create_and_do_getcwd(dirname, current_path_length = 0):
+                try:
+                    os.mkdir(dirname)
+                except:
+                    self.skipTest("mkdir cannot create directory sufficiently "
+                                  "deep for getcwd test")
 
-                    os.chdir(dirname)
-                    try:
-                        os.getcwd()
-                        if current_path_length < 4099:
-                            _create_and_do_getcwd(dirname, current_path_length + len(dirname) + 1)
-                    except OSError as e:
-                        expected_errno = errno.ENAMETOOLONG
-                        # The following platforms have quirky getcwd()
-                        # behaviour -- see issue 9185 and 15765 for
-                        # more information.
-                        quirky_platform = (
-                            'sunos' in sys.platform or
-                            'netbsd' in sys.platform or
-                            'openbsd' in sys.platform
-                        )
-                        if quirky_platform:
-                            expected_errno = errno.ERANGE
-                        self.assertEqual(e.errno, expected_errno)
-                    finally:
-                        os.chdir('..')
-                        os.rmdir(dirname)
+                os.chdir(dirname)
+                try:
+                    os.getcwd()
+                    if current_path_length < 4099:
+                        _create_and_do_getcwd(dirname, current_path_length + len(dirname) + 1)
+                except OSError as e:
+                    expected_errno = errno.ENAMETOOLONG
+                    # The following platforms have quirky getcwd()
+                    # behaviour -- see issue 9185 and 15765 for
+                    # more information.
+                    quirky_platform = (
+                        'sunos' in sys.platform or
+                        'netbsd' in sys.platform or
+                        'openbsd' in sys.platform
+                    )
+                    if quirky_platform:
+                        expected_errno = errno.ERANGE
+                    self.assertEqual(e.errno, expected_errno)
+                finally:
+                    os.chdir('..')
+                    os.rmdir(dirname)
 
-                _create_and_do_getcwd(dirname)
+            _create_and_do_getcwd(dirname)
 
-            finally:
-                os.chdir(curdir)
-                shutil.rmtree(base_path)
+        finally:
+            os.chdir(curdir)
+            shutil.rmtree(base_path)
 
     @unittest.skipUnless(hasattr(os, 'getegid'), "test needs os.getegid()")
     def test_getgroups(self):
@@ -522,7 +542,7 @@
             posix.initgroups(name, self.saved_groups[0])
 
     @unittest.skipUnless(hasattr(posix, 'initgroups'),
-                         "test needs posix.initgroups()")
+                         'test needs posix.initgroups()')
     def test_initgroups(self):
         # find missing group
 
@@ -532,7 +552,7 @@
         self.assertIn(g, posix.getgroups())
 
     @unittest.skipUnless(hasattr(posix, 'setgroups'),
-                         "test needs posix.setgroups()")
+                         'test needs posix.setgroups()')
     def test_setgroups(self):
         for groups in [[0], range(16)]:
             posix.setgroups(groups)
diff -r 3a1db0d2747e Lib/test/test_pwd.py
--- a/Lib/test/test_pwd.py
+++ b/Lib/test/test_pwd.py
@@ -8,8 +8,6 @@
 
     def test_values(self):
         entries = pwd.getpwall()
-        entriesbyname = {}
-        entriesbyuid = {}
 
         for e in entries:
             self.assertEqual(len(e), 7)
@@ -32,13 +30,20 @@
             # for one uid
             #    self.assertEqual(pwd.getpwuid(e.pw_uid), e)
             # instead of this collect all entries for one uid
-            # and check afterwards
+            # and check afterwards (done in test_values_extended)
+
+    def test_values_extended(self):
+        entries = pwd.getpwall()
+        entriesbyname = {}
+        entriesbyuid = {}
+
+        if len(entries) > 1000:  # Huge passwd file (NIS?) -- skip this test
+            self.skipTest('passwd file is huge; extended test skipped')
+
+        for e in entries:
             entriesbyname.setdefault(e.pw_name, []).append(e)
             entriesbyuid.setdefault(e.pw_uid, []).append(e)
 
-        if len(entries) > 1000:  # Huge passwd file (NIS?) -- skip the rest
-            return
-
         # check whether the entry returned by getpwuid()
         # for each uid is among those from getpwall() for this uid
         for e in entries:
diff -r 3a1db0d2747e Lib/test/test_pydoc.py
--- a/Lib/test/test_pydoc.py
+++ b/Lib/test/test_pydoc.py
@@ -10,6 +10,7 @@
 import pkgutil
 import unittest
 import xml.etree
+import types
 import test.test_support
 from collections import namedtuple
 from test.script_helper import assert_python_ok
@@ -421,13 +422,103 @@
     def test_namedtuple_public_underscore(self):
         NT = namedtuple('NT', ['abc', 'def'], rename=True)
         with captured_stdout() as help_io:
-            help(NT)
+            pydoc.help(NT)
         helptext = help_io.getvalue()
         self.assertIn('_1', helptext)
         self.assertIn('_replace', helptext)
         self.assertIn('_asdict', helptext)
 
 
+@unittest.skipUnless(test.test_support.have_unicode,
+                     "test requires unicode support")
+class TestUnicode(unittest.TestCase):
+
+    def setUp(self):
+        # Better not to use unicode escapes in literals, lest the
+        # parser choke on it if Python has been built without
+        # unicode support.
+        self.Q  = types.ModuleType(
+            'Q', 'Rational numbers: \xe2\x84\x9a'.decode('utf8'))
+        self.Q.__version__ = '\xe2\x84\x9a'.decode('utf8')
+        self.Q.__date__ = '\xe2\x84\x9a'.decode('utf8')
+        self.Q.__author__ = '\xe2\x84\x9a'.decode('utf8')
+        self.Q.__credits__ = '\xe2\x84\x9a'.decode('utf8')
+
+        self.assertIsInstance(self.Q.__doc__, unicode)
+
+    def test_render_doc(self):
+        # render_doc is robust against unicode in docstrings
+        doc = pydoc.render_doc(self.Q)
+        self.assertIsInstance(doc, str)
+
+    def test_encode(self):
+        # _encode is robust against characters out the specified encoding
+        self.assertEqual(pydoc._encode(self.Q.__doc__, 'ascii'), 'Rational numbers: &#8474;')
+
+    def test_pipepager(self):
+        # pipepager does not choke on unicode
+        doc = pydoc.render_doc(self.Q)
+
+        saved, os.popen = os.popen, open
+        try:
+            with test.test_support.temp_cwd():
+                pydoc.pipepager(doc, 'pipe')
+                self.assertEqual(open('pipe').read(), pydoc._encode(doc))
+        finally:
+            os.popen = saved
+
+    def test_tempfilepager(self):
+        # tempfilepager does not choke on unicode
+        doc = pydoc.render_doc(self.Q)
+
+        output = {}
+        def mock_system(cmd):
+            filename = cmd.strip()[1:-1]
+            self.assertEqual('"' + filename + '"', cmd.strip())
+            output['content'] = open(filename).read()
+        saved, os.system = os.system, mock_system
+        try:
+            pydoc.tempfilepager(doc, '')
+            self.assertEqual(output['content'], pydoc._encode(doc))
+        finally:
+            os.system = saved
+
+    def test_plainpager(self):
+        # plainpager does not choke on unicode
+        doc = pydoc.render_doc(self.Q)
+
+        # Note: captured_stdout is too permissive when it comes to
+        # unicode, and using it here would make the test always
+        # pass.
+        with test.test_support.temp_cwd():
+            with open('output', 'w') as f:
+                saved, sys.stdout = sys.stdout, f
+                try:
+                    pydoc.plainpager(doc)
+                finally:
+                    sys.stdout = saved
+            self.assertIn('Rational numbers:', open('output').read())
+
+    def test_ttypager(self):
+        # ttypager does not choke on unicode
+        doc = pydoc.render_doc(self.Q)
+        # Test ttypager
+        with test.test_support.temp_cwd(), test.test_support.captured_stdin():
+            with open('output', 'w') as f:
+                saved, sys.stdout = sys.stdout, f
+                try:
+                    pydoc.ttypager(doc)
+                finally:
+                    sys.stdout = saved
+            self.assertIn('Rational numbers:', open('output').read())
+
+    def test_htmlpage(self):
+        # html.page does not choke on unicode
+        with test.test_support.temp_cwd():
+            with captured_stdout() as output:
+                pydoc.writedoc(self.Q)
+        self.assertEqual(output.getvalue(), 'wrote Q.html\n')
+
 class TestHelper(unittest.TestCase):
     def test_keywords(self):
         self.assertEqual(sorted(pydoc.Helper.keywords),
@@ -456,6 +547,7 @@
         test.test_support.run_unittest(PydocDocTest,
                                        PydocImportTest,
                                        TestDescriptions,
+                                       TestUnicode,
                                        TestHelper)
     finally:
         reap_children()
diff -r 3a1db0d2747e Lib/test/test_random.py
--- a/Lib/test/test_random.py
+++ b/Lib/test/test_random.py
@@ -251,10 +251,10 @@
 
     def test_bigrand_ranges(self):
         for i in [40,80, 160, 200, 211, 250, 375, 512, 550]:
-            start = self.gen.randrange(2 ** i)
-            stop = self.gen.randrange(2 ** (i-2))
+            start = self.gen.randrange(2 ** (i-2))
+            stop = self.gen.randrange(2 ** i)
             if stop <= start:
-                return
+                continue
             self.assertTrue(start <= self.gen.randrange(start, stop) < stop)
 
     def test_rangelimits(self):
@@ -403,10 +403,10 @@
 
     def test_bigrand_ranges(self):
         for i in [40,80, 160, 200, 211, 250, 375, 512, 550]:
-            start = self.gen.randrange(2 ** i)
-            stop = self.gen.randrange(2 ** (i-2))
+            start = self.gen.randrange(2 ** (i-2))
+            stop = self.gen.randrange(2 ** i)
             if stop <= start:
-                return
+                continue
             self.assertTrue(start <= self.gen.randrange(start, stop) < stop)
 
     def test_rangelimits(self):
diff -r 3a1db0d2747e Lib/test/test_re.py
--- a/Lib/test/test_re.py
+++ b/Lib/test/test_re.py
@@ -700,7 +700,7 @@
         try:
             unicode
         except NameError:
-            return  # no problem if we have no unicode
+            self.skipTest('no problem if we have no unicode')
         class my_unicode(unicode): pass
         pat = re.compile(my_unicode("abc"))
         self.assertEqual(pat.match("xyz"), None)
@@ -714,7 +714,7 @@
         try:
             unicode
         except NameError:
-            return # no problem if we have no unicode
+            self.skipTest('no problem if we have no unicode')
         self.assertTrue(re.compile('bug_926075') is not
                      re.compile(eval("u'bug_926075'")))
 
@@ -722,7 +722,7 @@
         try:
             unicode
         except NameError:
-            pass
+            self.skipTest('no problem if we have no unicode')
         pattern = eval('u"[\u002E\u3002\uFF0E\uFF61]"')
         self.assertEqual(re.compile(pattern).split("a.b.c"),
                          ['a','b','c'])
diff -r 3a1db0d2747e Lib/test/test_repr.py
--- a/Lib/test/test_repr.py
+++ b/Lib/test/test_repr.py
@@ -179,8 +179,15 @@
         self.assertTrue(repr(x).startswith('<read-only buffer for 0x'))
 
     def test_cell(self):
-        # XXX Hmm? How to get at a cell object?
-        pass
+        def get_cell():
+            x = 42
+            def inner():
+                return x
+            return inner
+        x = get_cell().__closure__[0]
+        self.assertRegexpMatches(repr(x), r'<cell at 0x[0-9A-Fa-f]+: '
+                                          r'int object at 0x[0-9A-Fa-f]+>')
+        self.assertRegexpMatches(r(x), r'<cell at.*\.\.\..*>')
 
     def test_descriptors(self):
         eq = self.assertEqual
@@ -261,6 +268,7 @@
         eq(repr(foo.foo),
                "<class '%s.foo'>" % foo.__name__)
 
+    @unittest.skip('need a suitable object')
     def test_object(self):
         # XXX Test the repr of a type with a really long tp_name but with no
         # tp_repr.  WIBNI we had ::Inline? :)
@@ -302,6 +310,7 @@
             '<bound method aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.amethod of <%s.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa instance at 0x' \
             % (qux.__name__,) ))
 
+    @unittest.skip('needs a built-in function with a really long name')
     def test_builtin_function(self):
         # XXX test built-in functions and methods with really long names
         pass
diff -r 3a1db0d2747e Lib/test/test_resource.py
--- a/Lib/test/test_resource.py
+++ b/Lib/test/test_resource.py
@@ -18,62 +18,60 @@
         try:
             (cur, max) = resource.getrlimit(resource.RLIMIT_FSIZE)
         except AttributeError:
-            pass
-        else:
-            # RLIMIT_FSIZE should be RLIM_INFINITY, which will be a really big
-            # number on a platform with large file support.  On these platforms,
-            # we need to test that the get/setrlimit functions properly convert
-            # the number to a C long long and that the conversion doesn't raise
-            # an error.
-            self.assertEqual(resource.RLIM_INFINITY, max)
-            resource.setrlimit(resource.RLIMIT_FSIZE, (cur, max))
+            self.skipTest('RLIMIT_FSIZE not available')
+        # RLIMIT_FSIZE should be RLIM_INFINITY, which will be a really big
+        # number on a platform with large file support.  On these platforms,
+        # we need to test that the get/setrlimit functions properly convert
+        # the number to a C long long and that the conversion doesn't raise
+        # an error.
+        self.assertEqual(resource.RLIM_INFINITY, max)
+        resource.setrlimit(resource.RLIMIT_FSIZE, (cur, max))
 
     def test_fsize_enforced(self):
         try:
             (cur, max) = resource.getrlimit(resource.RLIMIT_FSIZE)
         except AttributeError:
-            pass
-        else:
-            # Check to see what happens when the RLIMIT_FSIZE is small.  Some
-            # versions of Python were terminated by an uncaught SIGXFSZ, but
-            # pythonrun.c has been fixed to ignore that exception.  If so, the
-            # write() should return EFBIG when the limit is exceeded.
+            self.skipTest('RLIMIT_FSIZE not available')
+        # Check to see what happens when the RLIMIT_FSIZE is small.  Some
+        # versions of Python were terminated by an uncaught SIGXFSZ, but
+        # pythonrun.c has been fixed to ignore that exception.  If so, the
+        # write() should return EFBIG when the limit is exceeded.
 
-            # At least one platform has an unlimited RLIMIT_FSIZE and attempts
-            # to change it raise ValueError instead.
+        # At least one platform has an unlimited RLIMIT_FSIZE and attempts
+        # to change it raise ValueError instead.
+        try:
             try:
+                resource.setrlimit(resource.RLIMIT_FSIZE, (1024, max))
+                limit_set = True
+            except ValueError:
+                limit_set = False
+            f = open(test_support.TESTFN, "wb")
+            try:
+                f.write("X" * 1024)
                 try:
-                    resource.setrlimit(resource.RLIMIT_FSIZE, (1024, max))
-                    limit_set = True
-                except ValueError:
-                    limit_set = False
-                f = open(test_support.TESTFN, "wb")
-                try:
-                    f.write("X" * 1024)
-                    try:
-                        f.write("Y")
+                    f.write("Y")
+                    f.flush()
+                    # On some systems (e.g., Ubuntu on hppa) the flush()
+                    # doesn't always cause the exception, but the close()
+                    # does eventually.  Try flushing several times in
+                    # an attempt to ensure the file is really synced and
+                    # the exception raised.
+                    for i in range(5):
+                        time.sleep(.1)
                         f.flush()
-                        # On some systems (e.g., Ubuntu on hppa) the flush()
-                        # doesn't always cause the exception, but the close()
-                        # does eventually.  Try flushing several times in
-                        # an attempt to ensure the file is really synced and
-                        # the exception raised.
-                        for i in range(5):
-                            time.sleep(.1)
-                            f.flush()
-                    except IOError:
-                        if not limit_set:
-                            raise
-                    if limit_set:
-                        # Close will attempt to flush the byte we wrote
-                        # Restore limit first to avoid getting a spurious error
-                        resource.setrlimit(resource.RLIMIT_FSIZE, (cur, max))
-                finally:
-                    f.close()
+                except IOError:
+                    if not limit_set:
+                        raise
+                if limit_set:
+                    # Close will attempt to flush the byte we wrote
+                    # Restore limit first to avoid getting a spurious error
+                    resource.setrlimit(resource.RLIMIT_FSIZE, (cur, max))
             finally:
-                if limit_set:
-                    resource.setrlimit(resource.RLIMIT_FSIZE, (cur, max))
-                test_support.unlink(test_support.TESTFN)
+                f.close()
+        finally:
+            if limit_set:
+                resource.setrlimit(resource.RLIMIT_FSIZE, (cur, max))
+            test_support.unlink(test_support.TESTFN)
 
     def test_fsize_toobig(self):
         # Be sure that setrlimit is checking for really large values
@@ -81,16 +79,15 @@
         try:
             (cur, max) = resource.getrlimit(resource.RLIMIT_FSIZE)
         except AttributeError:
+            self.skipTest('RLIMIT_FSIZE not available')
+        try:
+            resource.setrlimit(resource.RLIMIT_FSIZE, (too_big, max))
+        except (OverflowError, ValueError):
             pass
-        else:
-            try:
-                resource.setrlimit(resource.RLIMIT_FSIZE, (too_big, max))
-            except (OverflowError, ValueError):
-                pass
-            try:
-                resource.setrlimit(resource.RLIMIT_FSIZE, (max, too_big))
-            except (OverflowError, ValueError):
-                pass
+        try:
+            resource.setrlimit(resource.RLIMIT_FSIZE, (max, too_big))
+        except (OverflowError, ValueError):
+            pass
 
     def test_getrusage(self):
         self.assertRaises(TypeError, resource.getrusage)
@@ -108,17 +105,16 @@
         try:
             limits = resource.getrlimit(resource.RLIMIT_CPU)
         except AttributeError:
-            pass
-        else:
-            class BadSequence:
-                def __len__(self):
-                    return 2
-                def __getitem__(self, key):
-                    if key in (0, 1):
-                        return len(tuple(range(1000000)))
-                    raise IndexError
+            self.skipTest('RLIMIT_CPU not available')
+        class BadSequence:
+            def __len__(self):
+                return 2
+            def __getitem__(self, key):
+                if key in (0, 1):
+                    return len(tuple(range(1000000)))
+                raise IndexError
 
-            resource.setrlimit(resource.RLIMIT_CPU, BadSequence())
+        resource.setrlimit(resource.RLIMIT_CPU, BadSequence())
 
 def test_main(verbose=None):
     test_support.run_unittest(ResourceTest)
diff -r 3a1db0d2747e Lib/test/test_set.py
--- a/Lib/test/test_set.py
+++ b/Lib/test/test_set.py
@@ -561,10 +561,10 @@
         s = None
         self.assertRaises(ReferenceError, str, p)
 
-    # C API test only available in a debug build
-    if hasattr(set, "test_c_api"):
-        def test_c_api(self):
-            self.assertEqual(set().test_c_api(), True)
+    @unittest.skipUnless(hasattr(set, "test_c_api"),
+                         'C API test only available in a debug build')
+    def test_c_api(self):
+        self.assertEqual(set().test_c_api(), True)
 
 class SetSubclass(set):
     pass
diff -r 3a1db0d2747e Lib/test/test_shutil.py
--- a/Lib/test/test_shutil.py
+++ b/Lib/test/test_shutil.py
@@ -78,33 +78,34 @@
         filename = tempfile.mktemp()
         self.assertRaises(OSError, shutil.rmtree, filename)
 
-    # See bug #1071513 for why we don't run this on cygwin
-    # and bug #1076467 for why we don't run this as root.
-    if (hasattr(os, 'chmod') and sys.platform[:6] != 'cygwin'
-        and not (hasattr(os, 'geteuid') and os.geteuid() == 0)):
-        def test_on_error(self):
-            self.errorState = 0
-            os.mkdir(TESTFN)
-            self.childpath = os.path.join(TESTFN, 'a')
-            f = open(self.childpath, 'w')
-            f.close()
-            old_dir_mode = os.stat(TESTFN).st_mode
-            old_child_mode = os.stat(self.childpath).st_mode
-            # Make unwritable.
-            os.chmod(self.childpath, stat.S_IREAD)
-            os.chmod(TESTFN, stat.S_IREAD)
+    @unittest.skipUnless(hasattr(os, 'chmod'), 'requires os.chmod()')
+    @unittest.skipIf(sys.platform[:6] == 'cygwin',
+                     "This test can't be run on Cygwin (issue #1071513).")
+    @unittest.skipIf(hasattr(os, 'geteuid') and os.geteuid() == 0,
+                     "This test can't be run reliably as root (issue #1076467).")
+    def test_on_error(self):
+        self.errorState = 0
+        os.mkdir(TESTFN)
+        self.childpath = os.path.join(TESTFN, 'a')
+        f = open(self.childpath, 'w')
+        f.close()
+        old_dir_mode = os.stat(TESTFN).st_mode
+        old_child_mode = os.stat(self.childpath).st_mode
+        # Make unwritable.
+        os.chmod(self.childpath, stat.S_IREAD)
+        os.chmod(TESTFN, stat.S_IREAD)
 
-            shutil.rmtree(TESTFN, onerror=self.check_args_to_onerror)
-            # Test whether onerror has actually been called.
-            self.assertEqual(self.errorState, 2,
-                             "Expected call to onerror function did not happen.")
+        shutil.rmtree(TESTFN, onerror=self.check_args_to_onerror)
+        # Test whether onerror has actually been called.
+        self.assertEqual(self.errorState, 2,
+                            "Expected call to onerror function did not happen.")
 
-            # Make writable again.
-            os.chmod(TESTFN, old_dir_mode)
-            os.chmod(self.childpath, old_child_mode)
+        # Make writable again.
+        os.chmod(TESTFN, old_dir_mode)
+        os.chmod(self.childpath, old_child_mode)
 
-            # Clean up.
-            shutil.rmtree(TESTFN)
+        # Clean up.
+        shutil.rmtree(TESTFN)
 
     def check_args_to_onerror(self, func, arg, exc):
         # test_rmtree_errors deliberately runs rmtree
@@ -308,37 +309,38 @@
             finally:
                 shutil.rmtree(TESTFN, ignore_errors=True)
 
-    if hasattr(os, "mkfifo"):
-        # Issue #3002: copyfile and copytree block indefinitely on named pipes
-        def test_copyfile_named_pipe(self):
-            os.mkfifo(TESTFN)
+    # Issue #3002: copyfile and copytree block indefinitely on named pipes
+    @unittest.skipUnless(hasattr(os, "mkfifo"), 'requires os.mkfifo()')
+    def test_copyfile_named_pipe(self):
+        os.mkfifo(TESTFN)
+        try:
+            self.assertRaises(shutil.SpecialFileError,
+                              shutil.copyfile, TESTFN, TESTFN2)
+            self.assertRaises(shutil.SpecialFileError,
+                              shutil.copyfile, __file__, TESTFN)
+        finally:
+            os.remove(TESTFN)
+
+    @unittest.skipUnless(hasattr(os, "mkfifo"), 'requires os.mkfifo()')
+    def test_copytree_named_pipe(self):
+        os.mkdir(TESTFN)
+        try:
+            subdir = os.path.join(TESTFN, "subdir")
+            os.mkdir(subdir)
+            pipe = os.path.join(subdir, "mypipe")
+            os.mkfifo(pipe)
             try:
-                self.assertRaises(shutil.SpecialFileError,
-                                  shutil.copyfile, TESTFN, TESTFN2)
-                self.assertRaises(shutil.SpecialFileError,
-                                  shutil.copyfile, __file__, TESTFN)
-            finally:
-                os.remove(TESTFN)
-
-        def test_copytree_named_pipe(self):
-            os.mkdir(TESTFN)
-            try:
-                subdir = os.path.join(TESTFN, "subdir")
-                os.mkdir(subdir)
-                pipe = os.path.join(subdir, "mypipe")
-                os.mkfifo(pipe)
-                try:
-                    shutil.copytree(TESTFN, TESTFN2)
-                except shutil.Error as e:
-                    errors = e.args[0]
-                    self.assertEqual(len(errors), 1)
-                    src, dst, error_msg = errors[0]
-                    self.assertEqual("`%s` is a named pipe" % pipe, error_msg)
-                else:
-                    self.fail("shutil.Error should have been raised")
-            finally:
-                shutil.rmtree(TESTFN, ignore_errors=True)
-                shutil.rmtree(TESTFN2, ignore_errors=True)
+                shutil.copytree(TESTFN, TESTFN2)
+            except shutil.Error as e:
+                errors = e.args[0]
+                self.assertEqual(len(errors), 1)
+                src, dst, error_msg = errors[0]
+                self.assertEqual("`%s` is a named pipe" % pipe, error_msg)
+            else:
+                self.fail("shutil.Error should have been raised")
+        finally:
+            shutil.rmtree(TESTFN, ignore_errors=True)
+            shutil.rmtree(TESTFN2, ignore_errors=True)
 
     @unittest.skipUnless(hasattr(os, 'chflags') and
                          hasattr(errno, 'EOPNOTSUPP') and
@@ -649,16 +651,14 @@
     def test_move_file_other_fs(self):
         # Move a file to an existing dir on another filesystem.
         if not self.dir_other_fs:
-            # skip
-            return
+            self.skipTest('dir on other filesystem not available')
         self._check_move_file(self.src_file, self.file_other_fs,
             self.file_other_fs)
 
     def test_move_file_to_dir_other_fs(self):
         # Move a file to another location on another filesystem.
         if not self.dir_other_fs:
-            # skip
-            return
+            self.skipTest('dir on other filesystem not available')
         self._check_move_file(self.src_file, self.dir_other_fs,
             self.file_other_fs)
 
@@ -676,8 +676,7 @@
     def test_move_dir_other_fs(self):
         # Move a dir to another location on another filesystem.
         if not self.dir_other_fs:
-            # skip
-            return
+            self.skipTest('dir on other filesystem not available')
         dst_dir = tempfile.mktemp(dir=self.dir_other_fs)
         try:
             self._check_move_dir(self.src_dir, dst_dir, dst_dir)
@@ -695,8 +694,7 @@
     def test_move_dir_to_dir_other_fs(self):
         # Move a dir inside an existing dir on another filesystem.
         if not self.dir_other_fs:
-            # skip
-            return
+            self.skipTest('dir on other filesystem not available')
         self._check_move_dir(self.src_dir, self.dir_other_fs,
             os.path.join(self.dir_other_fs, os.path.basename(self.src_dir)))
 
diff -r 3a1db0d2747e Lib/test/test_site.py
--- a/Lib/test/test_site.py
+++ b/Lib/test/test_site.py
@@ -343,6 +343,7 @@
             self.assertNotIn(path, seen_paths)
             seen_paths.add(path)
 
+    @unittest.skip('test not implemented')
     def test_add_build_dir(self):
         # Test that the build directory's Modules directory is used when it
         # should be.
diff -r 3a1db0d2747e Lib/test/test_socket.py
--- a/Lib/test/test_socket.py
+++ b/Lib/test/test_socket.py
@@ -331,28 +331,29 @@
             ip = socket.gethostbyname(hostname)
         except socket.error:
             # Probably name lookup wasn't set up right; skip this test
-            return
+            self.skipTest('name lookup failure')
         self.assertTrue(ip.find('.') >= 0, "Error resolving host to ip.")
         try:
             hname, aliases, ipaddrs = socket.gethostbyaddr(ip)
         except socket.error:
             # Probably a similar problem as above; skip this test
-            return
+            self.skipTest('address lookup failure')
         all_host_names = [hostname, hname] + aliases
         fqhn = socket.getfqdn(ip)
         if not fqhn in all_host_names:
             self.fail("Error testing host resolution mechanisms. (fqdn: %s, all: %s)" % (fqhn, repr(all_host_names)))
 
+    @unittest.skipUnless(hasattr(sys, 'getrefcount'),
+                         'test needs sys.getrefcount()')
     def testRefCountGetNameInfo(self):
         # Testing reference count for getnameinfo
-        if hasattr(sys, "getrefcount"):
-            try:
-                # On some versions, this loses a reference
-                orig = sys.getrefcount(__name__)
-                socket.getnameinfo(__name__,0)
-            except TypeError:
-                self.assertEqual(sys.getrefcount(__name__), orig,
-                                 "socket.getnameinfo loses a reference")
+        try:
+            # On some versions, this loses a reference
+            orig = sys.getrefcount(__name__)
+            socket.getnameinfo(__name__,0)
+        except TypeError:
+            self.assertEqual(sys.getrefcount(__name__), orig,
+                             "socket.getnameinfo loses a reference")
 
     def testInterpreterCrash(self):
         # Making sure getnameinfo doesn't crash the interpreter
@@ -459,17 +460,17 @@
         # Check that setting it to an invalid type raises TypeError
         self.assertRaises(TypeError, socket.setdefaulttimeout, "spam")
 
+    @unittest.skipUnless(hasattr(socket, 'inet_aton'),
+                         'test needs socket.inet_aton()')
     def testIPv4_inet_aton_fourbytes(self):
-        if not hasattr(socket, 'inet_aton'):
-            return  # No inet_aton, nothing to check
         # Test that issue1008086 and issue767150 are fixed.
         # It must return 4 bytes.
         self.assertEqual('\x00'*4, socket.inet_aton('0.0.0.0'))
         self.assertEqual('\xff'*4, socket.inet_aton('255.255.255.255'))
 
+    @unittest.skipUnless(hasattr(socket, 'inet_pton'),
+                         'test needs socket.inet_pton()')
     def testIPv4toString(self):
-        if not hasattr(socket, 'inet_pton'):
-            return # No inet_pton() on this platform
         from socket import inet_aton as f, inet_pton, AF_INET
         g = lambda a: inet_pton(AF_INET, a)
 
@@ -484,15 +485,15 @@
         self.assertEqual('\xaa\xaa\xaa\xaa', g('170.170.170.170'))
         self.assertEqual('\xff\xff\xff\xff', g('255.255.255.255'))
 
+    @unittest.skipUnless(hasattr(socket, 'inet_pton'),
+                         'test needs socket.inet_pton()')
     def testIPv6toString(self):
-        if not hasattr(socket, 'inet_pton'):
-            return # No inet_pton() on this platform
         try:
             from socket import inet_pton, AF_INET6, has_ipv6
             if not has_ipv6:
-                return
+                self.skipTest('IPv6 not available')
         except ImportError:
-            return
+            self.skipTest('could not import needed symbols from socket')
         f = lambda a: inet_pton(AF_INET6, a)
 
         self.assertEqual('\x00' * 16, f('::'))
@@ -503,9 +504,9 @@
             f('45ef:76cb:1a:56ef:afeb:bac:1924:aeae')
         )
 
+    @unittest.skipUnless(hasattr(socket, 'inet_ntop'),
+                         'test needs socket.inet_ntop()')
     def testStringToIPv4(self):
-        if not hasattr(socket, 'inet_ntop'):
-            return # No inet_ntop() on this platform
         from socket import inet_ntoa as f, inet_ntop, AF_INET
         g = lambda a: inet_ntop(AF_INET, a)
 
@@ -518,15 +519,15 @@
         self.assertEqual('170.85.170.85', g('\xaa\x55\xaa\x55'))
         self.assertEqual('255.255.255.255', g('\xff\xff\xff\xff'))
 
+    @unittest.skipUnless(hasattr(socket, 'inet_ntop'),
+                         'test needs socket.inet_ntop()')
     def testStringToIPv6(self):
-        if not hasattr(socket, 'inet_ntop'):
-            return # No inet_ntop() on this platform
         try:
             from socket import inet_ntop, AF_INET6, has_ipv6
             if not has_ipv6:
-                return
+                self.skipTest('IPv6 not available')
         except ImportError:
-            return
+            self.skipTest('could not import needed symbols from socket')
         f = lambda a: inet_ntop(AF_INET6, a)
 
         self.assertEqual('::', f('\x00' * 16))
@@ -566,7 +567,7 @@
             my_ip_addr = socket.gethostbyname(socket.gethostname())
         except socket.error:
             # Probably name lookup wasn't set up right; skip this test
-            return
+            self.skipTest('name lookup failure')
         self.assertIn(name[0], ("0.0.0.0", my_ip_addr), '%s invalid' % name[0])
         self.assertEqual(name[1], port)
 
@@ -785,10 +786,10 @@
         big_chunk = 'f' * 2048
         self.serv_conn.sendall(big_chunk)
 
+    @unittest.skipUnless(hasattr(socket, 'fromfd'),
+                         'socket.fromfd not availble')
     def testFromFd(self):
         # Testing fromfd()
-        if not hasattr(socket, "fromfd"):
-            return # On Windows, this doesn't exist
         fd = self.cli_conn.fileno()
         sock = socket.fromfd(fd, socket.AF_INET, socket.SOCK_STREAM)
         self.addCleanup(sock.close)
@@ -871,6 +872,8 @@
         self.cli.connect((HOST, self.port))
         time.sleep(1.0)
 
+@unittest.skipUnless(hasattr(socket, 'socketpair'),
+                     'test needs socket.socketpair()')
 @unittest.skipUnless(thread, 'Threading required for this test.')
 class BasicSocketPairTest(SocketPairTest):
 
@@ -1456,12 +1459,12 @@
         if not ok:
             self.fail("accept() returned success when we did not expect it")
 
+    @unittest.skipUnless(hasattr(signal, 'alarm'),
+                         'test needs signal.alarm()')
     def testInterruptedTimeout(self):
         # XXX I don't know how to do this test on MSWindows or any other
         # plaform that doesn't support signal.alarm() or os.kill(), though
         # the bug should have existed on all platforms.
-        if not hasattr(signal, "alarm"):
-            return                  # can only test on *nix
         self.serv.settimeout(5.0)   # must be longer than alarm
         class Alarm(Exception):
             pass
@@ -1521,6 +1524,7 @@
         self.assertTrue(issubclass(socket.gaierror, socket.error))
         self.assertTrue(issubclass(socket.timeout, socket.error))
 
+@unittest.skipUnless(sys.platform == 'linux', 'Linux specific test')
 class TestLinuxAbstractNamespace(unittest.TestCase):
 
     UNIX_PATH_MAX = 108
@@ -1635,11 +1639,11 @@
         for line in f:
             if line.startswith("tipc "):
                 return True
-    if test_support.verbose:
-        print "TIPC module is not loaded, please 'sudo modprobe tipc'"
     return False
 
-class TIPCTest (unittest.TestCase):
+@unittest.skipUnless(isTipcAvailable(),
+                     "TIPC module is not loaded, please 'sudo modprobe tipc'")
+class TIPCTest(unittest.TestCase):
     def testRDM(self):
         srv = socket.socket(socket.AF_TIPC, socket.SOCK_RDM)
         cli = socket.socket(socket.AF_TIPC, socket.SOCK_RDM)
@@ -1659,7 +1663,9 @@
         self.assertEqual(msg, MSG)
 
 
-class TIPCThreadableTest (unittest.TestCase, ThreadableTest):
+@unittest.skipUnless(isTipcAvailable(),
+                     "TIPC module is not loaded, please 'sudo modprobe tipc'")
+class TIPCThreadableTest(unittest.TestCase, ThreadableTest):
     def __init__(self, methodName = 'runTest'):
         unittest.TestCase.__init__(self, methodName = methodName)
         ThreadableTest.__init__(self)
@@ -1712,13 +1718,9 @@
         NetworkConnectionAttributesTest,
         NetworkConnectionBehaviourTest,
     ])
-    if hasattr(socket, "socketpair"):
-        tests.append(BasicSocketPairTest)
-    if sys.platform == 'linux2':
-        tests.append(TestLinuxAbstractNamespace)
-    if isTipcAvailable():
-        tests.append(TIPCTest)
-        tests.append(TIPCThreadableTest)
+    tests.append(BasicSocketPairTest)
+    tests.append(TestLinuxAbstractNamespace)
+    tests.extend([TIPCTest, TIPCThreadableTest])
 
     thread_info = test_support.threading_setup()
     test_support.run_unittest(*tests)
diff -r 3a1db0d2747e Lib/test/test_socketserver.py
--- a/Lib/test/test_socketserver.py
+++ b/Lib/test/test_socketserver.py
@@ -27,7 +27,10 @@
 HOST = test.test_support.HOST
 
 HAVE_UNIX_SOCKETS = hasattr(socket, "AF_UNIX")
+requires_unix_sockets = unittest.skipUnless(HAVE_UNIX_SOCKETS,
+                                            'requires Unix sockets')
 HAVE_FORKING = hasattr(os, "fork") and os.name != "os2"
+requires_forking = unittest.skipUnless(HAVE_FORKING, 'requires forking')
 
 def signal_alarm(n):
     """Call signal.alarm when it exists (i.e. not on Windows)."""
@@ -188,31 +191,33 @@
                         SocketServer.StreamRequestHandler,
                         self.stream_examine)
 
-    if HAVE_FORKING:
-        def test_ForkingTCPServer(self):
-            with simple_subprocess(self):
-                self.run_server(SocketServer.ForkingTCPServer,
-                                SocketServer.StreamRequestHandler,
-                                self.stream_examine)
-
-    if HAVE_UNIX_SOCKETS:
-        def test_UnixStreamServer(self):
-            self.run_server(SocketServer.UnixStreamServer,
+    @requires_forking
+    def test_ForkingTCPServer(self):
+        with simple_subprocess(self):
+            self.run_server(SocketServer.ForkingTCPServer,
                             SocketServer.StreamRequestHandler,
                             self.stream_examine)
 
-        def test_ThreadingUnixStreamServer(self):
-            self.run_server(SocketServer.ThreadingUnixStreamServer,
+    @requires_unix_sockets
+    def test_UnixStreamServer(self):
+        self.run_server(SocketServer.UnixStreamServer,
+                        SocketServer.StreamRequestHandler,
+                        self.stream_examine)
+
+    @requires_unix_sockets
+    def test_ThreadingUnixStreamServer(self):
+        self.run_server(SocketServer.ThreadingUnixStreamServer,
+                        SocketServer.StreamRequestHandler,
+                        self.stream_examine)
+
+    @requires_unix_sockets
+    @requires_forking
+    def test_ForkingUnixStreamServer(self):
+        with simple_subprocess(self):
+            self.run_server(ForkingUnixStreamServer,
                             SocketServer.StreamRequestHandler,
                             self.stream_examine)
 
-        if HAVE_FORKING:
-            def test_ForkingUnixStreamServer(self):
-                with simple_subprocess(self):
-                    self.run_server(ForkingUnixStreamServer,
-                                    SocketServer.StreamRequestHandler,
-                                    self.stream_examine)
-
     def test_UDPServer(self):
         self.run_server(SocketServer.UDPServer,
                         SocketServer.DatagramRequestHandler,
@@ -223,12 +228,12 @@
                         SocketServer.DatagramRequestHandler,
                         self.dgram_examine)
 
-    if HAVE_FORKING:
-        def test_ForkingUDPServer(self):
-            with simple_subprocess(self):
-                self.run_server(SocketServer.ForkingUDPServer,
-                                SocketServer.DatagramRequestHandler,
-                                self.dgram_examine)
+    @requires_forking
+    def test_ForkingUDPServer(self):
+        with simple_subprocess(self):
+            self.run_server(SocketServer.ForkingUDPServer,
+                            SocketServer.DatagramRequestHandler,
+                            self.dgram_examine)
 
     @contextlib.contextmanager
     def mocked_select_module(self):
@@ -265,22 +270,24 @@
     # Alas, on Linux (at least) recvfrom() doesn't return a meaningful
     # client address so this cannot work:
 
-    # if HAVE_UNIX_SOCKETS:
-    #     def test_UnixDatagramServer(self):
-    #         self.run_server(SocketServer.UnixDatagramServer,
-    #                         SocketServer.DatagramRequestHandler,
-    #                         self.dgram_examine)
+    # @requires_unix_sockets
+    # def test_UnixDatagramServer(self):
+    #     self.run_server(SocketServer.UnixDatagramServer,
+    #                     SocketServer.DatagramRequestHandler,
+    #                     self.dgram_examine)
     #
-    #     def test_ThreadingUnixDatagramServer(self):
-    #         self.run_server(SocketServer.ThreadingUnixDatagramServer,
-    #                         SocketServer.DatagramRequestHandler,
-    #                         self.dgram_examine)
+    # @requires_unix_sockets
+    # def test_ThreadingUnixDatagramServer(self):
+    #     self.run_server(SocketServer.ThreadingUnixDatagramServer,
+    #                     SocketServer.DatagramRequestHandler,
+    #                     self.dgram_examine)
     #
-    #     if HAVE_FORKING:
-    #         def test_ForkingUnixDatagramServer(self):
-    #             self.run_server(SocketServer.ForkingUnixDatagramServer,
-    #                             SocketServer.DatagramRequestHandler,
-    #                             self.dgram_examine)
+    # @requires_unix_sockets
+    # @requires_forking
+    # def test_ForkingUnixDatagramServer(self):
+    #     self.run_server(SocketServer.ForkingUnixDatagramServer,
+    #                     SocketServer.DatagramRequestHandler,
+    #                     self.dgram_examine)
 
     @reap_threads
     def test_shutdown(self):
diff -r 3a1db0d2747e Lib/test/test_ssl.py
--- a/Lib/test/test_ssl.py
+++ b/Lib/test/test_ssl.py
@@ -192,9 +192,8 @@
         self.assertTrue(s.startswith("OpenSSL {:d}.{:d}.{:d}".format(major, minor, fix)),
                         (s, t))
 
+    @test_support.requires_resource('network')
     def test_ciphers(self):
-        if not test_support.is_resource_enabled('network'):
-            return
         remote = ("svn.python.org", 443)
         with test_support.transient_internet(remote[0]):
             s = ssl.wrap_socket(socket.socket(socket.AF_INET),
@@ -233,6 +232,13 @@
         self.assertRaises(socket.error, ss.send, b'x')
         self.assertRaises(socket.error, ss.sendto, b'x', ('0.0.0.0', 0))
 
+    def test_unsupported_dtls(self):
+        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
+        self.addCleanup(s.close)
+        with self.assertRaises(NotImplementedError) as cx:
+            ssl.wrap_socket(s, cert_reqs=ssl.CERT_NONE)
+        self.assertEqual(str(cx.exception), "only stream sockets are supported")
+
 
 class NetworkedTests(unittest.TestCase):
 
@@ -1046,7 +1052,7 @@
             try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv2, True)
             try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv2, True, ssl.CERT_OPTIONAL)
             try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv2, True, ssl.CERT_REQUIRED)
-            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv23, True)
+            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv23, False)
             try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv3, False)
             try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_TLSv1, False)
 
diff -r 3a1db0d2747e Lib/test/test_str.py
--- a/Lib/test/test_str.py
+++ b/Lib/test/test_str.py
@@ -1,4 +1,4 @@
-
+import unittest
 import struct
 import sys
 from test import test_support, string_tests
@@ -110,12 +110,12 @@
         self.assertEqual(str(Foo9("foo")), "string")
         self.assertEqual(unicode(Foo9("foo")), u"not unicode")
 
+    # This test only affects 32-bit platforms because expandtabs can only take
+    # an int as the max value, not a 64-bit C long.  If expandtabs is changed
+    # to take a 64-bit long, this test should apply to all platforms.
+    @unittest.skipIf(sys.maxint > (1 << 32) or struct.calcsize('P') != 4,
+                     'only applies to 32-bit platforms')
     def test_expandtabs_overflows_gracefully(self):
-        # This test only affects 32-bit platforms because expandtabs can only take
-        # an int as the max value, not a 64-bit C long.  If expandtabs is changed
-        # to take a 64-bit long, this test should apply to all platforms.
-        if sys.maxint > (1 << 32) or struct.calcsize('P') != 4:
-            return
         self.assertRaises(OverflowError, 't\tt\t'.expandtabs, sys.maxint)
 
     def test__format__(self):
diff -r 3a1db0d2747e Lib/test/test_strptime.py
--- a/Lib/test/test_strptime.py
+++ b/Lib/test/test_strptime.py
@@ -313,7 +313,7 @@
         # when time.tzname[0] == time.tzname[1] and time.daylight
         tz_name = time.tzname[0]
         if tz_name.upper() in ("UTC", "GMT"):
-            return
+            self.skipTest('need non-UTC/GMT timezone')
         try:
             original_tzname = time.tzname
             original_daylight = time.daylight
@@ -526,7 +526,7 @@
         try:
             locale.setlocale(locale.LC_TIME, ('en_US', 'UTF8'))
         except locale.Error:
-            return
+            self.skipTest('test needs en_US.UTF8 locale')
         try:
             _strptime._strptime_time('10', '%d')
             # Get id of current cache object.
@@ -543,7 +543,7 @@
             # If this is the case just suppress the exception and fall-through
             # to the resetting to the original locale.
             except locale.Error:
-                pass
+                self.skipTest('test needs de_DE.UTF8 locale')
         # Make sure we don't trample on the locale setting once we leave the
         # test.
         finally:
diff -r 3a1db0d2747e Lib/test/test_strtod.py
--- a/Lib/test/test_strtod.py
+++ b/Lib/test/test_strtod.py
@@ -249,6 +249,38 @@
                     else:
                         assert False, "expected ValueError"
 
+    @test_support.precisionbigmemtest(size=test_support._2G, memuse=3,
+                                      dry_run=False)
+    def test_oversized_digit_strings(self, maxsize):
+        # Input string whose length doesn't fit in an INT.
+        s = "1." + "1" * int(2.2e9)
+        with self.assertRaises(ValueError):
+            float(s)
+        del s
+
+        s = "0." + "0" * int(2.2e9) + "1"
+        with self.assertRaises(ValueError):
+            float(s)
+        del s
+
+    def test_large_exponents(self):
+        # Verify that the clipping of the exponent in strtod doesn't affect the
+        # output values.
+        def positive_exp(n):
+            """ Long string with value 1.0 and exponent n"""
+            return '0.{}1e+{}'.format('0'*(n-1), n)
+
+        def negative_exp(n):
+            """ Long string with value 1.0 and exponent -n"""
+            return '1{}e-{}'.format('0'*n, n)
+
+        self.assertEqual(float(positive_exp(10000)), 1.0)
+        self.assertEqual(float(positive_exp(20000)), 1.0)
+        self.assertEqual(float(positive_exp(30000)), 1.0)
+        self.assertEqual(float(negative_exp(10000)), 1.0)
+        self.assertEqual(float(negative_exp(20000)), 1.0)
+        self.assertEqual(float(negative_exp(30000)), 1.0)
+
     def test_particular(self):
         # inputs that produced crashes or incorrectly rounded results with
         # previous versions of dtoa.c, for various reasons
diff -r 3a1db0d2747e Lib/test/test_struct.py
--- a/Lib/test/test_struct.py
+++ b/Lib/test/test_struct.py
@@ -574,6 +574,18 @@
         self.check_sizeof('0s', 1)
         self.check_sizeof('0c', 0)
 
+    def test_unicode_format(self):
+        try:
+            unicode
+        except NameError:
+            self.skipTest('no unicode support')
+        # Issue #19099
+        s = struct.Struct(unichr(ord('I')))
+        self.assertEqual(s.format, 'I')
+        self.assertIs(type(s.format), str)
+        self.assertRaises(ValueError, struct.Struct, unichr(0x80))
+
+
 def test_main():
     support.run_unittest(StructTest)
 
diff -r 3a1db0d2747e Lib/test/test_sunau.py
--- a/Lib/test/test_sunau.py
+++ b/Lib/test/test_sunau.py
@@ -5,10 +5,12 @@
 import sunau
 
 
-class SunauPCM8Test(audiotests.AudioWriteTests,
-        audiotests.AudioTestsWithSourceFile,
-        unittest.TestCase):
+class SunauTest(audiotests.AudioWriteTests,
+                audiotests.AudioTestsWithSourceFile):
     module = sunau
+
+
+class SunauPCM8Test(SunauTest, unittest.TestCase):
     sndfilename = 'pluck-pcm8.au'
     sndfilenframes = 3307
     nchannels = 2
@@ -25,10 +27,7 @@
       """)
 
 
-class SunauPCM16Test(audiotests.AudioWriteTests,
-        audiotests.AudioTestsWithSourceFile,
-        unittest.TestCase):
-    module = sunau
+class SunauPCM16Test(SunauTest, unittest.TestCase):
     sndfilename = 'pluck-pcm16.au'
     sndfilenframes = 3307
     nchannels = 2
@@ -47,10 +46,7 @@
       """)
 
 
-class SunauPCM32Test(audiotests.AudioWriteTests,
-        audiotests.AudioTestsWithSourceFile,
-        unittest.TestCase):
-    module = sunau
+class SunauPCM32Test(SunauTest, unittest.TestCase):
     sndfilename = 'pluck-pcm32.au'
     sndfilenframes = 3307
     nchannels = 2
@@ -75,10 +71,7 @@
       """)
 
 
-class SunauULAWTest(audiotests.AudioWriteTests,
-        audiotests.AudioTestsWithSourceFile,
-        unittest.TestCase):
-    module = sunau
+class SunauULAWTest(SunauTest, unittest.TestCase):
     sndfilename = 'pluck-ulaw.au'
     sndfilenframes = 3307
     nchannels = 2
diff -r 3a1db0d2747e Lib/test/test_support.py
--- a/Lib/test/test_support.py
+++ b/Lib/test/test_support.py
@@ -271,6 +271,36 @@
         # is exited) but there is a .pyo file.
         unlink(os.path.join(dirname, modname + os.extsep + 'pyo'))
 
+# On some platforms, should not run gui test even if it is allowed
+# in `use_resources'.
+if sys.platform.startswith('win'):
+    import ctypes
+    import ctypes.wintypes
+    def _is_gui_available():
+        UOI_FLAGS = 1
+        WSF_VISIBLE = 0x0001
+        class USEROBJECTFLAGS(ctypes.Structure):
+            _fields_ = [("fInherit", ctypes.wintypes.BOOL),
+                        ("fReserved", ctypes.wintypes.BOOL),
+                        ("dwFlags", ctypes.wintypes.DWORD)]
+        dll = ctypes.windll.user32
+        h = dll.GetProcessWindowStation()
+        if not h:
+            raise ctypes.WinError()
+        uof = USEROBJECTFLAGS()
+        needed = ctypes.wintypes.DWORD()
+        res = dll.GetUserObjectInformationW(h,
+            UOI_FLAGS,
+            ctypes.byref(uof),
+            ctypes.sizeof(uof),
+            ctypes.byref(needed))
+        if not res:
+            raise ctypes.WinError()
+        return bool(uof.dwFlags & WSF_VISIBLE)
+else:
+    def _is_gui_available():
+        return True
+
 def is_resource_enabled(resource):
     """Test whether a resource is enabled.  Known resources are set by
     regrtest.py."""
@@ -281,6 +311,8 @@
 
     If the caller's module is __main__ then automatically return True.  The
     possibility of False being returned occurs when regrtest.py is executing."""
+    if resource == 'gui' and not _is_gui_available():
+        raise unittest.SkipTest("Cannot use the 'gui' resource")
     # see if the caller's module is __main__ - if so, treat as if
     # the resource was set
     if sys._getframe(1).f_globals.get("__name__") == "__main__":
@@ -377,9 +409,15 @@
                 raise TestFailed("tests should never set the SO_REUSEADDR "   \
                                  "socket option on TCP/IP sockets!")
         if hasattr(socket, 'SO_REUSEPORT'):
-            if sock.getsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT) == 1:
-                raise TestFailed("tests should never set the SO_REUSEPORT "   \
-                                 "socket option on TCP/IP sockets!")
+            try:
+                if sock.getsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT) == 1:
+                    raise TestFailed("tests should never set the SO_REUSEPORT "   \
+                                     "socket option on TCP/IP sockets!")
+            except EnvironmentError:
+                # Python's socket module was compiled using modern headers
+                # thus defining SO_REUSEPORT but this process is running
+                # under an older kernel that does not support SO_REUSEPORT.
+                pass
         if hasattr(socket, 'SO_EXCLUSIVEADDRUSE'):
             sock.setsockopt(socket.SOL_SOCKET, socket.SO_EXCLUSIVEADDRUSE, 1)
 
@@ -1128,6 +1166,8 @@
     return obj
 
 def requires_resource(resource):
+    if resource == 'gui' and not _is_gui_available():
+        return unittest.skip("resource 'gui' is not available")
     if is_resource_enabled(resource):
         return _id
     else:
diff -r 3a1db0d2747e Lib/test/test_sys.py
--- a/Lib/test/test_sys.py
+++ b/Lib/test/test_sys.py
@@ -266,15 +266,16 @@
         #  still has 5 elements
         maj, min, buildno, plat, csd = sys.getwindowsversion()
 
+    @unittest.skipUnless(hasattr(sys, "setdlopenflags"),
+                         'test needs sys.setdlopenflags()')
     def test_dlopenflags(self):
-        if hasattr(sys, "setdlopenflags"):
-            self.assertTrue(hasattr(sys, "getdlopenflags"))
-            self.assertRaises(TypeError, sys.getdlopenflags, 42)
-            oldflags = sys.getdlopenflags()
-            self.assertRaises(TypeError, sys.setdlopenflags)
-            sys.setdlopenflags(oldflags+1)
-            self.assertEqual(sys.getdlopenflags(), oldflags+1)
-            sys.setdlopenflags(oldflags)
+        self.assertTrue(hasattr(sys, "getdlopenflags"))
+        self.assertRaises(TypeError, sys.getdlopenflags, 42)
+        oldflags = sys.getdlopenflags()
+        self.assertRaises(TypeError, sys.setdlopenflags)
+        sys.setdlopenflags(oldflags+1)
+        self.assertEqual(sys.getdlopenflags(), oldflags+1)
+        sys.setdlopenflags(oldflags)
 
     def test_refcount(self):
         # n here must be a global in order for this test to pass while
diff -r 3a1db0d2747e Lib/test/test_tarfile.py
--- a/Lib/test/test_tarfile.py
+++ b/Lib/test/test_tarfile.py
@@ -260,7 +260,7 @@
     def test_fail_comp(self):
         # For Gzip and Bz2 Tests: fail with a ReadError on an uncompressed file.
         if self.mode == "r:":
-            return
+            self.skipTest('needs a gz or bz2 mode')
         self.assertRaises(tarfile.ReadError, tarfile.open, tarname, self.mode)
         fobj = open(tarname, "rb")
         self.assertRaises(tarfile.ReadError, tarfile.open, fileobj=fobj, mode=self.mode)
@@ -446,14 +446,12 @@
     def test_detect_fileobj(self):
         self._test_modes(self._testfunc_fileobj)
 
+    @unittest.skipUnless(bz2, 'requires bz2')
     def test_detect_stream_bz2(self):
         # Originally, tarfile's stream detection looked for the string
         # "BZh91" at the start of the file. This is incorrect because
         # the '9' represents the blocksize (900kB). If the file was
         # compressed using another blocksize autodetection fails.
-        if not bz2:
-            return
-
         with open(tarname, "rb") as fobj:
             data = fobj.read()
 
@@ -982,12 +980,11 @@
         self.assertTrue(data.count("\0") == tarfile.RECORDSIZE,
                          "incorrect zero padding")
 
+    @unittest.skipIf(sys.platform == 'win32', 'not appropriate for Windows')
+    @unittest.skipUnless(hasattr(os, 'umask'), 'requires os.umask')
     def test_file_mode(self):
         # Test for issue #8464: Create files with correct
         # permissions.
-        if sys.platform == "win32" or not hasattr(os, "umask"):
-            return
-
         if os.path.exists(tmpname):
             os.remove(tmpname)
 
@@ -1360,15 +1357,13 @@
         self._add_testfile()
         self._test(names=["foo", "bar"])
 
+    @unittest.skipUnless(gzip, 'requires gzip')
     def test_append_gz(self):
-        if gzip is None:
-            return
         self._create_testtar("w:gz")
         self.assertRaises(tarfile.ReadError, tarfile.open, tmpname, "a")
 
+    @unittest.skipUnless(bz2, 'requires bz2')
     def test_append_bz2(self):
-        if bz2 is None:
-            return
         self._create_testtar("w:bz2")
         self.assertRaises(tarfile.ReadError, tarfile.open, tmpname, "a")
 
diff -r 3a1db0d2747e Lib/test/test_tcl.py
--- a/Lib/test/test_tcl.py
+++ b/Lib/test/test_tcl.py
@@ -33,6 +33,7 @@
 
     def setUp(self):
         self.interp = Tcl()
+        self.wantobjects = self.interp.tk.wantobjects()
 
     def testEval(self):
         tcl = self.interp
@@ -138,18 +139,15 @@
         tcl = self.interp
         self.assertRaises(TclError,tcl.eval,'package require DNE')
 
+    @unittest.skipUnless(sys.platform == 'win32', "only applies to Windows")
     def testLoadWithUNC(self):
-        import sys
-        if sys.platform != 'win32':
-            return
-
         # Build a UNC path from the regular path.
         # Something like
         #   \\%COMPUTERNAME%\c$\python27\python.exe
 
         fullname = os.path.abspath(sys.executable)
         if fullname[1] != ':':
-            return
+            self.skipTest('unusable path: %r' % fullname)
         unc_name = r'\\%s\%s$\%s' % (os.environ['COMPUTERNAME'],
                                     fullname[0],
                                     fullname[3:])
@@ -158,7 +156,14 @@
             env.unset("TCL_LIBRARY")
             cmd = '%s -c "import Tkinter; print Tkinter"' % (unc_name,)
 
-            p = Popen(cmd, stdout=PIPE, stderr=PIPE)
+            try:
+                p = Popen(cmd, stdout=PIPE, stderr=PIPE)
+            except WindowsError as e:
+                if e.winerror == 5:
+                    self.skipTest('Not permitted to start the child process')
+                else:
+                    raise
+
             out_data, err_data = p.communicate()
 
             msg = '\n\n'.join(['"Tkinter.py" not in output',
@@ -174,24 +179,32 @@
     def test_passing_values(self):
         def passValue(value):
             return self.interp.call('set', '_', value)
-        self.assertEqual(passValue(True), True)
-        self.assertEqual(passValue(False), False)
-        self.assertEqual(passValue('string'), 'string')
-        self.assertEqual(passValue('string\u20ac'), 'string\u20ac')
+
+        self.assertEqual(passValue(True), True if self.wantobjects else '1')
+        self.assertEqual(passValue(False), False if self.wantobjects else '0')
         self.assertEqual(passValue(u'string'), u'string')
         self.assertEqual(passValue(u'string\u20ac'), u'string\u20ac')
         for i in (0, 1, -1, int(2**31-1), int(-2**31)):
-            self.assertEqual(passValue(i), i)
+            self.assertEqual(passValue(i), i if self.wantobjects else str(i))
         for f in (0.0, 1.0, -1.0, 1//3, 1/3.0,
                   sys.float_info.min, sys.float_info.max,
                   -sys.float_info.min, -sys.float_info.max):
-            self.assertEqual(passValue(f), f)
-        for f in float('nan'), float('inf'), -float('inf'):
-            if f != f: # NaN
-                self.assertNotEqual(passValue(f), f)
+            if self.wantobjects:
+                self.assertEqual(passValue(f), f)
             else:
-                self.assertEqual(passValue(f), f)
-        self.assertEqual(passValue((1, '2', (3.4,))), (1, '2', (3.4,)))
+                self.assertEqual(float(passValue(f)), f)
+        if self.wantobjects:
+            f = passValue(float('nan'))
+            self.assertNotEqual(f, f)
+            self.assertEqual(passValue(float('inf')), float('inf'))
+            self.assertEqual(passValue(-float('inf')), -float('inf'))
+        else:
+            f = float(passValue(float('nan')))
+            self.assertNotEqual(f, f)
+            self.assertEqual(float(passValue(float('inf'))), float('inf'))
+            self.assertEqual(float(passValue(-float('inf'))), -float('inf'))
+        self.assertEqual(passValue((1, '2', (3.4,))),
+                         (1, '2', (3.4,)) if self.wantobjects else '1 2 3.4')
 
     def test_splitlist(self):
         splitlist = self.interp.tk.splitlist
@@ -216,12 +229,15 @@
             ('a 3.4', ('a', '3.4')),
             (('a', 3.4), ('a', 3.4)),
             ((), ()),
-            (call('list', 1, '2', (3.4,)), (1, '2', (3.4,))),
+            (call('list', 1, '2', (3.4,)),
+                (1, '2', (3.4,)) if self.wantobjects else
+                ('1', '2', '3.4')),
         ]
         if tcl_version >= (8, 5):
             testcases += [
                 (call('dict', 'create', 1, u'\u20ac', '\xe2\x82\xac', (3.4,)),
-                        (1, u'\u20ac', u'\u20ac', (3.4,))),
+                    (1, u'\u20ac', u'\u20ac', (3.4,)) if self.wantobjects else
+                    ('1', '\xe2\x82\xac', '\xe2\x82\xac', '3.4')),
             ]
         for arg, res in testcases:
             self.assertEqual(splitlist(arg), res)
@@ -253,12 +269,15 @@
             (('a', 3.4), ('a', 3.4)),
             (('a', (2, 3.4)), ('a', (2, 3.4))),
             ((), ()),
-            (call('list', 1, '2', (3.4,)), (1, '2', (3.4,))),
+            (call('list', 1, '2', (3.4,)),
+                (1, '2', (3.4,)) if self.wantobjects else
+                ('1', '2', '3.4')),
         ]
         if tcl_version >= (8, 5):
             testcases += [
                 (call('dict', 'create', 12, u'\u20ac', '\xe2\x82\xac', (3.4,)),
-                        (12, u'\u20ac', u'\u20ac', (3.4,))),
+                    (12, u'\u20ac', u'\u20ac', (3.4,)) if self.wantobjects else
+                    ('12', '\xe2\x82\xac', '\xe2\x82\xac', '3.4')),
             ]
         for arg, res in testcases:
             self.assertEqual(split(arg), res)
@@ -278,6 +297,12 @@
         self.assertRaises(OverflowError, self.interp.call, 'set', '_', value)
 
 
+def setUpModule():
+    if test_support.verbose:
+        tcl = Tcl()
+        print 'patchlevel =', tcl.call('info', 'patchlevel')
+
+
 def test_main():
     test_support.run_unittest(TclTest, TkinterTest, BigmemTclTest)
 
diff -r 3a1db0d2747e Lib/test/test_telnetlib.py
--- a/Lib/test/test_telnetlib.py
+++ b/Lib/test/test_telnetlib.py
@@ -177,7 +177,6 @@
         self.dataq.join()
         data = telnet.read_all()
         self.assertEqual(data, ''.join(want[:-1]))
-        return
 
     def _test_blocking(self, func):
         self.dataq.put([self.block_long, EOF_sigil])
diff -r 3a1db0d2747e Lib/test/test_tempfile.py
--- a/Lib/test/test_tempfile.py
+++ b/Lib/test/test_tempfile.py
@@ -342,10 +342,9 @@
         finally:
             os.rmdir(dir)
 
+    @unittest.skipUnless(has_stat, 'os.stat not available')
     def test_file_mode(self):
         # _mkstemp_inner creates files with the proper mode
-        if not has_stat:
-            return            # ugh, can't use SkipTest.
 
         file = self.do_create()
         mode = stat.S_IMODE(os.stat(file.name).st_mode)
@@ -357,10 +356,9 @@
             expected = user * (1 + 8 + 64)
         self.assertEqual(mode, expected)
 
+    @unittest.skipUnless(has_spawnl, 'os.spawnl not available')
     def test_noinherit(self):
         # _mkstemp_inner file handles are not inherited by child processes
-        if not has_spawnl:
-            return            # ugh, can't use SkipTest.
 
         if support.verbose:
             v="v"
@@ -395,10 +393,9 @@
                     "child process caught fatal signal %d" % -retval)
         self.assertFalse(retval > 0, "child process reports failure %d"%retval)
 
+    @unittest.skipUnless(has_textmode, "text mode not available")
     def test_textmode(self):
         # _mkstemp_inner can create files in text mode
-        if not has_textmode:
-            return            # ugh, can't use SkipTest.
 
         self.do_create(bin=0).write("blat\n")
         # XXX should test that the file really is a text file
@@ -590,10 +587,9 @@
         finally:
             os.rmdir(dir)
 
+    @unittest.skipUnless(has_stat, 'os.stat not available')
     def test_mode(self):
         # mkdtemp creates directories with the proper mode
-        if not has_stat:
-            return            # ugh, can't use SkipTest.
 
         dir = self.do_create()
         try:
diff -r 3a1db0d2747e Lib/test/test_thread.py
--- a/Lib/test/test_thread.py
+++ b/Lib/test/test_thread.py
@@ -70,39 +70,35 @@
         thread.stack_size(0)
         self.assertEqual(thread.stack_size(), 0, "stack_size not reset to default")
 
-        if os.name not in ("nt", "os2", "posix"):
-            return
-
-        tss_supported = True
+    @unittest.skipIf(os.name not in ("nt", "os2", "posix"), 'test meant for nt, os2, and posix')
+    def test_nt_and_posix_stack_size(self):
         try:
             thread.stack_size(4096)
         except ValueError:
             verbose_print("caught expected ValueError setting "
                             "stack_size(4096)")
         except thread.error:
-            tss_supported = False
-            verbose_print("platform does not support changing thread stack "
-                            "size")
+            self.skipTest("platform does not support changing thread stack "
+                          "size")
 
-        if tss_supported:
-            fail_msg = "stack_size(%d) failed - should succeed"
-            for tss in (262144, 0x100000, 0):
-                thread.stack_size(tss)
-                self.assertEqual(thread.stack_size(), tss, fail_msg % tss)
-                verbose_print("successfully set stack_size(%d)" % tss)
+        fail_msg = "stack_size(%d) failed - should succeed"
+        for tss in (262144, 0x100000, 0):
+            thread.stack_size(tss)
+            self.assertEqual(thread.stack_size(), tss, fail_msg % tss)
+            verbose_print("successfully set stack_size(%d)" % tss)
 
-            for tss in (262144, 0x100000):
-                verbose_print("trying stack_size = (%d)" % tss)
-                self.next_ident = 0
-                self.created = 0
-                for i in range(NUMTASKS):
-                    self.newtask()
+        for tss in (262144, 0x100000):
+            verbose_print("trying stack_size = (%d)" % tss)
+            self.next_ident = 0
+            self.created = 0
+            for i in range(NUMTASKS):
+                self.newtask()
 
-                verbose_print("waiting for all tasks to complete")
-                self.done_mutex.acquire()
-                verbose_print("all tasks done")
+            verbose_print("waiting for all tasks to complete")
+            self.done_mutex.acquire()
+            verbose_print("all tasks done")
 
-            thread.stack_size(0)
+        thread.stack_size(0)
 
     def test__count(self):
         # Test the _count() function.
diff -r 3a1db0d2747e Lib/test/test_threading.py
--- a/Lib/test/test_threading.py
+++ b/Lib/test/test_threading.py
@@ -14,6 +14,10 @@
 import weakref
 import os
 import subprocess
+try:
+    import _testcapi
+except ImportError:
+    _testcapi = None
 
 from test import lock_tests
 
@@ -125,9 +129,7 @@
         try:
             threading.stack_size(262144)
         except thread.error:
-            if verbose:
-                print 'platform does not support changing thread stack size'
-            return
+            self.skipTest('platform does not support changing thread stack size')
         self.test_various_ops()
         threading.stack_size(0)
 
@@ -138,9 +140,7 @@
         try:
             threading.stack_size(0x100000)
         except thread.error:
-            if verbose:
-                print 'platform does not support changing thread stack size'
-            return
+            self.skipTest('platform does not support changing thread stack size')
         self.test_various_ops()
         threading.stack_size(0)
 
@@ -167,9 +167,7 @@
         try:
             import ctypes
         except ImportError:
-            if verbose:
-                print "test_PyThreadState_SetAsyncExc can't import ctypes"
-            return  # can't do anything
+            self.skipTest('requires ctypes')
 
         set_async_exc = ctypes.pythonapi.PyThreadState_SetAsyncExc
 
@@ -275,9 +273,7 @@
         try:
             import ctypes
         except ImportError:
-            if verbose:
-                print("test_finalize_with_runnning_thread can't import ctypes")
-            return  # can't do anything
+            self.skipTest('requires ctypes')
 
         rc = subprocess.call([sys.executable, "-c", """if 1:
             import ctypes, sys, time, thread
@@ -728,6 +724,45 @@
         for t in threads:
             t.join()
 
+    @unittest.skipIf(_testcapi is None, "need _testcapi module")
+    def test_frame_tstate_tracing(self):
+        # Issue #14432: Crash when a generator is created in a C thread that is
+        # destroyed while the generator is still used. The issue was that a
+        # generator contains a frame, and the frame kept a reference to the
+        # Python state of the destroyed C thread. The crash occurs when a trace
+        # function is setup.
+
+        def noop_trace(frame, event, arg):
+            # no operation
+            return noop_trace
+
+        def generator():
+            while 1:
+                yield "genereator"
+
+        def callback():
+            if callback.gen is None:
+                callback.gen = generator()
+            return next(callback.gen)
+        callback.gen = None
+
+        old_trace = sys.gettrace()
+        sys.settrace(noop_trace)
+        try:
+            # Install a trace function
+            threading.settrace(noop_trace)
+
+            # Create a generator in a C thread which exits after the call
+            _testcapi.call_in_temporary_c_thread(callback)
+
+            # Call the generator in a different Python thread, check that the
+            # generator didn't keep a reference to the destroyed thread state
+            for test in range(3):
+                # The trace function is still called here
+                callback()
+        finally:
+            sys.settrace(old_trace)
+
 
 class ThreadingExceptionTests(BaseTestCase):
     # A RuntimeError should be raised if Thread.start() is called
diff -r 3a1db0d2747e Lib/test/test_timeout.py
--- a/Lib/test/test_timeout.py
+++ b/Lib/test/test_timeout.py
@@ -178,16 +178,19 @@
                      "timeout (%g) is %g seconds more than expected (%g)"
                      %(_delta, self.fuzz, _timeout))
 
+    @unittest.skip('test not implemented')
     def testSend(self):
         # Test send() timeout
         # couldn't figure out how to test it
         pass
 
+    @unittest.skip('test not implemented')
     def testSendto(self):
         # Test sendto() timeout
         # couldn't figure out how to test it
         pass
 
+    @unittest.skip('test not implemented')
     def testSendall(self):
         # Test sendall() timeout
         # couldn't figure out how to test it
diff -r 3a1db0d2747e Lib/test/test_unicode.py
--- a/Lib/test/test_unicode.py
+++ b/Lib/test/test_unicode.py
@@ -1278,12 +1278,12 @@
         self.assertEqual(repr(s1()), '\\n')
         self.assertEqual(repr(s2()), '\\n')
 
+    # This test only affects 32-bit platforms because expandtabs can only take
+    # an int as the max value, not a 64-bit C long.  If expandtabs is changed
+    # to take a 64-bit long, this test should apply to all platforms.
+    @unittest.skipIf(sys.maxint > (1 << 32) or struct.calcsize('P') != 4,
+                     'only applies to 32-bit platforms')
     def test_expandtabs_overflows_gracefully(self):
-        # This test only affects 32-bit platforms because expandtabs can only take
-        # an int as the max value, not a 64-bit C long.  If expandtabs is changed
-        # to take a 64-bit long, this test should apply to all platforms.
-        if sys.maxint > (1 << 32) or struct.calcsize('P') != 4:
-            return
         self.assertRaises(OverflowError, u't\tt\t'.expandtabs, sys.maxint)
 
     def test__format__(self):
diff -r 3a1db0d2747e Lib/test/test_urllibnet.py
--- a/Lib/test/test_urllibnet.py
+++ b/Lib/test/test_urllibnet.py
@@ -112,12 +112,9 @@
             open_url.close()
         self.assertEqual(code, 404)
 
+    @unittest.skipIf(sys.platform in ('win32',), 'not appropriate for Windows')
+    @unittest.skipUnless(hasattr(os, 'fdopen'), 'os.fdopen not available')
     def test_fileno(self):
-        if (sys.platform in ('win32',) or
-                not hasattr(os, 'fdopen')):
-            # On Windows, socket handles are not file descriptors; this
-            # test can't pass on Windows.
-            return
         # Make sure fd returned by fileno is valid.
         open_url = self.urlopen("http://www.python.org/")
         fd = open_url.fileno()
diff -r 3a1db0d2747e Lib/test/test_uuid.py
--- a/Lib/test/test_uuid.py
+++ b/Lib/test/test_uuid.py
@@ -1,5 +1,6 @@
 import unittest
 from test import test_support
+import io
 import os
 import uuid
 
@@ -346,6 +347,37 @@
 
         self.assertEqual(node1, node2)
 
+    @unittest.skipUnless(os.name == 'posix', 'requires Posix')
+    def test_find_mac(self):
+        data = '''\
+
+fake hwaddr
+cscotun0  Link encap:UNSPEC  HWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00
+eth0      Link encap:Ethernet  HWaddr 12:34:56:78:90:ab
+'''
+        def mock_popen(cmd):
+            return io.BytesIO(data)
+
+        path = os.environ.get("PATH", os.defpath).split(os.pathsep)
+        path.extend(('/sbin', '/usr/sbin'))
+        for dir in path:
+            executable = os.path.join(dir, 'ifconfig')
+            if (os.path.exists(executable) and
+                os.access(executable, os.F_OK | os.X_OK) and
+                not os.path.isdir(executable)):
+                break
+        else:
+            self.skipTest('requires ifconfig')
+
+        with test_support.swap_attr(os, 'popen', mock_popen):
+            mac = uuid._find_mac(
+                command='ifconfig',
+                args='',
+                hw_identifiers=['hwaddr'],
+                get_index=lambda x: x + 1,
+            )
+            self.assertEqual(mac, 0x1234567890ab)
+
     @unittest.skipUnless(importable('ctypes'), 'requires ctypes')
     def test_uuid1(self):
         equal = self.assertEqual
diff -r 3a1db0d2747e Lib/test/test_warnings.py
--- a/Lib/test/test_warnings.py
+++ b/Lib/test/test_warnings.py
@@ -259,11 +259,10 @@
         finally:
             warning_tests.__file__ = filename
 
+    @unittest.skipUnless(hasattr(sys, 'argv'), 'test needs sys.argv')
     def test_missing_filename_main_with_argv(self):
         # If __file__ is not specified and the caller is __main__ and sys.argv
         # exists, then use sys.argv[0] as the file.
-        if not hasattr(sys, 'argv'):
-            return
         filename = warning_tests.__file__
         module_name = warning_tests.__name__
         try:
@@ -669,7 +668,7 @@
         # Explicit tests for the test_support convenience wrapper
         wmod = self.module
         if wmod is not sys.modules['warnings']:
-            return
+            self.skipTest('module to test is not loaded warnings module')
         with test_support.check_warnings(quiet=False) as w:
             self.assertEqual(w.warnings, [])
             wmod.simplefilter("always")
diff -r 3a1db0d2747e Lib/test/test_wave.py
--- a/Lib/test/test_wave.py
+++ b/Lib/test/test_wave.py
@@ -5,10 +5,15 @@
 import wave
 
 
-class WavePCM8Test(audiotests.AudioWriteTests,
-        audiotests.AudioTestsWithSourceFile,
-        unittest.TestCase):
+class WaveTest(audiotests.AudioWriteTests,
+               audiotests.AudioTestsWithSourceFile):
     module = wave
+    test_unseekable_write = None
+    test_unseekable_overflowed_write = None
+    test_unseekable_incompleted_write = None
+
+
+class WavePCM8Test(WaveTest, unittest.TestCase):
     sndfilename = 'pluck-pcm8.wav'
     sndfilenframes = 3307
     nchannels = 2
@@ -25,10 +30,7 @@
       """)
 
 
-class WavePCM16Test(audiotests.AudioWriteTests,
-        audiotests.AudioTestsWithSourceFile,
-        unittest.TestCase):
-    module = wave
+class WavePCM16Test(WaveTest, unittest.TestCase):
     sndfilename = 'pluck-pcm16.wav'
     sndfilenframes = 3307
     nchannels = 2
@@ -48,14 +50,14 @@
     if sys.byteorder != 'big':
         frames = audiotests.byteswap2(frames)
 
+    if sys.byteorder == 'big':
+        @unittest.expectedFailure
+        def test_unseekable_incompleted_write(self):
+            super().test_unseekable_incompleted_write()
 
-@unittest.skipIf(sys.byteorder == 'big',
-                 '24-bit wave files are supported only on little-endian '
-                 'platforms')
-class WavePCM24Test(audiotests.AudioWriteTests,
-        audiotests.AudioTestsWithSourceFile,
-        unittest.TestCase):
-    module = wave
+
+
+class WavePCM24Test(WaveTest, unittest.TestCase):
     sndfilename = 'pluck-pcm24.wav'
     sndfilenframes = 3307
     nchannels = 2
@@ -82,10 +84,7 @@
         frames = audiotests.byteswap3(frames)
 
 
-class WavePCM32Test(audiotests.AudioWriteTests,
-        audiotests.AudioTestsWithSourceFile,
-        unittest.TestCase):
-    module = wave
+class WavePCM32Test(WaveTest, unittest.TestCase):
     sndfilename = 'pluck-pcm32.wav'
     sndfilenframes = 3307
     nchannels = 2
@@ -111,6 +110,11 @@
     if sys.byteorder != 'big':
         frames = audiotests.byteswap4(frames)
 
+    if sys.byteorder == 'big':
+        @unittest.expectedFailure
+        def test_unseekable_incompleted_write(self):
+            super().test_unseekable_incompleted_write()
+
 
 def test_main():
     run_unittest(WavePCM8Test, WavePCM16Test, WavePCM24Test, WavePCM32Test)
diff -r 3a1db0d2747e Lib/test/test_weakref.py
--- a/Lib/test/test_weakref.py
+++ b/Lib/test/test_weakref.py
@@ -4,6 +4,8 @@
 import UserList
 import weakref
 import operator
+import contextlib
+import copy
 
 from test import test_support
 
@@ -91,11 +93,9 @@
         ref1 = weakref.ref(o, self.callback)
         ref2 = weakref.ref(o, self.callback)
         del o
-        self.assertTrue(ref1() is None,
-                     "expected reference to be invalidated")
-        self.assertTrue(ref2() is None,
-                     "expected reference to be invalidated")
-        self.assertTrue(self.cbcalled == 2,
+        self.assertIsNone(ref1(), "expected reference to be invalidated")
+        self.assertIsNone(ref2(), "expected reference to be invalidated")
+        self.assertEqual(self.cbcalled, 2,
                      "callback not called the right number of times")
 
     def test_multiple_selfref_callbacks(self):
@@ -129,15 +129,15 @@
         self.assertRaises(weakref.ReferenceError, check, ref1)
         self.assertRaises(weakref.ReferenceError, check, ref2)
         self.assertRaises(weakref.ReferenceError, bool, weakref.proxy(C()))
-        self.assertTrue(self.cbcalled == 2)
+        self.assertEqual(self.cbcalled, 2)
 
     def check_basic_ref(self, factory):
         o = factory()
         ref = weakref.ref(o)
-        self.assertTrue(ref() is not None,
+        self.assertIsNotNone(ref(),
                      "weak reference to live object should be live")
         o2 = ref()
-        self.assertTrue(o is o2,
+        self.assertIs(o, o2,
                      "<ref>() should return original object if live")
 
     def check_basic_callback(self, factory):
@@ -145,9 +145,9 @@
         o = factory()
         ref = weakref.ref(o, self.callback)
         del o
-        self.assertTrue(self.cbcalled == 1,
+        self.assertEqual(self.cbcalled, 1,
                      "callback did not properly set 'cbcalled'")
-        self.assertTrue(ref() is None,
+        self.assertIsNone(ref(),
                      "ref2 should be dead after deleting object reference")
 
     def test_ref_reuse(self):
@@ -157,19 +157,19 @@
         # between these two; it should make no difference
         proxy = weakref.proxy(o)
         ref2 = weakref.ref(o)
-        self.assertTrue(ref1 is ref2,
+        self.assertIs(ref1, ref2,
                      "reference object w/out callback should be re-used")
 
         o = C()
         proxy = weakref.proxy(o)
         ref1 = weakref.ref(o)
         ref2 = weakref.ref(o)
-        self.assertTrue(ref1 is ref2,
+        self.assertIs(ref1, ref2,
                      "reference object w/out callback should be re-used")
-        self.assertTrue(weakref.getweakrefcount(o) == 2,
+        self.assertEqual(weakref.getweakrefcount(o), 2,
                      "wrong weak ref count for object")
         del proxy
-        self.assertTrue(weakref.getweakrefcount(o) == 1,
+        self.assertEqual(weakref.getweakrefcount(o), 1,
                      "wrong weak ref count for object after deleting proxy")
 
     def test_proxy_reuse(self):
@@ -177,7 +177,7 @@
         proxy1 = weakref.proxy(o)
         ref = weakref.ref(o)
         proxy2 = weakref.proxy(o)
-        self.assertTrue(proxy1 is proxy2,
+        self.assertIs(proxy1, proxy2,
                      "proxy object w/out callback should have been re-used")
 
     def test_basic_proxy(self):
@@ -259,19 +259,19 @@
         o = Object(1)
         p1 = makeref(o, None)
         p2 = makeref(o, None)
-        self.assertTrue(p1 is p2, "both callbacks were None in the C API")
+        self.assertIs(p1, p2, "both callbacks were None in the C API")
         del p1, p2
         p1 = makeref(o)
         p2 = makeref(o, None)
-        self.assertTrue(p1 is p2, "callbacks were NULL, None in the C API")
+        self.assertIs(p1, p2, "callbacks were NULL, None in the C API")
         del p1, p2
         p1 = makeref(o)
         p2 = makeref(o)
-        self.assertTrue(p1 is p2, "both callbacks were NULL in the C API")
+        self.assertIs(p1, p2, "both callbacks were NULL in the C API")
         del p1, p2
         p1 = makeref(o, None)
         p2 = makeref(o)
-        self.assertTrue(p1 is p2, "callbacks were None, NULL in the C API")
+        self.assertIs(p1, p2, "callbacks were None, NULL in the C API")
 
     def test_callable_proxy(self):
         o = Callable()
@@ -279,13 +279,13 @@
 
         self.check_proxy(o, ref1)
 
-        self.assertTrue(type(ref1) is weakref.CallableProxyType,
+        self.assertIs(type(ref1), weakref.CallableProxyType,
                      "proxy is not of callable type")
         ref1('twinkies!')
-        self.assertTrue(o.bar == 'twinkies!',
+        self.assertEqual(o.bar, 'twinkies!',
                      "call through proxy not passed through to original")
         ref1(x='Splat.')
-        self.assertTrue(o.bar == 'Splat.',
+        self.assertEqual(o.bar, 'Splat.',
                      "call through proxy not passed through to original")
 
         # expect due to too few args
@@ -296,24 +296,23 @@
 
     def check_proxy(self, o, proxy):
         o.foo = 1
-        self.assertTrue(proxy.foo == 1,
+        self.assertEqual(proxy.foo, 1,
                      "proxy does not reflect attribute addition")
         o.foo = 2
-        self.assertTrue(proxy.foo == 2,
+        self.assertEqual(proxy.foo, 2,
                      "proxy does not reflect attribute modification")
         del o.foo
-        self.assertTrue(not hasattr(proxy, 'foo'),
+        self.assertFalse(hasattr(proxy, 'foo'),
                      "proxy does not reflect attribute removal")
 
         proxy.foo = 1
-        self.assertTrue(o.foo == 1,
+        self.assertEqual(o.foo, 1,
                      "object does not reflect attribute addition via proxy")
         proxy.foo = 2
-        self.assertTrue(
-            o.foo == 2,
+        self.assertEqual(o.foo, 2,
             "object does not reflect attribute modification via proxy")
         del proxy.foo
-        self.assertTrue(not hasattr(o, 'foo'),
+        self.assertFalse(hasattr(o, 'foo'),
                      "object does not reflect attribute removal via proxy")
 
     def test_proxy_deletion(self):
@@ -337,21 +336,21 @@
         o = C()
         ref1 = weakref.ref(o)
         ref2 = weakref.ref(o, self.callback)
-        self.assertTrue(weakref.getweakrefcount(o) == 2,
+        self.assertEqual(weakref.getweakrefcount(o), 2,
                      "got wrong number of weak reference objects")
 
         proxy1 = weakref.proxy(o)
         proxy2 = weakref.proxy(o, self.callback)
-        self.assertTrue(weakref.getweakrefcount(o) == 4,
+        self.assertEqual(weakref.getweakrefcount(o), 4,
                      "got wrong number of weak reference objects")
 
         del ref1, ref2, proxy1, proxy2
-        self.assertTrue(weakref.getweakrefcount(o) == 0,
+        self.assertEqual(weakref.getweakrefcount(o), 0,
                      "weak reference objects not unlinked from"
                      " referent when discarded.")
 
         # assumes ints do not support weakrefs
-        self.assertTrue(weakref.getweakrefcount(1) == 0,
+        self.assertEqual(weakref.getweakrefcount(1), 0,
                      "got wrong number of weak reference objects for int")
 
     def test_getweakrefs(self):
@@ -359,22 +358,22 @@
         ref1 = weakref.ref(o, self.callback)
         ref2 = weakref.ref(o, self.callback)
         del ref1
-        self.assertTrue(weakref.getweakrefs(o) == [ref2],
+        self.assertEqual(weakref.getweakrefs(o), [ref2],
                      "list of refs does not match")
 
         o = C()
         ref1 = weakref.ref(o, self.callback)
         ref2 = weakref.ref(o, self.callback)
         del ref2
-        self.assertTrue(weakref.getweakrefs(o) == [ref1],
+        self.assertEqual(weakref.getweakrefs(o), [ref1],
                      "list of refs does not match")
 
         del ref1
-        self.assertTrue(weakref.getweakrefs(o) == [],
+        self.assertEqual(weakref.getweakrefs(o), [],
                      "list of refs not cleared")
 
         # assumes ints do not support weakrefs
-        self.assertTrue(weakref.getweakrefs(1) == [],
+        self.assertEqual(weakref.getweakrefs(1), [],
                      "list of refs does not match for int")
 
     def test_newstyle_number_ops(self):
@@ -382,8 +381,8 @@
             pass
         f = F(2.0)
         p = weakref.proxy(f)
-        self.assertTrue(p + 1.0 == 3.0)
-        self.assertTrue(1.0 + p == 3.0)  # this used to SEGV
+        self.assertEqual(p + 1.0, 3.0)
+        self.assertEqual(1.0 + p, 3.0)  # this used to SEGV
 
     def test_callbacks_protected(self):
         # Callbacks protected from already-set exceptions?
@@ -636,7 +635,7 @@
         c.wr = weakref.ref(d, callback)     # this won't trigger
         d.wr = weakref.ref(callback, d.cb)  # ditto
         external_wr = weakref.ref(callback, safe_callback)  # but this will
-        self.assertTrue(external_wr() is callback)
+        self.assertIs(external_wr(), callback)
 
         # The weakrefs attached to c and d should get cleared, so that
         # C.cb is never called.  But external_wr isn't part of the cyclic
@@ -808,11 +807,11 @@
                 return super(MyRef, self).__call__()
         o = Object("foo")
         mr = MyRef(o, value=24)
-        self.assertTrue(mr() is o)
+        self.assertIs(mr(), o)
         self.assertTrue(mr.called)
         self.assertEqual(mr.value, 24)
         del o
-        self.assertTrue(mr() is None)
+        self.assertIsNone(mr())
         self.assertTrue(mr.called)
 
     def test_subclass_refs_dont_replace_standard_refs(self):
@@ -821,14 +820,14 @@
         o = Object(42)
         r1 = MyRef(o)
         r2 = weakref.ref(o)
-        self.assertTrue(r1 is not r2)
+        self.assertIsNot(r1, r2)
         self.assertEqual(weakref.getweakrefs(o), [r2, r1])
         self.assertEqual(weakref.getweakrefcount(o), 2)
         r3 = MyRef(o)
         self.assertEqual(weakref.getweakrefcount(o), 3)
         refs = weakref.getweakrefs(o)
         self.assertEqual(len(refs), 3)
-        self.assertTrue(r2 is refs[0])
+        self.assertIs(r2, refs[0])
         self.assertIn(r1, refs[1:])
         self.assertIn(r3, refs[1:])
 
@@ -838,7 +837,7 @@
         o = Object(42)
         r1 = MyRef(o, id)
         r2 = MyRef(o, str)
-        self.assertTrue(r1 is not r2)
+        self.assertIsNot(r1, r2)
         refs = weakref.getweakrefs(o)
         self.assertIn(r1, refs)
         self.assertIn(r2, refs)
@@ -906,7 +905,7 @@
     def check_len_cycles(self, dict_type, cons):
         N = 20
         items = [RefCycle() for i in range(N)]
-        dct = dict_type(cons(o) for o in items)
+        dct = dict_type(cons(i, o) for i, o in enumerate(items))
         # Keep an iterator alive
         it = dct.iteritems()
         try:
@@ -916,18 +915,23 @@
         del items
         gc.collect()
         n1 = len(dct)
+        list(it)
         del it
         gc.collect()
         n2 = len(dct)
-        # one item may be kept alive inside the iterator
-        self.assertIn(n1, (0, 1))
+        # iteration should prevent garbage collection here
+        # Note that this is a test on an implementation detail.  The requirement
+        # is only to provide stable iteration, not that the size of the container
+        # stay fixed.
+        self.assertEqual(n1, 20)
+        #self.assertIn(n1, (0, 1))
         self.assertEqual(n2, 0)
 
     def test_weak_keyed_len_cycles(self):
-        self.check_len_cycles(weakref.WeakKeyDictionary, lambda k: (k, 1))
+        self.check_len_cycles(weakref.WeakKeyDictionary, lambda n, k: (k, n))
 
     def test_weak_valued_len_cycles(self):
-        self.check_len_cycles(weakref.WeakValueDictionary, lambda k: (1, k))
+        self.check_len_cycles(weakref.WeakValueDictionary, lambda n, k: (n, k))
 
     def check_len_race(self, dict_type, cons):
         # Extended sanity checks for len() in the face of cyclic collection
@@ -965,23 +969,23 @@
         #
         dict, objects = self.make_weak_valued_dict()
         for o in objects:
-            self.assertTrue(weakref.getweakrefcount(o) == 1,
+            self.assertEqual(weakref.getweakrefcount(o), 1,
                          "wrong number of weak references to %r!" % o)
-            self.assertTrue(o is dict[o.arg],
+            self.assertIs(o, dict[o.arg],
                          "wrong object returned by weak dict!")
         items1 = dict.items()
         items2 = dict.copy().items()
         items1.sort()
         items2.sort()
-        self.assertTrue(items1 == items2,
+        self.assertEqual(items1, items2,
                      "cloning of weak-valued dictionary did not work!")
         del items1, items2
-        self.assertTrue(len(dict) == self.COUNT)
+        self.assertEqual(len(dict), self.COUNT)
         del objects[0]
-        self.assertTrue(len(dict) == (self.COUNT - 1),
+        self.assertEqual(len(dict), (self.COUNT - 1),
                      "deleting object did not cause dictionary update")
         del objects, o
-        self.assertTrue(len(dict) == 0,
+        self.assertEqual(len(dict), 0,
                      "deleting the values did not clear the dictionary")
         # regression on SF bug #447152:
         dict = weakref.WeakValueDictionary()
@@ -996,21 +1000,21 @@
         #
         dict, objects = self.make_weak_keyed_dict()
         for o in objects:
-            self.assertTrue(weakref.getweakrefcount(o) == 1,
+            self.assertEqual(weakref.getweakrefcount(o), 1,
                          "wrong number of weak references to %r!" % o)
-            self.assertTrue(o.arg is dict[o],
+            self.assertIs(o.arg, dict[o],
                          "wrong object returned by weak dict!")
         items1 = dict.items()
         items2 = dict.copy().items()
-        self.assertTrue(set(items1) == set(items2),
+        self.assertEqual(set(items1), set(items2),
                      "cloning of weak-keyed dictionary did not work!")
         del items1, items2
-        self.assertTrue(len(dict) == self.COUNT)
+        self.assertEqual(len(dict), self.COUNT)
         del objects[0]
-        self.assertTrue(len(dict) == (self.COUNT - 1),
+        self.assertEqual(len(dict), (self.COUNT - 1),
                      "deleting object did not cause dictionary update")
         del objects, o
-        self.assertTrue(len(dict) == 0,
+        self.assertEqual(len(dict), 0,
                      "deleting the keys did not clear the dictionary")
         o = Object(42)
         dict[o] = "What is the meaning of the universe?"
@@ -1072,37 +1076,117 @@
         items = dict.items()
         for item in dict.iteritems():
             items.remove(item)
-        self.assertTrue(len(items) == 0, "iteritems() did not touch all items")
+        self.assertEqual(len(items), 0, "iteritems() did not touch all items")
 
         # key iterator, via __iter__():
         keys = dict.keys()
         for k in dict:
             keys.remove(k)
-        self.assertTrue(len(keys) == 0, "__iter__() did not touch all keys")
+        self.assertEqual(len(keys), 0, "__iter__() did not touch all keys")
 
         # key iterator, via iterkeys():
         keys = dict.keys()
         for k in dict.iterkeys():
             keys.remove(k)
-        self.assertTrue(len(keys) == 0, "iterkeys() did not touch all keys")
+        self.assertEqual(len(keys), 0, "iterkeys() did not touch all keys")
 
         # value iterator:
         values = dict.values()
         for v in dict.itervalues():
             values.remove(v)
-        self.assertTrue(len(values) == 0,
+        self.assertEqual(len(values), 0,
                      "itervalues() did not touch all values")
 
+    def check_weak_destroy_while_iterating(self, dict, objects, iter_name):
+        n = len(dict)
+        it = iter(getattr(dict, iter_name)())
+        next(it)             # Trigger internal iteration
+        # Destroy an object
+        del objects[-1]
+        gc.collect()    # just in case
+        # We have removed either the first consumed object, or another one
+        self.assertIn(len(list(it)), [len(objects), len(objects) - 1])
+        del it
+        # The removal has been committed
+        self.assertEqual(len(dict), n - 1)
+
+    def check_weak_destroy_and_mutate_while_iterating(self, dict, testcontext):
+        # Check that we can explicitly mutate the weak dict without
+        # interfering with delayed removal.
+        # `testcontext` should create an iterator, destroy one of the
+        # weakref'ed objects and then return a new key/value pair corresponding
+        # to the destroyed object.
+        with testcontext() as (k, v):
+            self.assertFalse(k in dict)
+        with testcontext() as (k, v):
+            self.assertRaises(KeyError, dict.__delitem__, k)
+        self.assertFalse(k in dict)
+        with testcontext() as (k, v):
+            self.assertRaises(KeyError, dict.pop, k)
+        self.assertFalse(k in dict)
+        with testcontext() as (k, v):
+            dict[k] = v
+        self.assertEqual(dict[k], v)
+        ddict = copy.copy(dict)
+        with testcontext() as (k, v):
+            dict.update(ddict)
+        self.assertEqual(dict, ddict)
+        with testcontext() as (k, v):
+            dict.clear()
+        self.assertEqual(len(dict), 0)
+
+    def test_weak_keys_destroy_while_iterating(self):
+        # Issue #7105: iterators shouldn't crash when a key is implicitly removed
+        dict, objects = self.make_weak_keyed_dict()
+        self.check_weak_destroy_while_iterating(dict, objects, 'iterkeys')
+        self.check_weak_destroy_while_iterating(dict, objects, 'iteritems')
+        self.check_weak_destroy_while_iterating(dict, objects, 'itervalues')
+        self.check_weak_destroy_while_iterating(dict, objects, 'iterkeyrefs')
+        dict, objects = self.make_weak_keyed_dict()
+        @contextlib.contextmanager
+        def testcontext():
+            try:
+                it = iter(dict.iteritems())
+                next(it)
+                # Schedule a key/value for removal and recreate it
+                v = objects.pop().arg
+                gc.collect()      # just in case
+                yield Object(v), v
+            finally:
+                it = None           # should commit all removals
+        self.check_weak_destroy_and_mutate_while_iterating(dict, testcontext)
+
+    def test_weak_values_destroy_while_iterating(self):
+        # Issue #7105: iterators shouldn't crash when a key is implicitly removed
+        dict, objects = self.make_weak_valued_dict()
+        self.check_weak_destroy_while_iterating(dict, objects, 'iterkeys')
+        self.check_weak_destroy_while_iterating(dict, objects, 'iteritems')
+        self.check_weak_destroy_while_iterating(dict, objects, 'itervalues')
+        self.check_weak_destroy_while_iterating(dict, objects, 'itervaluerefs')
+        dict, objects = self.make_weak_valued_dict()
+        @contextlib.contextmanager
+        def testcontext():
+            try:
+                it = iter(dict.iteritems())
+                next(it)
+                # Schedule a key/value for removal and recreate it
+                k = objects.pop().arg
+                gc.collect()      # just in case
+                yield k, Object(k)
+            finally:
+                it = None           # should commit all removals
+        self.check_weak_destroy_and_mutate_while_iterating(dict, testcontext)
+
     def test_make_weak_keyed_dict_from_dict(self):
         o = Object(3)
         dict = weakref.WeakKeyDictionary({o:364})
-        self.assertTrue(dict[o] == 364)
+        self.assertEqual(dict[o], 364)
 
     def test_make_weak_keyed_dict_from_weak_keyed_dict(self):
         o = Object(3)
         dict = weakref.WeakKeyDictionary({o:364})
         dict2 = weakref.WeakKeyDictionary(dict)
-        self.assertTrue(dict[o] == 364)
+        self.assertEqual(dict[o], 364)
 
     def make_weak_keyed_dict(self):
         dict = weakref.WeakKeyDictionary()
@@ -1122,19 +1206,19 @@
         weakdict = klass()
         weakdict[key1] = value1
         weakdict[key2] = value2
-        self.assertTrue(len(weakdict) == 2)
+        self.assertEqual(len(weakdict), 2)
         k, v = weakdict.popitem()
-        self.assertTrue(len(weakdict) == 1)
+        self.assertEqual(len(weakdict), 1)
         if k is key1:
-            self.assertTrue(v is value1)
+            self.assertIs(v, value1)
         else:
-            self.assertTrue(v is value2)
+            self.assertIs(v, value2)
         k, v = weakdict.popitem()
-        self.assertTrue(len(weakdict) == 0)
+        self.assertEqual(len(weakdict), 0)
         if k is key1:
-            self.assertTrue(v is value1)
+            self.assertIs(v, value1)
         else:
-            self.assertTrue(v is value2)
+            self.assertIs(v, value2)
 
     def test_weak_valued_dict_popitem(self):
         self.check_popitem(weakref.WeakValueDictionary,
@@ -1145,7 +1229,7 @@
                            C(), "value 1", C(), "value 2")
 
     def check_setdefault(self, klass, key, value1, value2):
-        self.assertTrue(value1 is not value2,
+        self.assertIsNot(value1, value2,
                      "invalid test"
                      " -- value parameters must be distinct objects")
         weakdict = klass()
@@ -1204,10 +1288,10 @@
         o2 = Object('2')
         d[o1] = 'something'
         d[o2] = 'something'
-        self.assertTrue(len(d) == 2)
+        self.assertEqual(len(d), 2)
         del d[o1]
-        self.assertTrue(len(d) == 1)
-        self.assertTrue(d.keys() == [o2])
+        self.assertEqual(len(d), 1)
+        self.assertEqual(d.keys(), [o2])
 
     def test_weak_valued_delitem(self):
         d = weakref.WeakValueDictionary()
@@ -1215,10 +1299,10 @@
         o2 = Object('2')
         d['something'] = o1
         d['something else'] = o2
-        self.assertTrue(len(d) == 2)
+        self.assertEqual(len(d), 2)
         del d['something']
-        self.assertTrue(len(d) == 1)
-        self.assertTrue(d.items() == [('something else', o2)])
+        self.assertEqual(len(d), 1)
+        self.assertEqual(d.items(), [('something else', o2)])
 
     def test_weak_keyed_bad_delitem(self):
         d = weakref.WeakKeyDictionary()
diff -r 3a1db0d2747e Lib/test/test_weakset.py
--- a/Lib/test/test_weakset.py
+++ b/Lib/test/test_weakset.py
@@ -11,6 +11,7 @@
 import collections
 import gc
 import contextlib
+from UserString import UserString as ustr
 
 
 class Foo:
@@ -448,6 +449,59 @@
             self.assertGreaterEqual(n2, 0)
             self.assertLessEqual(n2, n1)
 
+    def test_weak_destroy_while_iterating(self):
+        # Issue #7105: iterators shouldn't crash when a key is implicitly removed
+        # Create new items to be sure no-one else holds a reference
+        items = [ustr(c) for c in ('a', 'b', 'c')]
+        s = WeakSet(items)
+        it = iter(s)
+        next(it)             # Trigger internal iteration
+        # Destroy an item
+        del items[-1]
+        gc.collect()    # just in case
+        # We have removed either the first consumed items, or another one
+        self.assertIn(len(list(it)), [len(items), len(items) - 1])
+        del it
+        # The removal has been committed
+        self.assertEqual(len(s), len(items))
+
+    def test_weak_destroy_and_mutate_while_iterating(self):
+        # Issue #7105: iterators shouldn't crash when a key is implicitly removed
+        items = [ustr(c) for c in string.ascii_letters]
+        s = WeakSet(items)
+        @contextlib.contextmanager
+        def testcontext():
+            try:
+                it = iter(s)
+                # Start iterator
+                yielded = ustr(str(next(it)))
+                # Schedule an item for removal and recreate it
+                u = ustr(str(items.pop()))
+                if yielded == u:
+                    # The iterator still has a reference to the removed item,
+                    # advance it (issue #20006).
+                    next(it)
+                gc.collect()      # just in case
+                yield u
+            finally:
+                it = None           # should commit all removals
+
+        with testcontext() as u:
+            self.assertFalse(u in s)
+        with testcontext() as u:
+            self.assertRaises(KeyError, s.remove, u)
+        self.assertFalse(u in s)
+        with testcontext() as u:
+            s.add(u)
+        self.assertTrue(u in s)
+        t = s.copy()
+        with testcontext() as u:
+            s.update(t)
+        self.assertEqual(len(s), len(t))
+        with testcontext() as u:
+            s.clear()
+        self.assertEqual(len(s), 0)
+
 
 def test_main(verbose=None):
     test_support.run_unittest(TestWeakSet)
diff -r 3a1db0d2747e Lib/test/test_winsound.py
--- a/Lib/test/test_winsound.py
+++ b/Lib/test/test_winsound.py
@@ -159,18 +159,15 @@
             )
 
     def test_alias_fallback(self):
-        # This test can't be expected to work on all systems.  The MS
-        # PlaySound() docs say:
-        #
-        #     If it cannot find the specified sound, PlaySound uses the
-        #     default system event sound entry instead.  If the function
-        #     can find neither the system default entry nor the default
-        #     sound, it makes no sound and returns FALSE.
-        #
-        # It's known to return FALSE on some real systems.
-
-        # winsound.PlaySound('!"$%&/(#+*', winsound.SND_ALIAS)
-        return
+        # In the absense of the ability to tell if a sound was actually
+        # played, this test has two acceptable outcomes: success (no error,
+        # sound was theoretically played; although as issue #19987 shows
+        # a box without a soundcard can "succeed") or RuntimeError.  Any
+        # other error is a failure.
+        try:
+            winsound.PlaySound('!"$%&/(#+*', winsound.SND_ALIAS)
+        except RuntimeError:
+            pass
 
     def test_alias_nofallback(self):
         if _have_soundcard():
diff -r 3a1db0d2747e Lib/test/test_xml_etree.py
--- a/Lib/test/test_xml_etree.py
+++ b/Lib/test/test_xml_etree.py
@@ -713,14 +713,21 @@
     end {namespace}root
     end-ns None
 
+    >>> import StringIO
+
+    >>> events = ('start-ns', 'end-ns')
+    >>> context = ET.iterparse(StringIO.StringIO(r"<root xmlns=''/>"), events)
+    >>> for action, elem in context:
+    ...   print action, elem
+    start-ns ('', '')
+    end-ns None
+
     >>> events = ("start", "end", "bogus")
     >>> with open(SIMPLE_XMLFILE, "rb") as f:
     ...     iterparse(f, events)
     Traceback (most recent call last):
     ValueError: unknown event 'bogus'
 
-    >>> import StringIO
-
     >>> source = StringIO.StringIO(
     ...     "<?xml version='1.0' encoding='iso-8859-1'?>\\n"
     ...     "<body xmlns='http://&#233;ffbot.org/ns'\\n"
diff -r 3a1db0d2747e Lib/test/test_xmlrpc.py
--- a/Lib/test/test_xmlrpc.py
+++ b/Lib/test/test_xmlrpc.py
@@ -19,6 +19,11 @@
     threading = None
 
 try:
+    import gzip
+except ImportError:
+    gzip = None
+
+try:
     unicode
 except NameError:
     have_unicode = False
@@ -681,6 +686,7 @@
 
 #A test case that verifies that gzip encoding works in both directions
 #(for a request and the response)
+@unittest.skipUnless(gzip, 'gzip not available')
 class GzipServerTestCase(BaseServerTestCase):
     #a request handler that supports keep-alive and logs requests into a
     #class variable
@@ -1011,11 +1017,7 @@
     xmlrpc_tests.append(SimpleServerTestCase)
     xmlrpc_tests.append(KeepaliveServerTestCase1)
     xmlrpc_tests.append(KeepaliveServerTestCase2)
-    try:
-        import gzip
-        xmlrpc_tests.append(GzipServerTestCase)
-    except ImportError:
-        pass #gzip not supported in this build
+    xmlrpc_tests.append(GzipServerTestCase)
     xmlrpc_tests.append(MultiPathServerTestCase)
     xmlrpc_tests.append(ServerProxyTestCase)
     xmlrpc_tests.append(FailingServerTestCase)
diff -r 3a1db0d2747e Lib/test/test_zipimport.py
--- a/Lib/test/test_zipimport.py
+++ b/Lib/test/test_zipimport.py
@@ -1,3 +1,4 @@
+import io
 import sys
 import os
 import marshal
@@ -55,6 +56,27 @@
 TEMP_ZIP = os.path.abspath("junk95142" + os.extsep + "zip")
 
 
+def _write_zip_package(zipname, files,
+                       data_to_prepend=b"", compression=ZIP_STORED):
+    z = ZipFile(zipname, "w")
+    try:
+        for name, (mtime, data) in files.items():
+            zinfo = ZipInfo(name, time.localtime(mtime))
+            zinfo.compress_type = compression
+            z.writestr(zinfo, data)
+    finally:
+        z.close()
+
+    if data_to_prepend:
+        # Prepend data to the start of the zipfile
+        with open(zipname, "rb") as f:
+            zip_data = f.read()
+
+        with open(zipname, "wb") as f:
+            f.write(data_to_prepend)
+            f.write(zip_data)
+
+
 class UncompressedZipImportTestCase(ImportHooksBaseTestCase):
 
     compression = ZIP_STORED
@@ -67,26 +89,9 @@
         ImportHooksBaseTestCase.setUp(self)
 
     def doTest(self, expected_ext, files, *modules, **kw):
-        z = ZipFile(TEMP_ZIP, "w")
+        _write_zip_package(TEMP_ZIP, files, data_to_prepend=kw.get("stuff"),
+                           compression=self.compression)
         try:
-            for name, (mtime, data) in files.items():
-                zinfo = ZipInfo(name, time.localtime(mtime))
-                zinfo.compress_type = self.compression
-                z.writestr(zinfo, data)
-            z.close()
-
-            stuff = kw.get("stuff", None)
-            if stuff is not None:
-                # Prepend 'stuff' to the start of the zipfile
-                f = open(TEMP_ZIP, "rb")
-                data = f.read()
-                f.close()
-
-                f = open(TEMP_ZIP, "wb")
-                f.write(stuff)
-                f.write(data)
-                f.close()
-
             sys.path.insert(0, TEMP_ZIP)
 
             mod = __import__(".".join(modules), globals(), locals(),
@@ -101,7 +106,6 @@
                 self.assertEqual(file, os.path.join(TEMP_ZIP,
                                  *modules) + expected_ext)
         finally:
-            z.close()
             os.remove(TEMP_ZIP)
 
     def testAFakeZlib(self):
@@ -123,7 +127,7 @@
         # so we'll simply skip it then. Bug #765456.
         #
         if "zlib" in sys.builtin_module_names:
-            return
+            self.skipTest('zlib is a builtin module')
         if "zlib" in sys.modules:
             del sys.modules["zlib"]
         files = {"zlib.py": (NOW, test_src)}
@@ -387,6 +391,64 @@
     compression = ZIP_DEFLATED
 
 
+class ZipFileModifiedAfterImportTestCase(ImportHooksBaseTestCase):
+    def setUp(self):
+        zipimport._zip_directory_cache.clear()
+        zipimport._zip_stat_cache.clear()
+        ImportHooksBaseTestCase.setUp(self)
+
+    def tearDown(self):
+        ImportHooksBaseTestCase.tearDown(self)
+        if os.path.exists(TEMP_ZIP):
+            os.remove(TEMP_ZIP)
+
+    def testZipFileChangesAfterFirstImport(self):
+        """Alter the zip file after caching its index and try an import."""
+        packdir = TESTPACK + os.sep
+        files = {packdir + "__init__" + pyc_ext: (NOW, test_pyc),
+                 packdir + TESTMOD + ".py": (NOW, "test_value = 38\n"),
+                 "ziptest_a.py": (NOW, "test_value = 23\n"),
+                 "ziptest_b.py": (NOW, "test_value = 42\n"),
+                 "ziptest_c.py": (NOW, "test_value = 1337\n")}
+        zipfile_path = TEMP_ZIP
+        _write_zip_package(zipfile_path, files)
+        self.assertTrue(os.path.exists(zipfile_path))
+        sys.path.insert(0, zipfile_path)
+
+        # Import something out of the zipfile and confirm it is correct.
+        testmod = __import__(TESTPACK + "." + TESTMOD,
+                             globals(), locals(), ["__dummy__"])
+        self.assertEqual(testmod.test_value, 38)
+        # Import something else out of the zipfile and confirm it is correct.
+        ziptest_b = __import__("ziptest_b", globals(), locals(), ["test_value"])
+        self.assertEqual(ziptest_b.test_value, 42)
+
+        # Truncate and fill the zip file with non-zip garbage.
+        with io.open(zipfile_path, "rb") as orig_zip_file:
+            orig_zip_file_contents = orig_zip_file.read()
+        with io.open(zipfile_path, "wb") as byebye_valid_zip_file:
+            byebye_valid_zip_file.write(b"Tear down this wall!\n"*1987)
+        # Now that the zipfile has been replaced, import something else from it
+        # which should fail as the file contents are now garbage.
+        with self.assertRaises(ImportError):
+            ziptest_a = __import__("ziptest_a", globals(), locals(),
+                                   ["test_value"])
+
+        # Now lets make it a valid zipfile that has some garbage at the start.
+        # This alters all of the offsets within the file
+        with io.open(zipfile_path, "wb") as new_zip_file:
+            new_zip_file.write(b"X"*1991)  # The year Python was created.
+            new_zip_file.write(orig_zip_file_contents)
+
+        # Now that the zip file has been "restored" to a valid but different
+        # zipfile the zipimporter should *successfully* re-read the new zip
+        # file's end of file central index and be able to import from it again.
+        ziptest_a = __import__("ziptest_a", globals(), locals(), ["test_value"])
+        self.assertEqual(ziptest_a.test_value, 23)
+        ziptest_c = __import__("ziptest_c", globals(), locals(), ["test_value"])
+        self.assertEqual(ziptest_c.test_value, 1337)
+
+
 class BadFileZipImportTestCase(unittest.TestCase):
     def assertZipFailure(self, filename):
         self.assertRaises(zipimport.ZipImportError,
@@ -464,6 +526,7 @@
               UncompressedZipImportTestCase,
               CompressedZipImportTestCase,
               BadFileZipImportTestCase,
+              ZipFileModifiedAfterImportTestCase,
             )
     finally:
         test_support.unlink(TESTMOD)
diff -r 3a1db0d2747e Lib/test/test_zlib.py
--- a/Lib/test/test_zlib.py
+++ b/Lib/test/test_zlib.py
@@ -12,6 +12,13 @@
 
 zlib = import_module('zlib')
 
+requires_Compress_copy = unittest.skipUnless(
+        hasattr(zlib.compressobj(), "copy"),
+        'requires Compress.copy()')
+requires_Decompress_copy = unittest.skipUnless(
+        hasattr(zlib.decompressobj(), "copy"),
+        'requires Decompress.copy()')
+
 
 class ChecksumTestCase(unittest.TestCase):
     # checksum test cases
@@ -339,39 +346,39 @@
                                         "mode=%i, level=%i") % (sync, level))
                 del obj
 
+    @unittest.skipUnless(hasattr(zlib, 'Z_SYNC_FLUSH'),
+                         'requires zlib.Z_SYNC_FLUSH')
     def test_odd_flush(self):
         # Test for odd flushing bugs noted in 2.0, and hopefully fixed in 2.1
         import random
+        # Testing on 17K of "random" data
 
-        if hasattr(zlib, 'Z_SYNC_FLUSH'):
-            # Testing on 17K of "random" data
+        # Create compressor and decompressor objects
+        co = zlib.compressobj(zlib.Z_BEST_COMPRESSION)
+        dco = zlib.decompressobj()
 
-            # Create compressor and decompressor objects
-            co = zlib.compressobj(zlib.Z_BEST_COMPRESSION)
-            dco = zlib.decompressobj()
+        # Try 17K of data
+        # generate random data stream
+        try:
+            # In 2.3 and later, WichmannHill is the RNG of the bug report
+            gen = random.WichmannHill()
+        except AttributeError:
+            try:
+                # 2.2 called it Random
+                gen = random.Random()
+            except AttributeError:
+                # others might simply have a single RNG
+                gen = random
+        gen.seed(1)
+        data = genblock(1, 17 * 1024, generator=gen)
 
-            # Try 17K of data
-            # generate random data stream
-            try:
-                # In 2.3 and later, WichmannHill is the RNG of the bug report
-                gen = random.WichmannHill()
-            except AttributeError:
-                try:
-                    # 2.2 called it Random
-                    gen = random.Random()
-                except AttributeError:
-                    # others might simply have a single RNG
-                    gen = random
-            gen.seed(1)
-            data = genblock(1, 17 * 1024, generator=gen)
+        # compress, sync-flush, and decompress
+        first = co.compress(data)
+        second = co.flush(zlib.Z_SYNC_FLUSH)
+        expanded = dco.decompress(first + second)
 
-            # compress, sync-flush, and decompress
-            first = co.compress(data)
-            second = co.flush(zlib.Z_SYNC_FLUSH)
-            expanded = dco.decompress(first + second)
-
-            # if decompressed data is different from the input data, choke.
-            self.assertEqual(expanded, data, "17K random source doesn't match")
+        # if decompressed data is different from the input data, choke.
+        self.assertEqual(expanded, data, "17K random source doesn't match")
 
     def test_empty_flush(self):
         # Test that calling .flush() on unused objects works.
@@ -408,35 +415,36 @@
         data = zlib.compress(input2)
         self.assertEqual(dco.flush(), input1[1:])
 
-    if hasattr(zlib.compressobj(), "copy"):
-        def test_compresscopy(self):
-            # Test copying a compression object
-            data0 = HAMLET_SCENE
-            data1 = HAMLET_SCENE.swapcase()
-            c0 = zlib.compressobj(zlib.Z_BEST_COMPRESSION)
-            bufs0 = []
-            bufs0.append(c0.compress(data0))
+    @requires_Compress_copy
+    def test_compresscopy(self):
+        # Test copying a compression object
+        data0 = HAMLET_SCENE
+        data1 = HAMLET_SCENE.swapcase()
+        c0 = zlib.compressobj(zlib.Z_BEST_COMPRESSION)
+        bufs0 = []
+        bufs0.append(c0.compress(data0))
 
-            c1 = c0.copy()
-            bufs1 = bufs0[:]
+        c1 = c0.copy()
+        bufs1 = bufs0[:]
 
-            bufs0.append(c0.compress(data0))
-            bufs0.append(c0.flush())
-            s0 = ''.join(bufs0)
+        bufs0.append(c0.compress(data0))
+        bufs0.append(c0.flush())
+        s0 = ''.join(bufs0)
 
-            bufs1.append(c1.compress(data1))
-            bufs1.append(c1.flush())
-            s1 = ''.join(bufs1)
+        bufs1.append(c1.compress(data1))
+        bufs1.append(c1.flush())
+        s1 = ''.join(bufs1)
 
-            self.assertEqual(zlib.decompress(s0),data0+data0)
-            self.assertEqual(zlib.decompress(s1),data0+data1)
+        self.assertEqual(zlib.decompress(s0),data0+data0)
+        self.assertEqual(zlib.decompress(s1),data0+data1)
 
-        def test_badcompresscopy(self):
-            # Test copying a compression object in an inconsistent state
-            c = zlib.compressobj()
-            c.compress(HAMLET_SCENE)
-            c.flush()
-            self.assertRaises(ValueError, c.copy)
+    @requires_Compress_copy
+    def test_badcompresscopy(self):
+        # Test copying a compression object in an inconsistent state
+        c = zlib.compressobj()
+        c.compress(HAMLET_SCENE)
+        c.flush()
+        self.assertRaises(ValueError, c.copy)
 
     def test_decompress_unused_data(self):
         # Repeated calls to decompress() after EOF should accumulate data in
@@ -463,35 +471,36 @@
                 self.assertEqual(dco.unconsumed_tail, b'')
                 self.assertEqual(dco.unused_data, remainder)
 
-    if hasattr(zlib.decompressobj(), "copy"):
-        def test_decompresscopy(self):
-            # Test copying a decompression object
-            data = HAMLET_SCENE
-            comp = zlib.compress(data)
+    @requires_Decompress_copy
+    def test_decompresscopy(self):
+        # Test copying a decompression object
+        data = HAMLET_SCENE
+        comp = zlib.compress(data)
 
-            d0 = zlib.decompressobj()
-            bufs0 = []
-            bufs0.append(d0.decompress(comp[:32]))
+        d0 = zlib.decompressobj()
+        bufs0 = []
+        bufs0.append(d0.decompress(comp[:32]))
 
-            d1 = d0.copy()
-            bufs1 = bufs0[:]
+        d1 = d0.copy()
+        bufs1 = bufs0[:]
 
-            bufs0.append(d0.decompress(comp[32:]))
-            s0 = ''.join(bufs0)
+        bufs0.append(d0.decompress(comp[32:]))
+        s0 = ''.join(bufs0)
 
-            bufs1.append(d1.decompress(comp[32:]))
-            s1 = ''.join(bufs1)
+        bufs1.append(d1.decompress(comp[32:]))
+        s1 = ''.join(bufs1)
 
-            self.assertEqual(s0,s1)
-            self.assertEqual(s0,data)
+        self.assertEqual(s0,s1)
+        self.assertEqual(s0,data)
 
-        def test_baddecompresscopy(self):
-            # Test copying a compression object in an inconsistent state
-            data = zlib.compress(HAMLET_SCENE)
-            d = zlib.decompressobj()
-            d.decompress(data)
-            d.flush()
-            self.assertRaises(ValueError, d.copy)
+    @requires_Decompress_copy
+    def test_baddecompresscopy(self):
+        # Test copying a compression object in an inconsistent state
+        data = zlib.compress(HAMLET_SCENE)
+        d = zlib.decompressobj()
+        d.decompress(data)
+        d.flush()
+        self.assertRaises(ValueError, d.copy)
 
     # Memory use of the following functions takes into account overallocation
 
diff -r 3a1db0d2747e Lib/tokenize.py
--- a/Lib/tokenize.py
+++ b/Lib/tokenize.py
@@ -263,7 +263,7 @@
 
 def generate_tokens(readline):
     """
-    The generate_tokens() generator requires one argment, readline, which
+    The generate_tokens() generator requires one argument, readline, which
     must be a callable object which provides the same interface as the
     readline() method of built-in file objects. Each call to the function
     should return one line of input as a string.  Alternately, readline
diff -r 3a1db0d2747e Lib/unittest/test/test_case.py
--- a/Lib/unittest/test/test_case.py
+++ b/Lib/unittest/test/test_case.py
@@ -293,7 +293,7 @@
             def test(self):
                 pass
 
-        self.assertTrue(Foo('test').failureException is AssertionError)
+        self.assertIs(Foo('test').failureException, AssertionError)
 
     # "This class attribute gives the exception raised by the test() method.
     # If a test framework needs to use a specialized exception, possibly to
@@ -311,7 +311,7 @@
 
             failureException = RuntimeError
 
-        self.assertTrue(Foo('test').failureException is RuntimeError)
+        self.assertIs(Foo('test').failureException, RuntimeError)
 
 
         Foo('test').run(result)
@@ -334,7 +334,7 @@
 
             failureException = RuntimeError
 
-        self.assertTrue(Foo('test').failureException is RuntimeError)
+        self.assertIs(Foo('test').failureException, RuntimeError)
 
 
         Foo('test').run(result)
@@ -607,7 +607,7 @@
             msg = e.args[0]
         else:
             self.fail('assertSequenceEqual did not fail.')
-        self.assertTrue(len(msg) < len(diff))
+        self.assertLess(len(msg), len(diff))
         self.assertIn(omitted, msg)
 
         self.maxDiff = len(diff) * 2
@@ -617,7 +617,7 @@
             msg = e.args[0]
         else:
             self.fail('assertSequenceEqual did not fail.')
-        self.assertTrue(len(msg) > len(diff))
+        self.assertGreater(len(msg), len(diff))
         self.assertNotIn(omitted, msg)
 
         self.maxDiff = None
@@ -627,7 +627,7 @@
             msg = e.args[0]
         else:
             self.fail('assertSequenceEqual did not fail.')
-        self.assertTrue(len(msg) > len(diff))
+        self.assertGreater(len(msg), len(diff))
         self.assertNotIn(omitted, msg)
 
     def testTruncateMessage(self):
diff -r 3a1db0d2747e Lib/unittest/test/test_loader.py
--- a/Lib/unittest/test/test_loader.py
+++ b/Lib/unittest/test/test_loader.py
@@ -1279,7 +1279,7 @@
     # "The default value is the TestSuite class"
     def test_suiteClass__default_value(self):
         loader = unittest.TestLoader()
-        self.assertTrue(loader.suiteClass is unittest.TestSuite)
+        self.assertIs(loader.suiteClass, unittest.TestSuite)
 
     # Make sure the dotted name resolution works even if the actual
     # function doesn't have the same name as is used to find it.
diff -r 3a1db0d2747e Lib/unittest/test/test_result.py
--- a/Lib/unittest/test/test_result.py
+++ b/Lib/unittest/test/test_result.py
@@ -176,7 +176,7 @@
         self.assertEqual(result.shouldStop, False)
 
         test_case, formatted_exc = result.failures[0]
-        self.assertTrue(test_case is test)
+        self.assertIs(test_case, test)
         self.assertIsInstance(formatted_exc, str)
 
     # "addError(test, err)"
@@ -224,7 +224,7 @@
         self.assertEqual(result.shouldStop, False)
 
         test_case, formatted_exc = result.errors[0]
-        self.assertTrue(test_case is test)
+        self.assertIs(test_case, test)
         self.assertIsInstance(formatted_exc, str)
 
     def testGetDescriptionWithoutDocstring(self):
diff -r 3a1db0d2747e Lib/uuid.py
--- a/Lib/uuid.py
+++ b/Lib/uuid.py
@@ -293,25 +293,38 @@
 
 def _find_mac(command, args, hw_identifiers, get_index):
     import os
-    for dir in ['', '/sbin/', '/usr/sbin']:
+    path = os.environ.get("PATH", os.defpath).split(os.pathsep)
+    path.extend(('/sbin', '/usr/sbin'))
+    for dir in path:
         executable = os.path.join(dir, command)
-        if not os.path.exists(executable):
-            continue
+        if (os.path.exists(executable) and
+            os.access(executable, os.F_OK | os.X_OK) and
+            not os.path.isdir(executable)):
+            break
+    else:
+        return None
 
-        try:
-            # LC_ALL to get English output, 2>/dev/null to
-            # prevent output on stderr
-            cmd = 'LC_ALL=C %s %s 2>/dev/null' % (executable, args)
-            with os.popen(cmd) as pipe:
-                for line in pipe:
-                    words = line.lower().split()
-                    for i in range(len(words)):
-                        if words[i] in hw_identifiers:
+    try:
+        # LC_MESSAGES to get English output, 2>/dev/null to
+        # prevent output on stderr
+        cmd = 'LC_MESSAGES=C %s %s 2>/dev/null' % (executable, args)
+        with os.popen(cmd) as pipe:
+            for line in pipe:
+                words = line.lower().split()
+                for i in range(len(words)):
+                    if words[i] in hw_identifiers:
+                        try:
                             return int(
                                 words[get_index(i)].replace(':', ''), 16)
-        except IOError:
-            continue
-    return None
+                        except (ValueError, IndexError):
+                            # Virtual interfaces, such as those provided by
+                            # VPNs, do not have a colon-delimited MAC address
+                            # as expected, but a 16-byte HWAddr separated by
+                            # dashes. These should be ignored in favor of a
+                            # real MAC address
+                            pass
+    except IOError:
+        pass
 
 def _ifconfig_getnode():
     """Get the hardware address on Unix by running ifconfig."""
diff -r 3a1db0d2747e Lib/wave.py
--- a/Lib/wave.py
+++ b/Lib/wave.py
@@ -82,14 +82,15 @@
 
 _array_fmts = None, 'b', 'h', None, 'i'
 
-# Determine endian-ness
 import struct
-if struct.pack("h", 1) == "\000\001":
-    big_endian = 1
-else:
-    big_endian = 0
+import sys
+from chunk import Chunk
 
-from chunk import Chunk
+def _byteswap3(data):
+    ba = bytearray(data)
+    ba[::3] = data[2::3]
+    ba[2::3] = data[::3]
+    return bytes(ba)
 
 class Wave_read:
     """Variables used in this class:
@@ -231,7 +232,7 @@
             self._data_seek_needed = 0
         if nframes == 0:
             return ''
-        if self._sampwidth > 1 and big_endian:
+        if self._sampwidth in (2, 4) and sys.byteorder == 'big':
             # unfortunately the fromfile() method does not take
             # something that only looks like a file object, so
             # we have to reach into the innards of the chunk object
@@ -252,6 +253,8 @@
             data = data.tostring()
         else:
             data = self._data_chunk.read(nframes * self._framesize)
+            if self._sampwidth == 3 and sys.byteorder == 'big':
+                data = _byteswap3(data)
         if self._convert and data:
             data = self._convert(data)
         self._soundpos = self._soundpos + len(data) // (self._nchannels * self._sampwidth)
@@ -419,14 +422,18 @@
         nframes = len(data) // (self._sampwidth * self._nchannels)
         if self._convert:
             data = self._convert(data)
-        if self._sampwidth > 1 and big_endian:
+        if self._sampwidth in (2, 4) and sys.byteorder == 'big':
             import array
-            data = array.array(_array_fmts[self._sampwidth], data)
+            a = array.array(_array_fmts[self._sampwidth])
+            a.fromstring(data)
+            data = a
             assert data.itemsize == self._sampwidth
             data.byteswap()
             data.tofile(self._file)
             self._datawritten = self._datawritten + len(data) * self._sampwidth
         else:
+            if self._sampwidth == 3 and sys.byteorder == 'big':
+                data = _byteswap3(data)
             self._file.write(data)
             self._datawritten = self._datawritten + len(data)
         self._nframeswritten = self._nframeswritten + nframes
diff -r 3a1db0d2747e Lib/weakref.py
--- a/Lib/weakref.py
+++ b/Lib/weakref.py
@@ -20,7 +20,7 @@
      ProxyType,
      ReferenceType)
 
-from _weakrefset import WeakSet
+from _weakrefset import WeakSet, _IterationGuard
 
 from exceptions import ReferenceError
 
@@ -48,10 +48,24 @@
         def remove(wr, selfref=ref(self)):
             self = selfref()
             if self is not None:
-                del self.data[wr.key]
+                if self._iterating:
+                    self._pending_removals.append(wr.key)
+                else:
+                    del self.data[wr.key]
         self._remove = remove
+        # A list of keys to be removed
+        self._pending_removals = []
+        self._iterating = set()
         UserDict.UserDict.__init__(self, *args, **kw)
 
+    def _commit_removals(self):
+        l = self._pending_removals
+        d = self.data
+        # We shouldn't encounter any KeyError, because this method should
+        # always be called *before* mutating the dict.
+        while l:
+            del d[l.pop()]
+
     def __getitem__(self, key):
         o = self.data[key]()
         if o is None:
@@ -59,6 +73,11 @@
         else:
             return o
 
+    def __delitem__(self, key):
+        if self._pending_removals:
+            self._commit_removals()
+        del self.data[key]
+
     def __contains__(self, key):
         try:
             o = self.data[key]()
@@ -77,8 +96,15 @@
         return "<WeakValueDictionary at %s>" % id(self)
 
     def __setitem__(self, key, value):
+        if self._pending_removals:
+            self._commit_removals()
         self.data[key] = KeyedRef(value, self._remove, key)
 
+    def clear(self):
+        if self._pending_removals:
+            self._commit_removals()
+        self.data.clear()
+
     def copy(self):
         new = WeakValueDictionary()
         for key, wr in self.data.items():
@@ -120,16 +146,18 @@
         return L
 
     def iteritems(self):
-        for wr in self.data.itervalues():
-            value = wr()
-            if value is not None:
-                yield wr.key, value
+        with _IterationGuard(self):
+            for wr in self.data.itervalues():
+                value = wr()
+                if value is not None:
+                    yield wr.key, value
 
     def iterkeys(self):
-        return self.data.iterkeys()
+        with _IterationGuard(self):
+            for k in self.data.iterkeys():
+                yield k
 
-    def __iter__(self):
-        return self.data.iterkeys()
+    __iter__ = iterkeys
 
     def itervaluerefs(self):
         """Return an iterator that yields the weak references to the values.
@@ -141,15 +169,20 @@
         keep the values around longer than needed.
 
         """
-        return self.data.itervalues()
+        with _IterationGuard(self):
+            for wr in self.data.itervalues():
+                yield wr
 
     def itervalues(self):
-        for wr in self.data.itervalues():
-            obj = wr()
-            if obj is not None:
-                yield obj
+        with _IterationGuard(self):
+            for wr in self.data.itervalues():
+                obj = wr()
+                if obj is not None:
+                    yield obj
 
     def popitem(self):
+        if self._pending_removals:
+            self._commit_removals()
         while 1:
             key, wr = self.data.popitem()
             o = wr()
@@ -157,6 +190,8 @@
                 return key, o
 
     def pop(self, key, *args):
+        if self._pending_removals:
+            self._commit_removals()
         try:
             o = self.data.pop(key)()
         except KeyError:
@@ -172,12 +207,16 @@
         try:
             wr = self.data[key]
         except KeyError:
+            if self._pending_removals:
+                self._commit_removals()
             self.data[key] = KeyedRef(default, self._remove, key)
             return default
         else:
             return wr()
 
     def update(self, dict=None, **kwargs):
+        if self._pending_removals:
+            self._commit_removals()
         d = self.data
         if dict is not None:
             if not hasattr(dict, "items"):
@@ -245,9 +284,29 @@
         def remove(k, selfref=ref(self)):
             self = selfref()
             if self is not None:
-                del self.data[k]
+                if self._iterating:
+                    self._pending_removals.append(k)
+                else:
+                    del self.data[k]
         self._remove = remove
-        if dict is not None: self.update(dict)
+        # A list of dead weakrefs (keys to be removed)
+        self._pending_removals = []
+        self._iterating = set()
+        if dict is not None:
+            self.update(dict)
+
+    def _commit_removals(self):
+        # NOTE: We don't need to call this method before mutating the dict,
+        # because a dead weakref never compares equal to a live weakref,
+        # even if they happened to refer to equal objects.
+        # However, it means keys may already have been removed.
+        l = self._pending_removals
+        d = self.data
+        while l:
+            try:
+                del d[l.pop()]
+            except KeyError:
+                pass
 
     def __delitem__(self, key):
         del self.data[ref(key)]
@@ -306,10 +365,11 @@
         return L
 
     def iteritems(self):
-        for wr, value in self.data.iteritems():
-            key = wr()
-            if key is not None:
-                yield key, value
+        with _IterationGuard(self):
+            for wr, value in self.data.iteritems():
+                key = wr()
+                if key is not None:
+                    yield key, value
 
     def iterkeyrefs(self):
         """Return an iterator that yields the weak references to the keys.
@@ -321,19 +381,23 @@
         keep the keys around longer than needed.
 
         """
-        return self.data.iterkeys()
+        with _IterationGuard(self):
+            for wr in self.data.iterkeys():
+                yield wr
 
     def iterkeys(self):
-        for wr in self.data.iterkeys():
-            obj = wr()
-            if obj is not None:
-                yield obj
+        with _IterationGuard(self):
+            for wr in self.data.iterkeys():
+                obj = wr()
+                if obj is not None:
+                    yield obj
 
-    def __iter__(self):
-        return self.iterkeys()
+    __iter__ = iterkeys
 
     def itervalues(self):
-        return self.data.itervalues()
+        with _IterationGuard(self):
+            for value in self.data.itervalues():
+                yield value
 
     def keyrefs(self):
         """Return a list of weak references to the keys.
diff -r 3a1db0d2747e Lib/zipfile.py
--- a/Lib/zipfile.py
+++ b/Lib/zipfile.py
@@ -606,7 +606,11 @@
         """Returns buffered bytes without advancing the position."""
         if n > len(self._readbuffer) - self._offset:
             chunk = self.read(n)
-            self._offset -= len(chunk)
+            if len(chunk) > self._offset:
+                self._readbuffer = chunk + self._readbuffer[self._offset:]
+                self._offset = 0
+            else:
+                self._offset -= len(chunk)
 
         # Return up to 512 bytes to reduce allocation overhead for tight loops.
         return self._readbuffer[self._offset: self._offset + 512]
diff -r 3a1db0d2747e Mac/IDLE/Info.plist.in
--- a/Mac/IDLE/Info.plist.in
+++ b/Mac/IDLE/Info.plist.in
@@ -36,7 +36,7 @@
 	<key>CFBundleExecutable</key>
 	<string>IDLE</string>
 	<key>CFBundleGetInfoString</key>
-	<string>%VERSION%, © 2001-2013 Python Software Foundation</string>
+	<string>%VERSION%, © 2001-2014 Python Software Foundation</string>
 	<key>CFBundleIconFile</key>
 	<string>IDLE.icns</string>
 	<key>CFBundleIdentifier</key>
diff -r 3a1db0d2747e Mac/PythonLauncher/Info.plist.in
--- a/Mac/PythonLauncher/Info.plist.in
+++ b/Mac/PythonLauncher/Info.plist.in
@@ -40,7 +40,7 @@
 	<key>CFBundleExecutable</key>
 	<string>PythonLauncher</string>
 	<key>CFBundleGetInfoString</key>
-	<string>%VERSION%, © 2001-2013 Python Software Foundation</string>
+	<string>%VERSION%, © 2001-2014 Python Software Foundation</string>
 	<key>CFBundleIconFile</key>
 	<string>PythonLauncher.icns</string>
 	<key>CFBundleIdentifier</key>
diff -r 3a1db0d2747e Mac/Resources/app/Info.plist.in
--- a/Mac/Resources/app/Info.plist.in
+++ b/Mac/Resources/app/Info.plist.in
@@ -20,7 +20,7 @@
 	<key>CFBundleExecutable</key>
 	<string>Python</string>
 	<key>CFBundleGetInfoString</key>
-	<string>%version%, (c) 2004-2013 Python Software Foundation.</string>
+	<string>%version%, (c) 2004-2014 Python Software Foundation.</string>
 	<key>CFBundleHelpBookFolder</key>
 	<array>
 		<string>Documentation</string>
@@ -37,7 +37,7 @@
 	<key>CFBundleInfoDictionaryVersion</key>
 	<string>6.0</string>
 	<key>CFBundleLongVersionString</key>
-	<string>%version%, (c) 2004-2013 Python Software Foundation.</string>
+	<string>%version%, (c) 2004-2014 Python Software Foundation.</string>
 	<key>CFBundleName</key>
 	<string>Python</string>
 	<key>CFBundlePackageType</key>
@@ -55,7 +55,7 @@
 	<key>NSAppleScriptEnabled</key>
 	<true/>
 	<key>NSHumanReadableCopyright</key>
-	<string>(c) 2013 Python Software Foundation.</string>
+	<string>(c) 2014 Python Software Foundation.</string>
 	<key>NSHighResolutionCapable</key>
 	<true/>
 </dict>
diff -r 3a1db0d2747e Mac/Resources/framework/Info.plist.in
--- a/Mac/Resources/framework/Info.plist.in
+++ b/Mac/Resources/framework/Info.plist.in
@@ -17,9 +17,9 @@
 	<key>CFBundlePackageType</key>
 	<string>FMWK</string>
 	<key>CFBundleShortVersionString</key>
-	<string>%VERSION%, (c) 2004-2013 Python Software Foundation.</string>
+	<string>%VERSION%, (c) 2004-2014 Python Software Foundation.</string>
 	<key>CFBundleLongVersionString</key>
-	<string>%VERSION%, (c) 2004-2013 Python Software Foundation.</string>
+	<string>%VERSION%, (c) 2004-2014 Python Software Foundation.</string>
 	<key>CFBundleSignature</key>
 	<string>????</string>
 	<key>CFBundleVersion</key>
diff -r 3a1db0d2747e Makefile.pre.in
--- a/Makefile.pre.in
+++ b/Makefile.pre.in
@@ -750,7 +750,8 @@
 		Include/warnings.h \
 		Include/weakrefobject.h \
 		pyconfig.h \
-		$(PARSER_HEADERS)
+		$(PARSER_HEADERS) \
+		$(AST_H)
 
 $(LIBRARY_OBJS) $(MODOBJS) Modules/python.o: $(PYTHON_HEADERS)
 
@@ -939,7 +940,8 @@
 		logging bsddb bsddb/test csv importlib wsgiref \
 		lib2to3 lib2to3/fixes lib2to3/pgen2 lib2to3/tests \
 		lib2to3/tests/data lib2to3/tests/data/fixers lib2to3/tests/data/fixers/myfixes \
-		ctypes ctypes/test ctypes/macholib idlelib idlelib/Icons \
+		ctypes ctypes/test ctypes/macholib \
+		idlelib idlelib/Icons idlelib/idle_test \
 		distutils distutils/command distutils/tests $(XMLLIBSUBDIRS) \
 		multiprocessing multiprocessing/dummy \
 		unittest unittest/test \
diff -r 3a1db0d2747e Misc/ACKS
--- a/Misc/ACKS
+++ b/Misc/ACKS
@@ -324,6 +324,7 @@
 John Fouhy
 Stefan Franke
 Martin Franklin
+Kent Frazier
 Bruce Frederiksen
 Robin Friedrich
 Bradley Froehle
@@ -356,12 +357,14 @@
 Thomas Gellekum
 Gabriel Genellina
 Christos Georgiou
+Elazar Gershuni
 Ben Gertzfield
 Nadim Ghaznavi
 Dinu Gherman
 Jonathan Giddy
 Johannes Gijsbers
 Michael Gilfix
+Julian Gindi
 Wim Glenn
 Christoph Gohlke
 Tim Golden
@@ -378,6 +381,7 @@
 Dag Gruneau
 Filip Gruszczyński
 Thomas Guettler
+Ajitesh Gupta
 Michael Guravage
 Lars Gustäbel
 Thomas Güttler
@@ -708,6 +712,7 @@
 Dom Mitchell
 Florian Mladitsch
 Doug Moen
+Jaakko Moisio
 The Dragon De Monsyne
 Skip Montanaro
 Paul Moore
@@ -901,6 +906,7 @@
 Rich Salz
 Kevin Samborn
 Ilya Sandler
+Simon Sapin
 Mark Sapiro
 Ty Sarna
 Hugh Sasse
diff -r 3a1db0d2747e Misc/NEWS
--- a/Misc/NEWS
+++ b/Misc/NEWS
@@ -1,6 +1,205 @@
 Python News
 +++++++++++
 
+What's New in Python 2.7.7?
+===========================
+
+*Release date: XXXX-XX-XX*
+
+Core and Builtins
+-----------------
+
+- Issue #19081: When a zipimport .zip file in sys.path being imported from
+  is modified during the lifetime of the Python process after zipimport has
+  already cached the zip's table of contents we detect this and recover
+  rather than read bad data from the .zip (causing odd import errors).
+
+- Raise a better error when non-unicode codecs are used for a file's coding
+  cookie.
+
+- Issue #17976: Fixed potential problem with file.write() not detecting IO error
+  by inspecting the return value of fwrite().  Based on patches by Jaakko Moisio
+  and Victor Stinner.
+
+- Issue #14432: Generator now clears the borrowed reference to the thread
+  state. Fix a crash when a generator is created in a C thread that is
+  destroyed while the generator is still used. The issue was that a generator
+  contains a frame, and the frame kept a reference to the Python state of the
+  destroyed C thread. The crash occurs when a trace function is setup.
+
+- Issue #19932: Fix typo in import.h, missing whitespaces in function prototypes.
+
+- Issue #19638: Fix possible crash / undefined behaviour from huge (more than 2
+  billion characters) input strings in _Py_dg_strtod.
+
+Library
+-------
+
+- Issue #13107: argparse and optparse no longer raises an exception when output
+  a help on environment with too small COLUMNS.  Based on patch by
+  Elazar Gershuni.
+
+- Issue #20207: Always disable SSLv2 except when PROTOCOL_SSLv2 is explicitly
+  asked for.
+
+- Issue #20072: Fixed multiple errors in tkinter with wantobjects is False.
+
+- Issue #1065986: pydoc can now handle unicode strings.
+
+- Issue #16039: CVE-2013-1752: Change use of readline in imaplib module to
+  limit line length.  Patch by Emil Lind.
+
+- Issue #19422: Explicitly disallow non-SOCK_STREAM sockets in the ssl
+  module, rather than silently let them emit clear text data.
+
+- Issue #20027: Fixed locale aliases for devanagari locales.
+
+- Issue #20067: Tkinter variables now work when wantobjects is false.
+
+- Issue #19020: Tkinter now uses splitlist() instead of split() in configure
+  methods.
+
+- Issue #12226: HTTPS is now used by default when connecting to PyPI.
+
+- Issue #20048: Fixed ZipExtFile.peek() when it is called on the boundary of
+  the uncompress buffer and read() goes through more than one readbuffer.
+
+- Issue #20034: Updated alias mapping to most recent locale.alias file
+  from X.org distribution using makelocalealias.py.
+
+- Issue #5815: Fixed support for locales with modifiers.  Fixed support for
+  locale encodings with hyphens.
+
+- Issue #20026: Fix the sqlite module to handle correctly invalid isolation
+  level (wrong type).
+
+- Issue #18829: csv.Dialect() now checks type for delimiter, escapechar and
+  quotechar fields.  Original patch by Vajrasky Kok.
+
+- Issue #19855: uuid.getnode() on Unix now looks on the PATH for the
+  executables used to find the mac address, with /sbin and /usr/sbin as
+  fallbacks.
+
+- Issue #20007: HTTPResponse.read(0) no more prematurely closes connection.
+  Original patch by Simon Sapin.
+
+- Issue #19912: Fixed numerous bugs in ntpath.splitunc().
+
+- Issue #19623: Fixed writing to unseekable files in the aifc module.
+  Fixed writing 'ulaw' (lower case) compressed AIFC files.
+
+- Issue #17919: select.poll.register() again works with poll.POLLNVAL on AIX.
+  Fixed integer overflow in the eventmask parameter.
+
+- Issue #17200: telnetlib's read_until and expect timeout was broken by the
+  fix to Issue #14635 in Python 2.7.4 to be interpreted as milliseconds
+  instead of seconds when the platform supports select.poll (ie: everywhere).
+  It is now treated as seconds once again.
+
+- Issue #19099: The struct module now supports Unicode format strings.
+
+- Issue #19878: Fix segfault in bz2 module after calling __init__ twice with
+  non-existent filename. Initial patch by Vajrasky Kok.
+
+- Issue #16373: Prevent infinite recursion for ABC Set class comparisons.
+
+- Issue #19138: doctest's IGNORE_EXCEPTION_DETAIL now allows a match when
+  no exception detail exists (no colon following the exception's name, or
+  a colon does follow but no text follows the colon).
+
+- Issue #16231: Fixed pickle.Pickler to only fallback to its default pickling
+  behaviour when Pickler.persistent_id returns None, but not for any other
+  false values.  This allows false values other than None to be used as
+  persistent IDs.  This behaviour is consistent with cPickle.
+
+- Issue #11508: Fixed uuid.getnode() and uuid.uuid1() on environment with
+  virtual interface.  Original patch by Kent Frazier.
+
+- Issue #11489: JSON decoder now accepts lone surrogates.
+
+- Fix test.test_support.bind_port() to not cause an error when Python was
+  compiled on a system with SO_REUSEPORT defined in the headers but run on
+  a system with an OS kernel that does not support that new socket option.
+
+- Issue #19633: Fixed writing not compressed 16- and 32-bit wave files on
+  big-endian platforms.
+
+- Issue #19449: in csv's writerow, handle non-string keys when generating the
+  error message that certain keys are not in the 'fieldnames' list.
+
+- Issue #12853: Fix NameError in distutils.command.upload.
+
+- Issue #19523: Closed FileHandler leak which occurred when delay was set.
+
+- Issue #1575020: Fixed support of 24-bit wave files on big-endian platforms.
+
+- Issue #19480: HTMLParser now accepts all valid start-tag names as defined
+  by the HTML5 standard.
+
+- Issue #17827: Add the missing documentation for ``codecs.encode`` and
+  ``codecs.decode``.
+
+- Issue #6157: Fixed Tkinter.Text.debug().  Original patch by Guilherme Polo.
+
+- Issue #6160: The bbox() method of tkinter.Spinbox now returns a tuple of
+  integers instead of a string.  Based on patch by Guilherme Polo.
+
+- Issue #19286: Directories in ``package_data`` are no longer added to
+  the filelist, preventing failure outlined in the ticket.
+
+IDLE
+----
+
+- Issue #20058: sys.stdin.readline() in IDLE now always returns only one line.
+
+- Issue #19481: print() of unicode, str or bytearray subclass instance in IDLE
+  no more hangs.
+
+- Issue #18270: Prevent possible IDLE AttributeError on OS X when no initial
+  shell window is present.
+
+Tests
+-----
+
+- Issue #19804: The test_find_mac test in test_uuid is now skipped if the
+  ifconfig executable is not available.
+
+- Issue #19886: Use better estimated memory requirements for bigmem tests.
+
+- Backported tests for Tkinter variables.
+
+- Issue #19320: test_tcl no longer fails when wantobjects is false.
+
+- Issue #19683: Removed empty tests from test_minidom.  Initial patch by
+  Ajitesh Gupta.
+
+- Issue #19928: Implemented a test for repr() of cell objects.
+
+- Issue #19595, #19987: Re-enabled a long-disabled test in test_winsound.
+
+- Issue #19588: Fixed tests in test_random that were silently skipped most
+  of the time.  Patch by Julian Gindi.
+
+- Issue #17883: Tweak test_tcl testLoadWithUNC to skip the test in the
+  event of a permission error on Windows and to properly report other
+  skip conditions.
+
+- Issue #17883: Backported _is_gui_available() in test.test_support to
+  avoid hanging Windows buildbots on test_ttk_guionly.
+
+- Issue #18702, #19572: All skipped tests now reported as skipped.
+
+- Issue #19085: Added basic tests for all tkinter widget options.
+
+Documentation
+-------------
+
+- Issue #18840: Introduce the json module in the tutorial, and deemphasize
+  the pickle module.
+
+- Issue #19795: Improved markup of True/False constants.
+
+
 Whats' New in Python 2.7.6?
 ===========================
 
diff -r 3a1db0d2747e Modules/_csv.c
--- a/Modules/_csv.c
+++ b/Modules/_csv.c
@@ -239,19 +239,24 @@
     if (src == NULL)
         *target = dflt;
     else {
-        if (src == Py_None || PyString_Size(src) == 0)
-            *target = '\0';
-        else if (!PyString_Check(src) || PyString_Size(src) != 1) {
-            PyErr_Format(PyExc_TypeError,
-                         "\"%s\" must be an 1-character string",
-                         name);
-            return -1;
-        }
-        else {
-            char *s = PyString_AsString(src);
-            if (s == NULL)
+        *target = '\0';
+        if (src != Py_None) {
+            Py_ssize_t len;
+            if (!PyString_Check(src)) {
+                PyErr_Format(PyExc_TypeError,
+                    "\"%s\" must be string, not %.200s", name,
+                    src->ob_type->tp_name);
                 return -1;
-            *target = s[0];
+            }
+            len = PyString_GET_SIZE(src);
+            if (len > 1) {
+                PyErr_Format(PyExc_TypeError,
+                    "\"%s\" must be an 1-character string",
+                    name);
+                return -1;
+            }
+            if (len > 0)
+                *target = *PyString_AS_STRING(src);
         }
     }
     return 0;
@@ -267,7 +272,7 @@
             *target = NULL;
         else if (!IS_BASESTRING(src)) {
             PyErr_Format(PyExc_TypeError,
-                         "\"%s\" must be an string", name);
+                         "\"%s\" must be a string", name);
             return -1;
         }
         else {
@@ -426,7 +431,8 @@
     if (dialect_check_quoting(self->quoting))
         goto err;
     if (self->delimiter == 0) {
-        PyErr_SetString(PyExc_TypeError, "delimiter must be set");
+        PyErr_SetString(PyExc_TypeError,
+                        "\"delimiter\" must be an 1-character string");
         goto err;
     }
     if (quotechar == Py_None && quoting == NULL)
diff -r 3a1db0d2747e Modules/_elementtree.c
--- a/Modules/_elementtree.c
+++ b/Modules/_elementtree.c
@@ -2338,7 +2338,10 @@
     PyObject* sprefix = NULL;
     PyObject* suri = NULL;
 
-    suri = makestring(uri, strlen(uri));
+    if (uri)
+        suri = makestring(uri, strlen(uri));
+    else
+        suri = PyString_FromStringAndSize("", 0);
     if (!suri)
         return;
 
diff -r 3a1db0d2747e Modules/_json.c
--- a/Modules/_json.c
+++ b/Modules/_json.c
@@ -524,16 +524,10 @@
             }
 #ifdef Py_UNICODE_WIDE
             /* Surrogate pair */
-            if ((c & 0xfc00) == 0xd800) {
+            if ((c & 0xfc00) == 0xd800 && end + 6 < len &&
+                buf[next++] == '\\' &&
+                buf[next++] == 'u') {
                 Py_UNICODE c2 = 0;
-                if (end + 6 >= len) {
-                    raise_errmsg("Unpaired high surrogate", pystr, end - 5);
-                    goto bail;
-                }
-                if (buf[next++] != '\\' || buf[next++] != 'u') {
-                    raise_errmsg("Unpaired high surrogate", pystr, end - 5);
-                    goto bail;
-                }
                 end += 6;
                 /* Decode 4 hex digits */
                 for (; next < end; next++) {
@@ -554,15 +548,10 @@
                             goto bail;
                     }
                 }
-                if ((c2 & 0xfc00) != 0xdc00) {
-                    raise_errmsg("Unpaired high surrogate", pystr, end - 5);
-                    goto bail;
-                }
-                c = 0x10000 + (((c - 0xd800) << 10) | (c2 - 0xdc00));
-            }
-            else if ((c & 0xfc00) == 0xdc00) {
-                raise_errmsg("Unpaired low surrogate", pystr, end - 5);
-                goto bail;
+                if ((c2 & 0xfc00) == 0xdc00)
+                    c = 0x10000 + (((c - 0xd800) << 10) | (c2 - 0xdc00));
+                else
+                    end -= 6;
             }
 #endif
         }
@@ -703,16 +692,9 @@
             }
 #ifdef Py_UNICODE_WIDE
             /* Surrogate pair */
-            if ((c & 0xfc00) == 0xd800) {
+            if ((c & 0xfc00) == 0xd800 && end + 6 < len &&
+                buf[next++] == '\\' && buf[next++] == 'u') {
                 Py_UNICODE c2 = 0;
-                if (end + 6 >= len) {
-                    raise_errmsg("Unpaired high surrogate", pystr, end - 5);
-                    goto bail;
-                }
-                if (buf[next++] != '\\' || buf[next++] != 'u') {
-                    raise_errmsg("Unpaired high surrogate", pystr, end - 5);
-                    goto bail;
-                }
                 end += 6;
                 /* Decode 4 hex digits */
                 for (; next < end; next++) {
@@ -733,15 +715,10 @@
                             goto bail;
                     }
                 }
-                if ((c2 & 0xfc00) != 0xdc00) {
-                    raise_errmsg("Unpaired high surrogate", pystr, end - 5);
-                    goto bail;
-                }
-                c = 0x10000 + (((c - 0xd800) << 10) | (c2 - 0xdc00));
-            }
-            else if ((c & 0xfc00) == 0xdc00) {
-                raise_errmsg("Unpaired low surrogate", pystr, end - 5);
-                goto bail;
+                if ((c2 & 0xfc00) == 0xdc00)
+                    c = 0x10000 + (((c - 0xd800) << 10) | (c2 - 0xdc00));
+                else
+                    end -= 6;
             }
 #endif
         }
diff -r 3a1db0d2747e Modules/_sqlite/connection.c
--- a/Modules/_sqlite/connection.c
+++ b/Modules/_sqlite/connection.c
@@ -152,7 +152,10 @@
         Py_INCREF(isolation_level);
     }
     self->isolation_level = NULL;
-    pysqlite_connection_set_isolation_level(self, isolation_level);
+    if (pysqlite_connection_set_isolation_level(self, isolation_level) < 0) {
+        Py_DECREF(isolation_level);
+        return -1;
+    }
     Py_DECREF(isolation_level);
 
     self->statement_cache = (pysqlite_Cache*)PyObject_CallFunction((PyObject*)&pysqlite_CacheType, "Oi", self, cached_statements);
diff -r 3a1db0d2747e Modules/_sre.c
--- a/Modules/_sre.c
+++ b/Modules/_sre.c
@@ -2753,8 +2753,7 @@
     \_________\_____/        /
                \____________/
 
-   It also helps that SRE_CODE is always an unsigned type, either 2 bytes or 4
-   bytes wide (the latter if Python is compiled for "wide" unicode support).
+   It also helps that SRE_CODE is always an unsigned type.
 */
 
 /* Defining this one enables tracing of the validator */
diff -r 3a1db0d2747e Modules/_ssl.c
--- a/Modules/_ssl.c
+++ b/Modules/_ssl.c
@@ -273,6 +273,7 @@
     char *errstr = NULL;
     int ret;
     int verification_mode;
+    long options;
 
     self = PyObject_New(PySSLObject, &PySSL_Type); /* Create new object */
     if (self == NULL)
@@ -372,8 +373,10 @@
     }
 
     /* ssl compatibility */
-    SSL_CTX_set_options(self->ctx,
-                        SSL_OP_ALL & ~SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS);
+    options = SSL_OP_ALL & ~SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS;
+    if (proto_version != PY_SSL_VERSION_SSL2)
+        options |= SSL_OP_NO_SSLv2;
+    SSL_CTX_set_options(self->ctx, options);
 
     verification_mode = SSL_VERIFY_NONE;
     if (certreq == PY_SSL_CERT_OPTIONAL)
diff -r 3a1db0d2747e Modules/_struct.c
--- a/Modules/_struct.c
+++ b/Modules/_struct.c
@@ -1371,13 +1371,28 @@
 
     assert(PyStruct_Check(self));
 
-    if (!PyArg_ParseTupleAndKeywords(args, kwds, "S:Struct", kwlist,
+    if (!PyArg_ParseTupleAndKeywords(args, kwds, "O:Struct", kwlist,
                                      &o_format))
         return -1;
 
-    Py_INCREF(o_format);
-    Py_CLEAR(soself->s_format);
-    soself->s_format = o_format;
+    if (PyString_Check(o_format)) {
+        Py_INCREF(o_format);
+        Py_CLEAR(soself->s_format);
+        soself->s_format = o_format;
+    }
+    else if (PyUnicode_Check(o_format)) {
+        PyObject *str = PyUnicode_AsEncodedString(o_format, "ascii", NULL);
+        if (str == NULL)
+            return -1;
+        Py_CLEAR(soself->s_format);
+        soself->s_format = str;
+    }
+    else {
+        PyErr_Format(PyExc_TypeError,
+                     "Struct() argument 1 must be string, not %s",
+                     Py_TYPE(o_format)->tp_name);
+        return -1;
+    }
 
     ret = prepare_s(soself);
     return ret;
diff -r 3a1db0d2747e Modules/_testcapimodule.c
--- a/Modules/_testcapimodule.c
+++ b/Modules/_testcapimodule.c
@@ -1687,6 +1687,96 @@
     Py_RETURN_NONE;
 }
 
+#ifdef WITH_THREAD
+typedef struct {
+    PyThread_type_lock start_event;
+    PyThread_type_lock exit_event;
+    PyObject *callback;
+} test_c_thread_t;
+
+static void
+temporary_c_thread(void *data)
+{
+    test_c_thread_t *test_c_thread = data;
+    PyGILState_STATE state;
+    PyObject *res;
+
+    PyThread_release_lock(test_c_thread->start_event);
+
+    /* Allocate a Python thread state for this thread */
+    state = PyGILState_Ensure();
+
+    res = PyObject_CallFunction(test_c_thread->callback, "", NULL);
+    Py_CLEAR(test_c_thread->callback);
+
+    if (res == NULL) {
+        PyErr_Print();
+    }
+    else {
+        Py_DECREF(res);
+    }
+
+    /* Destroy the Python thread state for this thread */
+    PyGILState_Release(state);
+
+    PyThread_release_lock(test_c_thread->exit_event);
+
+    PyThread_exit_thread();
+}
+
+static PyObject *
+call_in_temporary_c_thread(PyObject *self, PyObject *callback)
+{
+    PyObject *res = NULL;
+    test_c_thread_t test_c_thread;
+    long thread;
+
+    PyEval_InitThreads();
+
+    test_c_thread.start_event = PyThread_allocate_lock();
+    test_c_thread.exit_event = PyThread_allocate_lock();
+    test_c_thread.callback = NULL;
+    if (!test_c_thread.start_event || !test_c_thread.exit_event) {
+        PyErr_SetString(PyExc_RuntimeError, "could not allocate lock");
+        goto exit;
+    }
+
+    Py_INCREF(callback);
+    test_c_thread.callback = callback;
+
+    PyThread_acquire_lock(test_c_thread.start_event, 1);
+    PyThread_acquire_lock(test_c_thread.exit_event, 1);
+
+    thread = PyThread_start_new_thread(temporary_c_thread, &test_c_thread);
+    if (thread == -1) {
+        PyErr_SetString(PyExc_RuntimeError, "unable to start the thread");
+        PyThread_release_lock(test_c_thread.start_event);
+        PyThread_release_lock(test_c_thread.exit_event);
+        goto exit;
+    }
+
+    PyThread_acquire_lock(test_c_thread.start_event, 1);
+    PyThread_release_lock(test_c_thread.start_event);
+
+    Py_BEGIN_ALLOW_THREADS
+        PyThread_acquire_lock(test_c_thread.exit_event, 1);
+        PyThread_release_lock(test_c_thread.exit_event);
+    Py_END_ALLOW_THREADS
+
+    Py_INCREF(Py_None);
+    res = Py_None;
+
+exit:
+    Py_CLEAR(test_c_thread.callback);
+    if (test_c_thread.start_event)
+        PyThread_free_lock(test_c_thread.start_event);
+    if (test_c_thread.exit_event)
+        PyThread_free_lock(test_c_thread.exit_event);
+    return res;
+}
+#endif   /* WITH_THREAD */
+
+
 static PyMethodDef TestMethods[] = {
     {"raise_exception",         raise_exception,                 METH_VARARGS},
     {"test_config",             (PyCFunction)test_config,        METH_NOARGS},
@@ -1745,6 +1835,10 @@
     {"make_exception_with_doc", (PyCFunction)make_exception_with_doc,
      METH_VARARGS | METH_KEYWORDS},
     {"sequence_delitem", (PyCFunction)sequence_delitem, METH_VARARGS},
+#ifdef WITH_THREAD
+    {"call_in_temporary_c_thread", call_in_temporary_c_thread, METH_O,
+     PyDoc_STR("set_error_class(error_class) -> None")},
+#endif
     {NULL, NULL} /* sentinel */
 };
 
diff -r 3a1db0d2747e Modules/bz2module.c
--- a/Modules/bz2module.c
+++ b/Modules/bz2module.c
@@ -1206,12 +1206,16 @@
                              0, NULL, NULL);
             break;
     }
-    if (self->fp) {
-        PyFile_DecUseCount((PyFileObject *)self->file);
-        self->fp = NULL;
+    if (self->file) {
+        if (self->fp)
+            PyFile_DecUseCount((PyFileObject *)self->file);
+        ret = PyObject_CallMethod(self->file, "close", NULL);
+    } else {
+        Py_INCREF(Py_None);
+        ret = Py_None;
     }
+    self->fp = NULL;
     self->mode = MODE_CLOSED;
-    ret = PyObject_CallMethod(self->file, "close", NULL);
     if (bzerror != BZ_OK) {
         Util_CatchBZ2Error(bzerror);
         Py_XDECREF(ret);
@@ -1479,10 +1483,9 @@
                              0, NULL, NULL);
             break;
     }
-    if (self->fp) {
+    if (self->fp != NULL && self->file != NULL)
         PyFile_DecUseCount((PyFileObject *)self->file);
-        self->fp = NULL;
-    }
+    self->fp = NULL;
     Util_DropReadAhead(self);
     Py_XDECREF(self->file);
     Py_TYPE(self)->tp_free((PyObject *)self);
diff -r 3a1db0d2747e Modules/fcntlmodule.c
--- a/Modules/fcntlmodule.c
+++ b/Modules/fcntlmodule.c
@@ -27,7 +27,7 @@
 }
 
 
-/* fcntl(fd, opt, [arg]) */
+/* fcntl(fd, op, [arg]) */
 
 static PyObject *
 fcntl_fcntl(PyObject *self, PyObject *args)
@@ -77,11 +77,12 @@
 }
 
 PyDoc_STRVAR(fcntl_doc,
-"fcntl(fd, opt, [arg])\n\
+"fcntl(fd, op, [arg])\n\
 \n\
-Perform the requested operation on file descriptor fd.  The operation\n\
-is defined by op and is operating system dependent.  These constants are\n\
-available from the fcntl module.  The argument arg is optional, and\n\
+Perform the operation op on file descriptor fd.  The values used\n\
+for op are operating system dependent, and are available\n\
+as constants in the fcntl module, using the same names as used in\n\
+the relevant C header files.  The argument arg is optional, and\n\
 defaults to 0; it may be an int or a string.  If arg is given as a string,\n\
 the return value of fcntl is a string of that length, containing the\n\
 resulting value put in the arg buffer by the operating system.  The length\n\
@@ -90,7 +91,7 @@
 corresponding to the return value of the fcntl call in the C code.");
 
 
-/* ioctl(fd, opt, [arg]) */
+/* ioctl(fd, op, [arg]) */
 
 static PyObject *
 fcntl_ioctl(PyObject *self, PyObject *args)
@@ -104,7 +105,7 @@
        whereas the system expects it to be a 32bit bit field value
        regardless of it being passed as an int or unsigned long on
        various platforms.  See the termios.TIOCSWINSZ constant across
-       platforms for an example of thise.
+       platforms for an example of this.
 
        If any of the 64bit platforms ever decide to use more than 32bits
        in their unsigned long ioctl codes this will break and need
@@ -212,11 +213,12 @@
 }
 
 PyDoc_STRVAR(ioctl_doc,
-"ioctl(fd, opt[, arg[, mutate_flag]])\n\
+"ioctl(fd, op[, arg[, mutate_flag]])\n\
 \n\
-Perform the requested operation on file descriptor fd.  The operation is\n\
-defined by opt and is operating system dependent.  Typically these codes are\n\
-retrieved from the fcntl or termios library modules.\n\
+Perform the operation op on file descriptor fd.  The values used for op\n\
+are operating system dependent, and are available as constants in the\n\
+fcntl or termios library modules, using the same names as used in the\n\
+relevant C header files.\n\
 \n\
 The argument arg is optional, and defaults to 0; it may be an int or a\n\
 buffer containing character data (most likely a string or an array). \n\
diff -r 3a1db0d2747e Modules/gcmodule.c
--- a/Modules/gcmodule.c
+++ b/Modules/gcmodule.c
@@ -113,7 +113,7 @@
 
 /*
    NOTE: about untracking of mutable objects.
-   
+
    Certain types of container cannot participate in a reference cycle, and
    so do not need to be tracked by the garbage collector. Untracking these
    objects reduces the cost of garbage collections. However, determining
@@ -131,10 +131,10 @@
    not survive until garbage collection. It is therefore not worthwhile
    to untrack eligible tuples at creation time.
 
-   Instead, all tuples except the empty tuple are tracked when created. 
-   During garbage collection it is determined whether any surviving tuples 
-   can be untracked. A tuple can be untracked if all of its contents are 
-   already not tracked. Tuples are examined for untracking in all garbage 
+   Instead, all tuples except the empty tuple are tracked when created.
+   During garbage collection it is determined whether any surviving tuples
+   can be untracked. A tuple can be untracked if all of its contents are
+   already not tracked. Tuples are examined for untracking in all garbage
    collection cycles. It may take more than one cycle to untrack a tuple.
 
    Dictionaries containing only immutable objects also do not need to be
@@ -147,8 +147,8 @@
    The module provides the python function is_tracked(obj), which returns
    the CURRENT tracking status of the object. Subsequent garbage
    collections may change the tracking status of the object.
-   
-   Untracking of certain containers was introduced in issue #4688, and 
+
+   Untracking of certain containers was introduced in issue #4688, and
    the algorithm was refined in response to issue #14775.
 */
 
diff -r 3a1db0d2747e Modules/ossaudiodev.c
--- a/Modules/ossaudiodev.c
+++ b/Modules/ossaudiodev.c
@@ -490,7 +490,6 @@
 {
     int wanted_fmt, wanted_channels, wanted_rate, strict=0;
     int fmt, channels, rate;
-    PyObject * rv;                    /* return tuple (fmt, channels, rate) */
 
     if (!PyArg_ParseTuple(args, "iii|i:setparameters",
                           &wanted_fmt, &wanted_channels, &wanted_rate,
@@ -532,13 +531,7 @@
 
     /* Construct the return value: a (fmt, channels, rate) tuple that
        tells what the audio hardware was actually set to. */
-    rv = PyTuple_New(3);
-    if (rv == NULL)
-        return NULL;
-    PyTuple_SET_ITEM(rv, 0, PyInt_FromLong(fmt));
-    PyTuple_SET_ITEM(rv, 1, PyInt_FromLong(channels));
-    PyTuple_SET_ITEM(rv, 2, PyInt_FromLong(rate));
-    return rv;
+    return Py_BuildValue("(iii)", fmt, channels, rate);
 }
 
 static int
diff -r 3a1db0d2747e Modules/selectmodule.c
--- a/Modules/selectmodule.c
+++ b/Modules/selectmodule.c
@@ -347,7 +347,7 @@
         assert(i < self->ufd_len);
         /* Never overflow */
         self->ufds[i].fd = (int)PyInt_AsLong(key);
-        self->ufds[i].events = (short)PyInt_AsLong(value);
+        self->ufds[i].events = (short)(unsigned short)PyInt_AsLong(value);
         i++;
     }
     assert(i == self->ufd_len);
@@ -355,6 +355,24 @@
     return 1;
 }
 
+static int
+ushort_converter(PyObject *obj, void *ptr)
+{
+    unsigned long uval;
+
+    uval = PyLong_AsUnsignedLong(obj);
+    if (uval == (unsigned long)-1 && PyErr_Occurred())
+        return 0;
+    if (uval > USHRT_MAX) {
+        PyErr_SetString(PyExc_OverflowError,
+                        "Python int too large for C unsigned short");
+        return 0;
+    }
+
+    *(unsigned short *)ptr = Py_SAFE_DOWNCAST(uval, unsigned long, unsigned short);
+    return 1;
+}
+
 PyDoc_STRVAR(poll_register_doc,
 "register(fd [, eventmask] ) -> None\n\n\
 Register a file descriptor with the polling object.\n\
@@ -367,12 +385,11 @@
 {
     PyObject *o, *key, *value;
     int fd;
-    short events = POLLIN | POLLPRI | POLLOUT;
+    unsigned short events = POLLIN | POLLPRI | POLLOUT;
     int err;
 
-    if (!PyArg_ParseTuple(args, "O|h:register", &o, &events)) {
+    if (!PyArg_ParseTuple(args, "O|O&:register", &o, ushort_converter, &events))
         return NULL;
-    }
 
     fd = PyObject_AsFileDescriptor(o);
     if (fd == -1) return NULL;
@@ -410,12 +427,12 @@
 poll_modify(pollObject *self, PyObject *args)
 {
     PyObject *o, *key, *value;
-    int fd, events;
+    int fd;
+    unsigned short events;
     int err;
 
-    if (!PyArg_ParseTuple(args, "Oi:modify", &o, &events)) {
+    if (!PyArg_ParseTuple(args, "OO&:modify", &o, ushort_converter, &events))
         return NULL;
-    }
 
     fd = PyObject_AsFileDescriptor(o);
     if (fd == -1) return NULL;
diff -r 3a1db0d2747e Modules/zipimport.c
--- a/Modules/zipimport.c
+++ b/Modules/zipimport.c
@@ -42,10 +42,16 @@
 
 static PyObject *ZipImportError;
 static PyObject *zip_directory_cache = NULL;
+static PyObject *zip_stat_cache = NULL;
+/* posix.fstat or nt.fstat function.  Used due to posixmodule.c's
+ * superior fstat implementation over libc's on Windows. */
+static PyObject *fstat_function = NULL;  /* posix.fstat() or nt.fstat() */
 
 /* forward decls */
-static PyObject *read_directory(char *archive);
-static PyObject *get_data(char *archive, PyObject *toc_entry);
+static FILE *fopen_rb_and_stat(char *path, PyObject **py_stat_p);
+static FILE *safely_reopen_archive(ZipImporter *self, char **archive_p);
+static PyObject *read_directory(FILE *fp, char *archive);
+static PyObject *get_data(FILE *fp, char *archive, PyObject *toc_entry);
 static PyObject *get_module_code(ZipImporter *self, char *fullname,
                                  int *p_ispackage, char **p_modpath);
 
@@ -126,12 +132,38 @@
         PyObject *files;
         files = PyDict_GetItemString(zip_directory_cache, path);
         if (files == NULL) {
-            files = read_directory(buf);
-            if (files == NULL)
+            PyObject *zip_stat = NULL;
+            FILE *fp = fopen_rb_and_stat(buf, &zip_stat);
+            if (fp == NULL) {
+                PyErr_Format(ZipImportError, "can't open Zip file: "
+                             "'%.200s'", buf);
+                Py_XDECREF(zip_stat);
                 return -1;
+            }
+
+            if (Py_VerboseFlag)
+                PySys_WriteStderr("# zipimport: %s not cached, "
+                                  "reading TOC.\n", path);
+
+            files = read_directory(fp, buf);
+            fclose(fp);
+            if (files == NULL) {
+                Py_XDECREF(zip_stat);
+                return -1;
+            }
             if (PyDict_SetItemString(zip_directory_cache, path,
-                                     files) != 0)
+                                     files) != 0) {
+                Py_DECREF(files);
+                Py_XDECREF(zip_stat);
                 return -1;
+            }
+            if (zip_stat && PyDict_SetItemString(zip_stat_cache, path,
+                                                 zip_stat) != 0) {
+                Py_DECREF(files);
+                Py_DECREF(zip_stat);
+                return -1;
+            }
+            Py_XDECREF(zip_stat);
         }
         else
             Py_INCREF(files);
@@ -419,11 +451,12 @@
 zipimporter_get_data(PyObject *obj, PyObject *args)
 {
     ZipImporter *self = (ZipImporter *)obj;
-    char *path;
+    char *path, *archive;
+    FILE *fp;
 #ifdef ALTSEP
     char *p, buf[MAXPATHLEN + 1];
 #endif
-    PyObject *toc_entry;
+    PyObject *toc_entry, *data;
     Py_ssize_t len;
 
     if (!PyArg_ParseTuple(args, "s:zipimporter.get_data", &path))
@@ -448,12 +481,19 @@
         path = path + len + 1;
     }
 
+    fp = safely_reopen_archive(self, &archive);
+    if (fp == NULL)
+        return NULL;
+
     toc_entry = PyDict_GetItemString(self->files, path);
     if (toc_entry == NULL) {
         PyErr_SetFromErrnoWithFilename(PyExc_IOError, path);
+        fclose(fp);
         return NULL;
     }
-    return get_data(PyString_AsString(self->archive), toc_entry);
+    data = get_data(fp, archive, toc_entry);
+    fclose(fp);
+    return data;
 }
 
 static PyObject *
@@ -473,7 +513,8 @@
 {
     ZipImporter *self = (ZipImporter *)obj;
     PyObject *toc_entry;
-    char *fullname, *subname, path[MAXPATHLEN+1];
+    FILE *fp;
+    char *fullname, *subname, path[MAXPATHLEN+1], *archive;
     int len;
     enum zi_module_info mi;
 
@@ -501,13 +542,20 @@
     else
         strcpy(path + len, ".py");
 
+    fp = safely_reopen_archive(self, &archive);
+    if (fp == NULL)
+        return NULL;
+
     toc_entry = PyDict_GetItemString(self->files, path);
-    if (toc_entry != NULL)
-        return get_data(PyString_AsString(self->archive), toc_entry);
+    if (toc_entry != NULL) {
+        PyObject *data = get_data(fp, archive, toc_entry);
+        fclose(fp);
+        return data;
+    }
+    fclose(fp);
 
     /* we have the module, but no source */
-    Py_INCREF(Py_None);
-    return Py_None;
+    Py_RETURN_NONE;
 }
 
 PyDoc_STRVAR(doc_find_module,
@@ -662,7 +710,137 @@
 }
 
 /*
-   read_directory(archive) -> files dict (new reference)
+   fopen_rb_and_stat(path, &py_stat) -> FILE *
+
+   Opens path in "rb" mode and populates the Python py_stat stat_result
+   with information about the opened file.  *py_stat may not be changed
+   if there is no fstat_function or if fstat_function fails.
+
+   Returns NULL and does nothing to *py_stat if the open failed.
+*/
+static FILE *
+fopen_rb_and_stat(char *path, PyObject **py_stat_p)
+{
+    FILE *fp;
+    assert(py_stat_p != NULL);
+    assert(*py_stat_p == NULL);
+
+    fp = fopen(path, "rb");
+    if (fp == NULL) {
+        return NULL;
+    }
+
+    if (fstat_function) {
+        PyObject *stat_result = PyObject_CallFunction(fstat_function,
+                                                      "i", fileno(fp));
+        if (stat_result == NULL) {
+            PyErr_Clear();  /* We can function without it. */
+        } else {
+            *py_stat_p = stat_result;
+        }
+    }
+
+    return fp;
+}
+
+/* Return 1 if objects a and b fail a Py_EQ test for an attr. */
+static int
+compare_obj_attr_strings(PyObject *obj_a, PyObject *obj_b, char *attr_name)
+{
+    int problem = 0;
+    PyObject *attr_a = PyObject_GetAttrString(obj_a, attr_name);
+    PyObject *attr_b = PyObject_GetAttrString(obj_b, attr_name);
+    if (attr_a == NULL || attr_b == NULL)
+        problem = 1;
+    else
+        problem = (PyObject_RichCompareBool(attr_a, attr_b, Py_EQ) != 1);
+    Py_XDECREF(attr_a);
+    Py_XDECREF(attr_b);
+    return problem;
+}
+
+/*
+ * Returns an open FILE * on success and sets *archive_p to point to
+ * a read only C string representation of the archive name (as a
+ * convenience for use in error messages).
+ *
+ * Returns NULL on error with the Python error context set.
+ */
+static FILE *
+safely_reopen_archive(ZipImporter *self, char **archive_p)
+{
+    FILE *fp;
+    PyObject *stat_now = NULL;
+    char *archive;
+
+    assert(archive_p != NULL);
+    *archive_p = PyString_AsString(self->archive);
+    if (*archive_p == NULL)
+        return NULL;
+    archive = *archive_p;
+
+    fp = fopen_rb_and_stat(archive, &stat_now);
+    if (!fp) {
+        PyErr_Format(PyExc_IOError,
+           "zipimport: can not open file %s", archive);
+        Py_XDECREF(stat_now);
+        return NULL;
+    }
+
+    if (stat_now != NULL) {
+        int problem = 0;
+        PyObject *files;
+        PyObject *prev_stat = PyDict_GetItemString(zip_stat_cache, archive);
+        /* Test stat_now vs the old cached stat on some key attributes. */
+        if (prev_stat != NULL) {
+            problem = compare_obj_attr_strings(prev_stat, stat_now,
+                                               "st_ino");
+            problem |= compare_obj_attr_strings(prev_stat, stat_now,
+                                                "st_size");
+            problem |= compare_obj_attr_strings(prev_stat, stat_now,
+                                                "st_mtime");
+        } else {
+            if (Py_VerboseFlag)
+                PySys_WriteStderr("# zipimport: no stat data for %s!\n",
+                                  archive);
+            problem = 1;
+        }
+
+        if (problem) {
+            if (Py_VerboseFlag)
+                PySys_WriteStderr("# zipimport: %s modified since last"
+                                  " import, rereading TOC.\n", archive);
+            files = read_directory(fp, archive);
+            if (files == NULL) {
+                Py_DECREF(stat_now);
+                fclose(fp);
+                return NULL;
+            }
+            if (PyDict_SetItem(zip_directory_cache, self->archive,
+                               files) != 0) {
+                Py_DECREF(files);
+                Py_DECREF(stat_now);
+                fclose(fp);
+                return NULL;
+            }
+            if (stat_now && PyDict_SetItem(zip_stat_cache, self->archive,
+                                           stat_now) != 0) {
+                Py_DECREF(files);
+                Py_DECREF(stat_now);
+                fclose(fp);
+                return NULL;
+            }
+            Py_XDECREF(self->files);  /* free the old value. */
+            self->files = files;
+        }
+        Py_DECREF(stat_now);
+    }  /* stat succeeded */
+
+    return fp;
+}
+
+/*
+   read_directory(fp, archive) -> files dict (new reference)
 
    Given a path to a Zip archive, build a dict, mapping file names
    (local to the archive, using SEP as a separator) to toc entries.
@@ -683,10 +861,9 @@
    data_size and file_offset are 0.
 */
 static PyObject *
-read_directory(char *archive)
+read_directory(FILE *fp, char *archive)
 {
     PyObject *files = NULL;
-    FILE *fp;
     long compress, crc, data_size, file_size, file_offset, date, time;
     long header_offset, name_size, header_size, header_position;
     long i, l, count;
@@ -696,6 +873,7 @@
     char *p, endof_central_dir[22];
     long arc_offset; /* offset from beginning of file to start of zip-archive */
 
+    assert(fp != NULL);
     if (strlen(archive) > MAXPATHLEN) {
         PyErr_SetString(PyExc_OverflowError,
                         "Zip path name is too long");
@@ -703,28 +881,18 @@
     }
     strcpy(path, archive);
 
-    fp = fopen(archive, "rb");
-    if (fp == NULL) {
-        PyErr_Format(ZipImportError, "can't open Zip file: "
-                     "'%.200s'", archive);
-        return NULL;
-    }
-
     if (fseek(fp, -22, SEEK_END) == -1) {
-        fclose(fp);
         PyErr_Format(ZipImportError, "can't read Zip file: %s", archive);
         return NULL;
     }
     header_position = ftell(fp);
     if (fread(endof_central_dir, 1, 22, fp) != 22) {
-        fclose(fp);
         PyErr_Format(ZipImportError, "can't read Zip file: "
                      "'%.200s'", archive);
         return NULL;
     }
     if (get_long((unsigned char *)endof_central_dir) != 0x06054B50) {
         /* Bad: End of Central Dir signature */
-        fclose(fp);
         PyErr_Format(ZipImportError, "not a Zip file: "
                      "'%.200s'", archive);
         return NULL;
@@ -793,18 +961,15 @@
             goto error;
         count++;
     }
-    fclose(fp);
     if (Py_VerboseFlag)
         PySys_WriteStderr("# zipimport: found %ld names in %s\n",
             count, archive);
     return files;
 fseek_error:
-    fclose(fp);
     Py_XDECREF(files);
     PyErr_Format(ZipImportError, "can't read Zip file: %s", archive);
     return NULL;
 error:
-    fclose(fp);
     Py_XDECREF(files);
     return NULL;
 }
@@ -841,14 +1006,13 @@
     return decompress;
 }
 
-/* Given a path to a Zip file and a toc_entry, return the (uncompressed)
+/* Given a FILE* to a Zip file and a toc_entry, return the (uncompressed)
    data as a new reference. */
 static PyObject *
-get_data(char *archive, PyObject *toc_entry)
+get_data(FILE *fp, char *archive, PyObject *toc_entry)
 {
     PyObject *raw_data, *data = NULL, *decompress;
     char *buf;
-    FILE *fp;
     int err;
     Py_ssize_t bytes_read = 0;
     long l;
@@ -862,16 +1026,8 @@
         return NULL;
     }
 
-    fp = fopen(archive, "rb");
-    if (!fp) {
-        PyErr_Format(PyExc_IOError,
-           "zipimport: can not open file %s", archive);
-        return NULL;
-    }
-
     /* Check to make sure the local file header is correct */
     if (fseek(fp, file_offset, 0) == -1) {
-        fclose(fp);
         PyErr_Format(ZipImportError, "can't read Zip file: %s", archive);
         return NULL;
     }
@@ -882,11 +1038,9 @@
         PyErr_Format(ZipImportError,
                      "bad local file header in %s",
                      archive);
-        fclose(fp);
         return NULL;
     }
     if (fseek(fp, file_offset + 26, 0) == -1) {
-        fclose(fp);
         PyErr_Format(ZipImportError, "can't read Zip file: %s", archive);
         return NULL;
     }
@@ -898,7 +1052,6 @@
     raw_data = PyString_FromStringAndSize((char *)NULL, compress == 0 ?
                                           data_size : data_size + 1);
     if (raw_data == NULL) {
-        fclose(fp);
         return NULL;
     }
     buf = PyString_AsString(raw_data);
@@ -907,11 +1060,9 @@
     if (err == 0) {
         bytes_read = fread(buf, 1, data_size, fp);
     } else {
-        fclose(fp);
         PyErr_Format(ZipImportError, "can't read Zip file: %s", archive);
         return NULL;
     }
-    fclose(fp);
     if (err || bytes_read != data_size) {
         PyErr_SetString(PyExc_IOError,
                         "zipimport: can't read data");
@@ -1107,17 +1258,13 @@
 /* Return the code object for the module named by 'fullname' from the
    Zip archive as a new reference. */
 static PyObject *
-get_code_from_data(ZipImporter *self, int ispackage, int isbytecode,
-                   time_t mtime, PyObject *toc_entry)
+get_code_from_data(char *archive, FILE *fp, int ispackage,
+                   int isbytecode, time_t mtime, PyObject *toc_entry)
 {
     PyObject *data, *code;
     char *modpath;
-    char *archive = PyString_AsString(self->archive);
 
-    if (archive == NULL)
-        return NULL;
-
-    data = get_data(archive, toc_entry);
+    data = get_data(fp, archive, toc_entry);
     if (data == NULL)
         return NULL;
 
@@ -1143,6 +1290,8 @@
     char *subname, path[MAXPATHLEN + 1];
     int len;
     struct st_zip_searchorder *zso;
+    FILE *fp;
+    char *archive;
 
     subname = get_subname(fullname);
 
@@ -1150,6 +1299,10 @@
     if (len < 0)
         return NULL;
 
+    fp = safely_reopen_archive(self, &archive);
+    if (fp == NULL)
+        return NULL;
+
     for (zso = zip_searchorder; *zso->suffix; zso++) {
         PyObject *code = NULL;
 
@@ -1158,6 +1311,7 @@
             PySys_WriteStderr("# trying %s%c%s\n",
                               PyString_AsString(self->archive),
                               SEP, path);
+
         toc_entry = PyDict_GetItemString(self->files, path);
         if (toc_entry != NULL) {
             time_t mtime = 0;
@@ -1168,7 +1322,7 @@
                 mtime = get_mtime_of_source(self, path);
             if (p_ispackage != NULL)
                 *p_ispackage = ispackage;
-            code = get_code_from_data(self, ispackage,
+            code = get_code_from_data(archive, fp, ispackage,
                                       isbytecode, mtime,
                                       toc_entry);
             if (code == Py_None) {
@@ -1180,10 +1334,12 @@
             if (code != NULL && p_modpath != NULL)
                 *p_modpath = PyString_AsString(
                     PyTuple_GetItem(toc_entry, 0));
+            fclose(fp);
             return code;
         }
     }
     PyErr_Format(ZipImportError, "can't find module '%.200s'", fullname);
+    fclose(fp);
     return NULL;
 }
 
@@ -1199,6 +1355,8 @@
   subclass of ImportError, so it can be caught as ImportError, too.\n\
 - _zip_directory_cache: a dict, mapping archive paths to zip directory\n\
   info dicts, as used in zipimporter._files.\n\
+- _zip_stat_cache: a dict, mapping archive paths to stat_result\n\
+  info for the .zip the last time anything was imported from it.\n\
 \n\
 It is usually not needed to use the zipimport module explicitly; it is\n\
 used by the builtin import mechanism for sys.path items that are paths\n\
@@ -1247,6 +1405,7 @@
                            (PyObject *)&ZipImporter_Type) < 0)
         return;
 
+    Py_XDECREF(zip_directory_cache);  /* Avoid embedded interpreter leaks. */
     zip_directory_cache = PyDict_New();
     if (zip_directory_cache == NULL)
         return;
@@ -1254,4 +1413,34 @@
     if (PyModule_AddObject(mod, "_zip_directory_cache",
                            zip_directory_cache) < 0)
         return;
+
+    Py_XDECREF(zip_stat_cache);  /* Avoid embedded interpreter leaks. */
+    zip_stat_cache = PyDict_New();
+    if (zip_stat_cache == NULL)
+        return;
+    Py_INCREF(zip_stat_cache);
+    if (PyModule_AddObject(mod, "_zip_stat_cache", zip_stat_cache) < 0)
+        return;
+
+    {
+        /* We cannot import "os" here as that is a .py/.pyc file that could
+         * live within a zipped up standard library.  Import the posix or nt
+         * builtin that provides the fstat() function we want instead. */
+        PyObject *os_like_module;
+        Py_CLEAR(fstat_function);  /* Avoid embedded interpreter leaks. */
+        os_like_module = PyImport_ImportModule("posix");
+        if (os_like_module == NULL) {
+            PyErr_Clear();
+            os_like_module = PyImport_ImportModule("nt");
+        }
+        if (os_like_module != NULL) {
+            fstat_function = PyObject_GetAttrString(os_like_module, "fstat");
+            Py_DECREF(os_like_module);
+        }
+        if (fstat_function == NULL) {
+            PyErr_Clear();  /* non-fatal, we'll go on without it. */
+            if (Py_VerboseFlag)
+                PySys_WriteStderr("# zipimport unable to use os.fstat().\n");
+        }
+    }
 }
diff -r 3a1db0d2747e Objects/descrobject.c
--- a/Objects/descrobject.c
+++ b/Objects/descrobject.c
@@ -1363,21 +1363,25 @@
 "\n"
 "fget is a function to be used for getting an attribute value, and likewise\n"
 "fset is a function for setting, and fdel a function for del'ing, an\n"
-"attribute.  Typical use is to define a managed attribute x:\n"
+"attribute.  Typical use is to define a managed attribute x:\n\n"
 "class C(object):\n"
 "    def getx(self): return self._x\n"
 "    def setx(self, value): self._x = value\n"
 "    def delx(self): del self._x\n"
 "    x = property(getx, setx, delx, \"I'm the 'x' property.\")\n"
 "\n"
-"Decorators make defining new properties or modifying existing ones easy:\n"
+"Decorators make defining new properties or modifying existing ones easy:\n\n"
 "class C(object):\n"
 "    @property\n"
-"    def x(self): return self._x\n"
+"    def x(self):\n"
+"        \"I am the 'x' property.\"\n"
+"        return self._x\n"
 "    @x.setter\n"
-"    def x(self, value): self._x = value\n"
+"    def x(self, value):\n"
+"        self._x = value\n"
 "    @x.deleter\n"
-"    def x(self): del self._x\n"
+"    def x(self):\n"
+"        del self._x\n"
 );
 
 static int
diff -r 3a1db0d2747e Objects/fileobject.c
--- a/Objects/fileobject.c
+++ b/Objects/fileobject.c
@@ -1804,6 +1804,7 @@
     const char *s;
     Py_ssize_t n, n2;
     PyObject *encoded = NULL;
+    int err_flag = 0, err;
 
     if (f->f_fp == NULL)
         return err_closed();
@@ -1849,11 +1850,16 @@
     FILE_BEGIN_ALLOW_THREADS(f)
     errno = 0;
     n2 = fwrite(s, 1, n, f->f_fp);
+    if (n2 != n || ferror(f->f_fp)) {
+        err_flag = 1;
+        err = errno;
+    }
     FILE_END_ALLOW_THREADS(f)
     Py_XDECREF(encoded);
     if (f->f_binary)
         PyBuffer_Release(&pbuf);
-    if (n2 != n) {
+    if (err_flag) {
+        errno = err;
         PyErr_SetFromErrno(PyExc_IOError);
         clearerr(f->f_fp);
         return NULL;
diff -r 3a1db0d2747e Objects/genobject.c
--- a/Objects/genobject.c
+++ b/Objects/genobject.c
@@ -76,6 +76,7 @@
 
     /* Generators always return to their most recent caller, not
      * necessarily their creator. */
+    f->f_tstate = tstate;
     Py_XINCREF(tstate->frame);
     assert(f->f_back == NULL);
     f->f_back = tstate->frame;
@@ -89,6 +90,8 @@
      * cycle. */
     assert(f->f_back == tstate->frame);
     Py_CLEAR(f->f_back);
+    /* Clear the borrowed reference to the thread state */
+    f->f_tstate = NULL;
 
     /* If the generator just returned (as opposed to yielding), signal
      * that the generator is exhausted. */
diff -r 3a1db0d2747e PC/python_nt.rc
--- a/PC/python_nt.rc
+++ b/PC/python_nt.rc
@@ -61,7 +61,7 @@
             VALUE "FileDescription", "Python Core\0"
             VALUE "FileVersion", PYTHON_VERSION
             VALUE "InternalName", "Python DLL\0"
-            VALUE "LegalCopyright", "Copyright  2001-2008 Python Software Foundation. Copyright  2000 BeOpen.com. Copyright  1995-2001 CNRI. Copyright  1991-1995 SMC.\0"
+            VALUE "LegalCopyright", "Copyright  2001-2014 Python Software Foundation. Copyright  2000 BeOpen.com. Copyright  1995-2001 CNRI. Copyright  1991-1995 SMC.\0"
             VALUE "OriginalFilename", PYTHON_DLL_NAME "\0"
             VALUE "ProductName", "Python\0"
             VALUE "ProductVersion", PYTHON_VERSION
diff -r 3a1db0d2747e PCbuild/readme.txt
--- a/PCbuild/readme.txt
+++ b/PCbuild/readme.txt
@@ -1,7 +1,7 @@
 Building Python using VC++ 9.0
 ------------------------------
 
-This directory is used to build Python for Win32 and x64 platforms, e.g. 
+This directory is used to build Python for Win32 and x64 platforms, e.g.
 Windows 2000, XP, Vista and Windows Server 2008.  In order to build 32-bit
 debug and release executables, Microsoft Visual C++ 2008 Express Edition is
 required at the very least.  In order to build 64-bit debug and release
@@ -27,7 +27,7 @@
 
 The solution is configured to build the projects in the correct order. "Build
 Solution" or F7 takes care of dependencies except for x64 builds. To make
-cross compiling x64 builds on a 32bit OS possible the x64 builds require a 
+cross compiling x64 builds on a 32bit OS possible the x64 builds require a
 32bit version of Python.
 
 NOTE:
@@ -37,7 +37,7 @@
    running a Python core buildbot test slave; see SUBPROJECTS below)
 
 When using the Debug setting, the output files have a _d added to
-their name:  python30_d.dll, python_d.exe, parser_d.pyd, and so on. Both
+their name:  python27_d.dll, python_d.exe, parser_d.pyd, and so on. Both
 the build and rt batch files accept a -d option for debug builds.
 
 The 32bit builds end up in the solution folder PCbuild while the x64 builds
@@ -47,7 +47,7 @@
 Legacy support
 --------------
 
-You can find build directories for older versions of Visual Studio and 
+You can find build directories for older versions of Visual Studio and
 Visual C++ in the PC directory. The legacy build directories are no longer
 actively maintained and may not work out of the box.
 
@@ -64,7 +64,7 @@
 
 Visual Studio 2008 uses version 9 of the C runtime (MSVCRT9).  The executables
 are linked to a CRT "side by side" assembly which must be present on the target
-machine.  This is avalible under the VC/Redist folder of your visual studio
+machine.  This is available under the VC/Redist folder of your visual studio
 distribution. On XP and later operating systems that support
 side-by-side assemblies it is not enough to have the msvcrt90.dll present,
 it has to be there as a whole assembly, that is, a folder with the .dll
@@ -105,16 +105,16 @@
 Python-controlled subprojects that wrap external projects:
 _bsddb
     Wraps Berkeley DB 4.7.25, which is currently built by _bsddb.vcproj.
-    project (see below).
+    project.
 _sqlite3
-    Wraps SQLite 3.6.21, which is currently built by sqlite3.vcproj (see below).
+    Wraps SQLite 3.6.21, which is currently built by sqlite3.vcproj.
 _tkinter
     Wraps the Tk windowing system.  Unlike _bsddb and _sqlite3, there's no
     corresponding tcltk.vcproj-type project that builds Tcl/Tk from vcproj's
     within our pcbuild.sln, which means this module expects to find a
     pre-built Tcl/Tk in either ..\..\tcltk for 32-bit or ..\..\tcltk64 for
     64-bit (relative to this directory).  See below for instructions to build
-    Tcl/Tk. 
+    Tcl/Tk.
 bz2
     Python wrapper for the libbz2 compression library.  Homepage
         http://sources.redhat.com/bzip2/
@@ -127,16 +127,6 @@
     obtaining external sources then you don't need to manually get the source
     above via subversion. **
 
-    A custom pre-link step in the bz2 project settings should manage to
-    build bzip2-1.0.6\libbz2.lib by magic before bz2.pyd (or bz2_d.pyd) is
-    linked in PCbuild\.
-    However, the bz2 project is not smart enough to remove anything under
-    bzip2-1.0.6\ when you do a clean, so if you want to rebuild bzip2.lib
-    you need to clean up bzip2-1.0.6\ by hand.
-
-    All of this managed to build libbz2.lib in 
-    bzip2-1.0.6\$platform-$configuration\, which the Python project links in.
-
 _ssl
     Python wrapper for the secure sockets library.
 
@@ -154,18 +144,16 @@
 
     You must install the NASM assembler from
         http://nasm.sf.net
-    for x86 builds.  Put nasmw.exe anywhere in your PATH.
-    Note: recent releases of nasm only have nasm.exe. Just rename it to 
-    nasmw.exe.
+    for x86 builds.  Put nasm.exe anywhere in your PATH.
 
     You can also install ActivePerl from
         http://www.activestate.com/activeperl/
-    if you like to use the official sources instead of the files from 
+    if you like to use the official sources instead of the files from
     python's subversion repository. The svn version contains pre-build
     makefiles and assembly files.
 
     The build process makes sure that no patented algorithms are included.
-    For now RC5, MDC2 and IDEA are excluded from the build. You may have 
+    For now RC5, MDC2 and IDEA are excluded from the build. You may have
     to manually remove $(OBJ_D)\i_*.obj from ms\nt.mak if the build process
     complains about missing files or forbidden IDEA. Again the files provided
     in the subversion repository are already fixed.
@@ -186,16 +174,16 @@
     this by hand.
 
 The subprojects above wrap external projects Python doesn't control, and as
-such, a little more work is required in order to download the relevant source 
+such, a little more work is required in order to download the relevant source
 files for each project before they can be built.  The buildbots do this each
-time they're built, so the easiest approach is to run either external.bat or 
+time they're built, so the easiest approach is to run either external.bat or
 external-amd64.bat in the ..\Tools\buildbot directory from ..\, i.e.:
 
     C:\..\svn.python.org\projects\python\trunk\PCbuild>cd ..
     C:\..\svn.python.org\projects\python\trunk>Tools\buildbot\external.bat
 
 This extracts all the external subprojects from http://svn.python.org/external
-via Subversion (so you'll need an svn.exe on your PATH) and places them in 
+via Subversion (so you'll need an svn.exe on your PATH) and places them in
 ..\.. (relative to this directory).  The external(-amd64).bat scripts will
 also build a debug build of Tcl/Tk; there aren't any equivalent batch files
 for building release versions of Tcl/Tk lying around in the Tools\buildbot
@@ -238,7 +226,7 @@
     junction as follows (using the directory structure above as an example):
 
         C:\..\python\trunk\external <- already exists and has built versions
-                                       of the external subprojects 
+                                       of the external subprojects
 
         C:\..\python\branches\py3k>linkd.exe external ..\..\trunk\external
         Link created at: external
@@ -251,19 +239,9 @@
 Building for Itanium
 --------------------
 
-NOTE:
 Official support for Itanium builds have been dropped from the build. Please
 contact us and provide patches if you are interested in Itanium builds.
 
-The project files support a ReleaseItanium configuration which creates
-Win64/Itanium binaries. For this to work, you need to install the Platform
-SDK, in particular the 64-bit support. This includes an Itanium compiler
-(future releases of the SDK likely include an AMD64 compiler as well).
-In addition, you need the Visual Studio plugin for external C compilers,
-from http://sf.net/projects/vsextcomp. The plugin will wrap cl.exe, to
-locate the proper target compiler, and convert compiler options
-accordingly. The project files require at least version 0.9.
-
 Building for AMD64
 ------------------
 
@@ -283,7 +261,7 @@
 
 The solution has two configurations for PGO. The PGInstrument
 configuration must be build first. The PGInstrument binaries are
-lniked against a profiling library and contain extra debug
+linked against a profiling library and contain extra debug
 information. The PGUpdate configuration takes the profiling data and
 generates optimized binaries.
 
@@ -291,22 +269,22 @@
 creates the PGI files, runs the unit test suite or PyBench with the PGI
 python and finally creates the optimized files.
 
-http://msdn2.microsoft.com/en-us/library/e7k32f4k(VS.90).aspx
+http://msdn.microsoft.com/en-us/library/e7k32f4k(VS.90).aspx
 
 Static library
 --------------
 
 The solution has no configuration for static libraries. However it is easy
-it build a static library instead of a DLL. You simply have to set the 
+it build a static library instead of a DLL. You simply have to set the
 "Configuration Type" to "Static Library (.lib)" and alter the preprocessor
 macro "Py_ENABLE_SHARED" to "Py_NO_ENABLE_SHARED". You may also have to
-change the "Runtime Library" from "Multi-threaded DLL (/MD)" to 
+change the "Runtime Library" from "Multi-threaded DLL (/MD)" to
 "Multi-threaded (/MT)".
 
 Visual Studio properties
 ------------------------
 
-The PCbuild solution makes heavy use of Visual Studio property files 
+The PCbuild solution makes heavy use of Visual Studio property files
 (*.vsprops). The properties can be viewed and altered in the Property
 Manager (View -> Other Windows -> Property Manager).
 
diff -r 3a1db0d2747e Parser/tokenizer.c
--- a/Parser/tokenizer.c
+++ b/Parser/tokenizer.c
@@ -400,6 +400,12 @@
         buf = PyObject_CallObject(tok->decoding_readline, NULL);
         if (buf == NULL)
             return error_ret(tok);
+        if (!PyUnicode_Check(buf)) {
+            Py_DECREF(buf);
+            PyErr_SetString(PyExc_SyntaxError,
+                            "codec did not return a unicode object");
+            return error_ret(tok);
+        }
     } else {
         tok->decoding_buffer = NULL;
         if (PyString_CheckExact(buf))
diff -r 3a1db0d2747e Python/dtoa.c
--- a/Python/dtoa.c
+++ b/Python/dtoa.c
@@ -204,7 +204,24 @@
    MAX_ABS_EXP in absolute value get truncated to +-MAX_ABS_EXP.  MAX_ABS_EXP
    should fit into an int. */
 #ifndef MAX_ABS_EXP
-#define MAX_ABS_EXP 19999U
+#define MAX_ABS_EXP 1100000000U
+#endif
+/* Bound on length of pieces of input strings in _Py_dg_strtod; specifically,
+   this is used to bound the total number of digits ignoring leading zeros and
+   the number of digits that follow the decimal point.  Ideally, MAX_DIGITS
+   should satisfy MAX_DIGITS + 400 < MAX_ABS_EXP; that ensures that the
+   exponent clipping in _Py_dg_strtod can't affect the value of the output. */
+#ifndef MAX_DIGITS
+#define MAX_DIGITS 1000000000U
+#endif
+
+/* Guard against trying to use the above values on unusual platforms with ints
+ * of width less than 32 bits. */
+#if MAX_ABS_EXP > INT_MAX
+#error "MAX_ABS_EXP should fit in an int"
+#endif
+#if MAX_DIGITS > INT_MAX
+#error "MAX_DIGITS should fit in an int"
 #endif
 
 /* The following definition of Storeinc is appropriate for MIPS processors.
@@ -1498,6 +1515,7 @@
     Long L;
     BCinfo bc;
     Bigint *bb, *bb1, *bd, *bd0, *bs, *delta;
+    size_t ndigits, fraclen;
 
     dval(&rv) = 0.;
 
@@ -1520,40 +1538,53 @@
         c = *++s;
     lz = s != s1;
 
-    /* Point s0 at the first nonzero digit (if any).  nd0 will be the position
-       of the point relative to s0.  nd will be the total number of digits
-       ignoring leading zeros. */
+    /* Point s0 at the first nonzero digit (if any).  fraclen will be the
+       number of digits between the decimal point and the end of the
+       digit string.  ndigits will be the total number of digits ignoring
+       leading zeros. */
     s0 = s1 = s;
     while ('0' <= c && c <= '9')
         c = *++s;
-    nd0 = nd = s - s1;
+    ndigits = s - s1;
+    fraclen = 0;
 
     /* Parse decimal point and following digits. */
     if (c == '.') {
         c = *++s;
-        if (!nd) {
+        if (!ndigits) {
             s1 = s;
             while (c == '0')
                 c = *++s;
             lz = lz || s != s1;
-            nd0 -= s - s1;
+            fraclen += (s - s1);
             s0 = s;
         }
         s1 = s;
         while ('0' <= c && c <= '9')
             c = *++s;
-        nd += s - s1;
+        ndigits += s - s1;
+        fraclen += s - s1;
     }
 
-    /* Now lz is true if and only if there were leading zero digits, and nd
-       gives the total number of digits ignoring leading zeros.  A valid input
-       must have at least one digit. */
-    if (!nd && !lz) {
+    /* Now lz is true if and only if there were leading zero digits, and
+       ndigits gives the total number of digits ignoring leading zeros.  A
+       valid input must have at least one digit. */
+    if (!ndigits && !lz) {
         if (se)
             *se = (char *)s00;
         goto parse_error;
     }
 
+    /* Range check ndigits and fraclen to make sure that they, and values
+       computed with them, can safely fit in an int. */
+    if (ndigits > MAX_DIGITS || fraclen > MAX_DIGITS) {
+        if (se)
+            *se = (char *)s00;
+        goto parse_error;
+    }
+    nd = (int)ndigits;
+    nd0 = (int)ndigits - (int)fraclen;
+
     /* Parse exponent. */
     e = 0;
     if (c == 'e' || c == 'E') {
@@ -1886,20 +1917,20 @@
         bd2++;
 
         /* At this stage bd5 - bb5 == e == bd2 - bb2 + bbe, bb2 - bs2 == 1,
-	   and bs == 1, so:
+           and bs == 1, so:
 
               tdv == bd * 10**e = bd * 2**(bbe - bb2 + bd2) * 5**(bd5 - bb5)
               srv == bb * 2**bbe = bb * 2**(bbe - bb2 + bb2)
-	      0.5 ulp(srv) == 2**(bbe-1) = bs * 2**(bbe - bb2 + bs2)
+              0.5 ulp(srv) == 2**(bbe-1) = bs * 2**(bbe - bb2 + bs2)
 
-	   It follows that:
+           It follows that:
 
               M * tdv = bd * 2**bd2 * 5**bd5
               M * srv = bb * 2**bb2 * 5**bb5
               M * 0.5 ulp(srv) = bs * 2**bs2 * 5**bb5
 
-	   for some constant M.  (Actually, M == 2**(bb2 - bbe) * 5**bb5, but
-	   this fact is not needed below.)
+           for some constant M.  (Actually, M == 2**(bb2 - bbe) * 5**bb5, but
+           this fact is not needed below.)
         */
 
         /* Remove factor of 2**i, where i = min(bb2, bd2, bs2). */
diff -r 3a1db0d2747e Python/getcopyright.c
--- a/Python/getcopyright.c
+++ b/Python/getcopyright.c
@@ -4,7 +4,7 @@
 
 static char cprt[] = 
 "\
-Copyright (c) 2001-2013 Python Software Foundation.\n\
+Copyright (c) 2001-2014 Python Software Foundation.\n\
 All Rights Reserved.\n\
 \n\
 Copyright (c) 2000 BeOpen.com.\n\
diff -r 3a1db0d2747e Python/sysmodule.c
--- a/Python/sysmodule.c
+++ b/Python/sysmodule.c
@@ -616,6 +616,10 @@
     PyStructSequence_SET_ITEM(version, pos++, PyInt_FromLong(ver.wSuiteMask));
     PyStructSequence_SET_ITEM(version, pos++, PyInt_FromLong(ver.wProductType));
 
+    if (PyErr_Occurred()) {
+        Py_DECREF(version);
+        return NULL;
+    }
     return version;
 }
 
@@ -1261,6 +1265,7 @@
 #undef SetFlag
 
     if (PyErr_Occurred()) {
+        Py_DECREF(seq);
         return NULL;
     }
     return seq;
diff -r 3a1db0d2747e README
--- a/README
+++ b/README
@@ -2,7 +2,7 @@
 ============================
 
 Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011,
-2012, 2013 Python Software Foundation.  All rights reserved.
+2012, 2013, 2014 Python Software Foundation.  All rights reserved.
 
 Copyright (c) 2000 BeOpen.com.
 All rights reserved.
diff -r 3a1db0d2747e Tools/gdb/libpython.py
--- a/Tools/gdb/libpython.py
+++ b/Tools/gdb/libpython.py
@@ -39,10 +39,20 @@
 
 The module also extends gdb with some python-specific commands.
 '''
-from __future__ import with_statement
+
+# NOTE: some gdbs are linked with Python 3, so this file should be dual-syntax
+# compatible (2.6+ and 3.0+).  See #19308.
+
+from __future__ import print_function, with_statement
 import gdb
+import os
 import sys
 
+if sys.version_info[0] >= 3:
+    unichr = chr
+    xrange = range
+    long = int
+
 # Look up the gdb.Type for some standard types:
 _type_char_ptr = gdb.lookup_type('char').pointer() # char*
 _type_unsigned_char_ptr = gdb.lookup_type('unsigned char').pointer() # unsigned char*
@@ -51,17 +61,17 @@
 SIZEOF_VOID_P = _type_void_ptr.sizeof
 
 
-Py_TPFLAGS_HEAPTYPE = (1L << 9)
+Py_TPFLAGS_HEAPTYPE = (1 << 9)
 
-Py_TPFLAGS_INT_SUBCLASS      = (1L << 23)
-Py_TPFLAGS_LONG_SUBCLASS     = (1L << 24)
-Py_TPFLAGS_LIST_SUBCLASS     = (1L << 25)
-Py_TPFLAGS_TUPLE_SUBCLASS    = (1L << 26)
-Py_TPFLAGS_STRING_SUBCLASS   = (1L << 27)
-Py_TPFLAGS_UNICODE_SUBCLASS  = (1L << 28)
-Py_TPFLAGS_DICT_SUBCLASS     = (1L << 29)
-Py_TPFLAGS_BASE_EXC_SUBCLASS = (1L << 30)
-Py_TPFLAGS_TYPE_SUBCLASS     = (1L << 31)
+Py_TPFLAGS_INT_SUBCLASS      = (1 << 23)
+Py_TPFLAGS_LONG_SUBCLASS     = (1 << 24)
+Py_TPFLAGS_LIST_SUBCLASS     = (1 << 25)
+Py_TPFLAGS_TUPLE_SUBCLASS    = (1 << 26)
+Py_TPFLAGS_STRING_SUBCLASS   = (1 << 27)
+Py_TPFLAGS_UNICODE_SUBCLASS  = (1 << 28)
+Py_TPFLAGS_DICT_SUBCLASS     = (1 << 29)
+Py_TPFLAGS_BASE_EXC_SUBCLASS = (1 << 30)
+Py_TPFLAGS_TYPE_SUBCLASS     = (1 << 31)
 
 
 MAX_OUTPUT_LEN=1024
@@ -80,7 +90,7 @@
 def safe_range(val):
     # As per range, but don't trust the value too much: cap it to a safety
     # threshold in case the data was corrupted
-    return xrange(safety_limit(val))
+    return xrange(safety_limit(int(val)))
 
 
 class StringTruncated(RuntimeError):
@@ -292,8 +302,8 @@
             # class
             return cls
 
-        #print 'tp_flags = 0x%08x' % tp_flags
-        #print 'tp_name = %r' % tp_name
+        #print('tp_flags = 0x%08x' % tp_flags)
+        #print('tp_name = %r' % tp_name)
 
         name_map = {'bool': PyBoolObjectPtr,
                     'classobj': PyClassObjectPtr,
@@ -758,14 +768,14 @@
         '''
         ob_size = long(self.field('ob_size'))
         if ob_size == 0:
-            return 0L
+            return 0
 
         ob_digit = self.field('ob_digit')
 
         if gdb.lookup_type('digit').sizeof == 2:
-            SHIFT = 15L
+            SHIFT = 15
         else:
-            SHIFT = 30L
+            SHIFT = 30
 
         digits = [long(ob_digit[i]) * 2**(SHIFT*i)
                   for i in safe_range(abs(ob_size))]
@@ -774,6 +784,12 @@
             result = -result
         return result
 
+    def write_repr(self, out, visited):
+        # This ensures the trailing 'L' is printed when gdb is linked
+        # with a Python 3 interpreter.
+        out.write(repr(self.proxyval(visited)).rstrip('L'))
+        out.write('L')
+
 
 class PyNoneStructPtr(PyObjectPtr):
     """
@@ -969,11 +985,19 @@
         field_ob_size = self.field('ob_size')
         field_ob_sval = self.field('ob_sval')
         char_ptr = field_ob_sval.address.cast(_type_unsigned_char_ptr)
+        # When gdb is linked with a Python 3 interpreter, this is really
+        # a latin-1 mojibake decoding of the original string...
         return ''.join([chr(char_ptr[i]) for i in safe_range(field_ob_size)])
 
     def proxyval(self, visited):
         return str(self)
 
+    def write_repr(self, out, visited):
+        val = repr(self.proxyval(visited))
+        if sys.version_info[0] >= 3:
+            val = val.encode('ascii', 'backslashreplace').decode('ascii')
+        out.write(val)
+
 class PyTupleObjectPtr(PyObjectPtr):
     _typename = 'PyTupleObject'
 
@@ -1072,6 +1096,15 @@
         result = u''.join([_unichr(ucs) for ucs in Py_UNICODEs])
         return result
 
+    def write_repr(self, out, visited):
+        val = repr(self.proxyval(visited))
+        if sys.version_info[0] >= 3:
+            val = val.encode('ascii', 'backslashreplace').decode('ascii')
+        # This ensures the 'u' prefix is printed when gdb is linked
+        # with a Python 3 interpreter.
+        out.write('u')
+        out.write(val.lstrip('u'))
+
 
 def int_from_int(gdbval):
     return int(str(gdbval))
@@ -1295,12 +1328,12 @@
 
         frame = Frame.get_selected_python_frame()
         if not frame:
-            print 'Unable to locate python frame'
+            print('Unable to locate python frame')
             return
 
         pyop = frame.get_pyop()
         if not pyop or pyop.is_optimized_out():
-            print 'Unable to read information on python frame'
+            print('Unable to read information on python frame')
             return
 
         filename = pyop.filename()
@@ -1350,9 +1383,9 @@
         frame = iter_frame
 
     if move_up:
-        print 'Unable to find an older python frame'
+        print('Unable to find an older python frame')
     else:
-        print 'Unable to find a newer python frame'
+        print('Unable to find a newer python frame')
 
 class PyUp(gdb.Command):
     'Select and print the python stack frame that called this one (if any)'
@@ -1415,23 +1448,23 @@
 
         frame = Frame.get_selected_python_frame()
         if not frame:
-            print 'Unable to locate python frame'
+            print('Unable to locate python frame')
             return
 
         pyop_frame = frame.get_pyop()
         if not pyop_frame:
-            print 'Unable to read information on python frame'
+            print('Unable to read information on python frame')
             return
 
         pyop_var, scope = pyop_frame.get_var_by_name(name)
 
         if pyop_var:
-            print ('%s %r = %s'
+            print('%s %r = %s'
                    % (scope,
                       name,
                       pyop_var.get_truncated_repr(MAX_OUTPUT_LEN)))
         else:
-            print '%r not found' % name
+            print('%r not found' % name)
 
 PyPrint()
 
@@ -1449,16 +1482,16 @@
 
         frame = Frame.get_selected_python_frame()
         if not frame:
-            print 'Unable to locate python frame'
+            print('Unable to locate python frame')
             return
 
         pyop_frame = frame.get_pyop()
         if not pyop_frame:
-            print 'Unable to read information on python frame'
+            print('Unable to read information on python frame')
             return
 
         for pyop_name, pyop_value in pyop_frame.iter_locals():
-            print ('%s = %s'
+            print('%s = %s'
                    % (pyop_name.proxyval(set()),
                       pyop_value.get_truncated_repr(MAX_OUTPUT_LEN)))
 
diff -r 3a1db0d2747e Tools/i18n/makelocalealias.py
--- a/Tools/i18n/makelocalealias.py
+++ b/Tools/i18n/makelocalealias.py
@@ -23,6 +23,12 @@
         if line[:1] == '#':
             continue
         locale, alias = line.split()
+        # Fix non-standard locale names, e.g. ks_IN@devanagari.UTF-8
+        if '@' in alias:
+            alias_lang, _, alias_mod = alias.partition('@')
+            if '.' in alias_mod:
+                alias_mod, _, alias_enc = alias_mod.partition('.')
+                alias = alias_lang + '.' + alias_enc + '@' + alias_mod
         # Strip ':'
         if locale[-1] == ':':
             locale = locale[:-1]
diff -r 3a1db0d2747e Tools/i18n/pygettext.py
--- a/Tools/i18n/pygettext.py
+++ b/Tools/i18n/pygettext.py
@@ -1,6 +1,6 @@
 #! /usr/bin/env python
 # -*- coding: iso-8859-1 -*-
-# Originally written by Barry Warsaw <barry@zope.com>
+# Originally written by Barry Warsaw <barry@python.org>
 #
 # Minimally patched to make it even more xgettext compatible
 # by Peter Funk <pf@artcom-gmbh.de>
diff -r 3a1db0d2747e Tools/msi/uuids.py
--- a/Tools/msi/uuids.py
+++ b/Tools/msi/uuids.py
@@ -63,4 +63,6 @@
     '2.7.5150':'{DBDD570E-0952-475f-9453-AB88F3DD5659}', # 2.7.5
     '2.7.6121':'{D1EBC07F-A7B1-4163-83DB-AE813CEF392F}', # 2.7.6rc1
     '2.7.6150':'{C3CC4DF5-39A5-4027-B136-2B3E1F5AB6E2}', # 2.7.6
+    '2.7.7121':'{5E0D187D-238B-4e96-9C75-C4CF141F5385}', # 2.7.7rc1
+    '2.7.7150':'{049CA433-77A0-4e48-AC76-180A282C4E10}', # 2.7.7
 }
diff -r 3a1db0d2747e config.guess
--- a/config.guess
+++ b/config.guess
@@ -1,10 +1,8 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
-#   2011, 2012, 2013 Free Software Foundation, Inc.
+#   Copyright 1992-2013 Free Software Foundation, Inc.
 
-timestamp='2012-12-29'
+timestamp='2013-06-10'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -26,7 +24,7 @@
 # program.  This Exception is an additional permission under section 7
 # of the GNU General Public License, version 3 ("GPLv3").
 #
-# Originally written by Per Bothner. 
+# Originally written by Per Bothner.
 #
 # You can get the latest version of this script from:
 # http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
@@ -52,9 +50,7 @@
 GNU config.guess ($timestamp)
 
 Originally written by Per Bothner.
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011,
-2012, 2013 Free Software Foundation, Inc.
+Copyright 1992-2013 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -136,6 +132,27 @@
 UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
 UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
 
+case "${UNAME_SYSTEM}" in
+Linux|GNU|GNU/*)
+	# If the system lacks a compiler, then just pick glibc.
+	# We could probably try harder.
+	LIBC=gnu
+
+	eval $set_cc_for_build
+	cat <<-EOF > $dummy.c
+	#include <features.h>
+	#if defined(__UCLIBC__)
+	LIBC=uclibc
+	#elif defined(__dietlibc__)
+	LIBC=dietlibc
+	#else
+	LIBC=gnu
+	#endif
+	EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC'`
+	;;
+esac
+
 # Note: order is significant - the case branches are not exclusive.
 
 case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
@@ -857,21 +874,21 @@
 	exit ;;
     *:GNU:*:*)
 	# the GNU system
-	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
+	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-${LIBC}`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
 	exit ;;
     *:GNU/*:*:*)
 	# other systems with GNU libc and userland
-	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu
+	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-${LIBC}
 	exit ;;
     i*86:Minix:*:*)
 	echo ${UNAME_MACHINE}-pc-minix
 	exit ;;
     aarch64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     aarch64_be:Linux:*:*)
 	UNAME_MACHINE=aarch64_be
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     alpha:Linux:*:*)
 	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
@@ -884,59 +901,54 @@
 	  EV68*) UNAME_MACHINE=alphaev68 ;;
 	esac
 	objdump --private-headers /bin/sh | grep -q ld.so.1
-	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
-	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
+	if test "$?" = 0 ; then LIBC="gnulibc1" ; fi
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    arc:Linux:*:* | arceb:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     arm*:Linux:*:*)
 	eval $set_cc_for_build
 	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
 	    | grep -q __ARM_EABI__
 	then
-	    echo ${UNAME_MACHINE}-unknown-linux-gnu
+	    echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	else
 	    if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
 		| grep -q __ARM_PCS_VFP
 	    then
-		echo ${UNAME_MACHINE}-unknown-linux-gnueabi
+		echo ${UNAME_MACHINE}-unknown-linux-${LIBC}eabi
 	    else
-		echo ${UNAME_MACHINE}-unknown-linux-gnueabihf
+		echo ${UNAME_MACHINE}-unknown-linux-${LIBC}eabihf
 	    fi
 	fi
 	exit ;;
     avr32*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     cris:Linux:*:*)
-	echo ${UNAME_MACHINE}-axis-linux-gnu
+	echo ${UNAME_MACHINE}-axis-linux-${LIBC}
 	exit ;;
     crisv32:Linux:*:*)
-	echo ${UNAME_MACHINE}-axis-linux-gnu
+	echo ${UNAME_MACHINE}-axis-linux-${LIBC}
 	exit ;;
     frv:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     hexagon:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     i*86:Linux:*:*)
-	LIBC=gnu
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#ifdef __dietlibc__
-	LIBC=dietlibc
-	#endif
-EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC'`
-	echo "${UNAME_MACHINE}-pc-linux-${LIBC}"
+	echo ${UNAME_MACHINE}-pc-linux-${LIBC}
 	exit ;;
     ia64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     m32r*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     m68*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     mips:Linux:*:* | mips64:Linux:*:*)
 	eval $set_cc_for_build
@@ -955,54 +967,63 @@
 	#endif
 EOF
 	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^CPU'`
-	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
+	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-${LIBC}"; exit; }
 	;;
+    or1k:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
     or32:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     padre:Linux:*:*)
-	echo sparc-unknown-linux-gnu
+	echo sparc-unknown-linux-${LIBC}
 	exit ;;
     parisc64:Linux:*:* | hppa64:Linux:*:*)
-	echo hppa64-unknown-linux-gnu
+	echo hppa64-unknown-linux-${LIBC}
 	exit ;;
     parisc:Linux:*:* | hppa:Linux:*:*)
 	# Look for CPU level
 	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
-	  PA7*) echo hppa1.1-unknown-linux-gnu ;;
-	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
-	  *)    echo hppa-unknown-linux-gnu ;;
+	  PA7*) echo hppa1.1-unknown-linux-${LIBC} ;;
+	  PA8*) echo hppa2.0-unknown-linux-${LIBC} ;;
+	  *)    echo hppa-unknown-linux-${LIBC} ;;
 	esac
 	exit ;;
     ppc64:Linux:*:*)
-	echo powerpc64-unknown-linux-gnu
+	echo powerpc64-unknown-linux-${LIBC}
 	exit ;;
     ppc:Linux:*:*)
-	echo powerpc-unknown-linux-gnu
+	echo powerpc-unknown-linux-${LIBC}
+	exit ;;
+    ppc64le:Linux:*:*)
+	echo powerpc64le-unknown-linux-${LIBC}
+	exit ;;
+    ppcle:Linux:*:*)
+	echo powerpcle-unknown-linux-${LIBC}
 	exit ;;
     s390:Linux:*:* | s390x:Linux:*:*)
-	echo ${UNAME_MACHINE}-ibm-linux
+	echo ${UNAME_MACHINE}-ibm-linux-${LIBC}
 	exit ;;
     sh64*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     sh*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     sparc:Linux:*:* | sparc64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     tile*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     vax:Linux:*:*)
-	echo ${UNAME_MACHINE}-dec-linux-gnu
+	echo ${UNAME_MACHINE}-dec-linux-${LIBC}
 	exit ;;
     x86_64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     xtensa*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     i*86:DYNIX/ptx:4*:*)
 	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
@@ -1235,19 +1256,21 @@
 	exit ;;
     *:Darwin:*:*)
 	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
-	case $UNAME_PROCESSOR in
-	    i386)
-		eval $set_cc_for_build
-		if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
-		  if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
-		      (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
-		      grep IS_64BIT_ARCH >/dev/null
-		  then
-		      UNAME_PROCESSOR="x86_64"
-		  fi
-		fi ;;
-	    unknown) UNAME_PROCESSOR=powerpc ;;
-	esac
+	eval $set_cc_for_build
+	if test "$UNAME_PROCESSOR" = unknown ; then
+	    UNAME_PROCESSOR=powerpc
+	fi
+	if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
+	    if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
+		(CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
+		grep IS_64BIT_ARCH >/dev/null
+	    then
+		case $UNAME_PROCESSOR in
+		    i386) UNAME_PROCESSOR=x86_64 ;;
+		    powerpc) UNAME_PROCESSOR=powerpc64 ;;
+		esac
+	    fi
+	fi
 	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
 	exit ;;
     *:procnto*:*:* | *:QNX:[0123456789]*:*)
diff -r 3a1db0d2747e config.sub
--- a/config.sub
+++ b/config.sub
@@ -1,10 +1,8 @@
 #! /bin/sh
 # Configuration validation subroutine script.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
-#   2011, 2012, 2013 Free Software Foundation, Inc.
+#   Copyright 1992-2013 Free Software Foundation, Inc.
 
-timestamp='2012-12-29'
+timestamp='2013-08-10'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -70,9 +68,7 @@
 version="\
 GNU config.sub ($timestamp)
 
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011,
-2012, 2013 Free Software Foundation, Inc.
+Copyright 1992-2013 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -256,12 +252,12 @@
 	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
 	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
 	| am33_2.0 \
-	| arc \
+	| arc | arceb \
 	| arm | arm[bl]e | arme[lb] | armv[2-8] | armv[3-8][lb] | armv7[arm] \
 	| avr | avr32 \
 	| be32 | be64 \
 	| bfin \
-	| c4x | clipper \
+	| c4x | c8051 | clipper \
 	| d10v | d30v | dlx | dsp16xx \
 	| epiphany \
 	| fido | fr30 | frv \
@@ -290,16 +286,17 @@
 	| mipsisa64r2 | mipsisa64r2el \
 	| mipsisa64sb1 | mipsisa64sb1el \
 	| mipsisa64sr71k | mipsisa64sr71kel \
+	| mipsr5900 | mipsr5900el \
 	| mipstx39 | mipstx39el \
 	| mn10200 | mn10300 \
 	| moxie \
 	| mt \
 	| msp430 \
 	| nds32 | nds32le | nds32be \
-	| nios | nios2 \
+	| nios | nios2 | nios2eb | nios2el \
 	| ns16k | ns32k \
 	| open8 \
-	| or32 \
+	| or1k | or32 \
 	| pdp10 | pdp11 | pj | pjl \
 	| powerpc | powerpc64 | powerpc64le | powerpcle \
 	| pyramid \
@@ -369,13 +366,13 @@
 	| aarch64-* | aarch64_be-* \
 	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
 	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
-	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \
+	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* | arceb-* \
 	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
 	| avr-* | avr32-* \
 	| be32-* | be64-* \
 	| bfin-* | bs2000-* \
 	| c[123]* | c30-* | [cjt]90-* | c4x-* \
-	| clipper-* | craynv-* | cydra-* \
+	| c8051-* | clipper-* | craynv-* | cydra-* \
 	| d10v-* | d30v-* | dlx-* \
 	| elxsi-* \
 	| f30[01]-* | f700-* | fido-* | fr30-* | frv-* | fx80-* \
@@ -407,12 +404,13 @@
 	| mipsisa64r2-* | mipsisa64r2el-* \
 	| mipsisa64sb1-* | mipsisa64sb1el-* \
 	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
+	| mipsr5900-* | mipsr5900el-* \
 	| mipstx39-* | mipstx39el-* \
 	| mmix-* \
 	| mt-* \
 	| msp430-* \
 	| nds32-* | nds32le-* | nds32be-* \
-	| nios-* | nios2-* \
+	| nios-* | nios2-* | nios2eb-* | nios2el-* \
 	| none-* | np1-* | ns16k-* | ns32k-* \
 	| open8-* \
 	| orion-* \
@@ -796,7 +794,7 @@
 		os=-mingw64
 		;;
 	mingw32)
-		basic_machine=i386-pc
+		basic_machine=i686-pc
 		os=-mingw32
 		;;
 	mingw32ce)
@@ -832,7 +830,7 @@
 		basic_machine=`echo $basic_machine | sed -e 's/ms1-/mt-/'`
 		;;
 	msys)
-		basic_machine=i386-pc
+		basic_machine=i686-pc
 		os=-msys
 		;;
 	mvs)
@@ -1354,7 +1352,7 @@
 	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
 	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -cnk* | -sunos | -sunos[34]*\
 	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -auroraux* | -solaris* \
-	      | -sym* | -kopensolaris* \
+	      | -sym* | -kopensolaris* | -plan9* \
 	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
 	      | -aos* | -aros* \
 	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
@@ -1500,9 +1498,6 @@
 	-aros*)
 		os=-aros
 		;;
-	-kaos*)
-		os=-kaos
-		;;
 	-zvmoe)
 		os=-zvmoe
 		;;
@@ -1551,6 +1546,9 @@
 	c4x-* | tic4x-*)
 		os=-coff
 		;;
+	c8051-*)
+		os=-elf
+		;;
 	hexagon-*)
 		os=-elf
 		;;
@@ -1594,6 +1592,9 @@
 	mips*-*)
 		os=-elf
 		;;
+	or1k-*)
+		os=-elf
+		;;
 	or32-*)
 		os=-coff
 		;;
